{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Accueil","text":"<p>Introduction par l'exemple \u00e0 Entity Framework 5 Code First</p> <p>Serge Tah\u00e9, octobre 2012</p> <p>Ce site a \u00e9t\u00e9 cr\u00e9\u00e9 avec le convertisseur [Word ou ODT - &gt; HTML] cr\u00e9\u00e9 par l\u2019IA Gemini 3 en janvier 2026.</p>"},{"location":"conclusion.html","title":"8. Conclusion","text":"<p>Dans ce document, nous avons tout d'abord d\u00e9couvert Entity Framework 5 Code First (EF 5). Puis nous avons port\u00e9 l'application suivante qui utilisait l'ORM NHibernate\u00a0:</p> <p>dans l'architecture suivante qui utilise l'ORM EF 5\u00a0:</p> <p>Nous avons construit cette derni\u00e8re architecture avec cinq SGBD. Si la portabilit\u00e9 entre SGBD n'a pas \u00e9t\u00e9 toujours de 100\u00a0%, elle a \u00e9t\u00e9 toutefois extr\u00eamement satisfaisante. </p> <p>Nous avons appris quelques principes\u00a0:</p> <ul> <li>tous les SGBD \u00e9tudi\u00e9s ont une solution pour g\u00e9n\u00e9rer automatiquement les valeurs des cl\u00e9s primaires\u00a0;</li> <li>pour g\u00e9rer la concurrence d'acc\u00e8s aux entit\u00e9s en base, il semble qu'une colonne de type entier incr\u00e9ment\u00e9e automatiquement par des triggers soit une solution accept\u00e9e par tous\u00a0;</li> <li>lorsqu'on est en mode Lazy Loading, il est important que les entit\u00e9s encapsulent les valeurs des cl\u00e9s \u00e9trang\u00e8res qui leur sont li\u00e9es. Cela permet ensuite d'aller chercher en base les d\u00e9pendances de l'entit\u00e9.</li> </ul>"},{"location":"etude-de-cas-avec--firebird-21.html","title":"7. Etude de cas avec  Firebird 2.1","text":""},{"location":"etude-de-cas-avec--firebird-21.html#71-installation-des-outils","title":"7.1. Installation des outils","text":"<p>Les outils \u00e0 installer sont les suivants\u00a0:</p> <ul> <li>le SGBD\u00a0: [http://www.firebirdsql.org/en/firebird-2-1-5/]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for InterBase/Firebird Freeware [http://www.sqlmanager.net/fr/products/ibfb/manager/download].</li> </ul> <p>Dans les exemples qui suivent, l'utilisateur est sysdba avec le mot de passe masterkey.</p> <p>Lan\u00e7ons Firebird puis l'outil [SQL Manager Lite for Firebird] avec lequel on va administrer le SGBD.</p> <ul> <li>en [1], nous lan\u00e7ons le SGBD Firebird \u00e0 partir du Menu D\u00e9marrer. Ici, le SGBD n'a pas \u00e9t\u00e9 install\u00e9 comme un service Windows\u00a0;</li> <li>en [2], le service est d\u00e9marr\u00e9. Une ic\u00f4ne s'est install\u00e9e en bas \u00e0 droite de l'\u00e9cran. Avec un clic droit sur celle-ci, on peut arr\u00eater le SGBD.</li> </ul> <p>Nous lan\u00e7ons maintenant l'outil [SQL Manager Lite for Firebird] avec lequel on va administrer le SGBD [3].</p> <ul> <li>en [4], nous cr\u00e9ons une nouvelle base\u00a0;</li> <li>en [5], on accepte\u00a0;</li> </ul> <ul> <li>en [5], on se connecte en tant que SYSDBA / masterkey\u00a0;</li> <li>en [6], on d\u00e9signe l'emplacement du fichier qui va \u00eatre cr\u00e9\u00e9. En effet, la base va \u00eatre cr\u00e9\u00e9e dans un unique fichier\u00a0;</li> <li>en [7], on valide l'ordre SQL qui va \u00eatre ex\u00e9cut\u00e9\u00a0;</li> </ul> <ul> <li>en [8], la base a \u00e9t\u00e9 cr\u00e9\u00e9e. Elle doit maintenant \u00eatre enregistr\u00e9e dans [EMS Manager]. Les informations sont bonnes. On fait [OK]\u00a0;</li> <li>en [9], on s'y connecte\u00a0;</li> <li>en [10], [EMS Manager] affiche la base, pour l'instant vide.</li> </ul> <p>Nous allons maintenant connecter un projet VS 2012 \u00e0 cette base.</p>"},{"location":"etude-de-cas-avec--firebird-21.html#72-creation-de-la-base-a-partir-des-entites","title":"7.2. Cr\u00e9ation de la base \u00e0 partir des entit\u00e9s","text":"<p>Nous commen\u00e7ons par dupliquer le dossier du projet [RdvMedecins-SqlServer-01] dans [RdvMedecins-Firebird-01] [1]\u00a0:</p> <ul> <li>en [2], dans VS 2012, nous supprimons le projet [RdvMedecins-SqlServer-01] de la solution\u00a0;</li> </ul> <ul> <li>en [3], le projet a \u00e9t\u00e9 supprim\u00e9\u00a0;</li> <li>en [4], on en rajoute un autre. Celui-ci est pris dans le dossier [RdvMedecins-Firebird-01] que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment\u00a0;</li> </ul> <ul> <li>en [5], le projet charg\u00e9 s'appelle [RdvMedecins-SqlServer-01]\u00a0;</li> <li>en [6], on change son nom en [RdvMedecins-Firebird-01]</li> </ul> <ul> <li>en [7], on rajoute un autre projet \u00e0 la solution. Celui-ci est pris dans le dossier [RdvMedecins-SqlServer-01] du projet que nous avons  supprim\u00e9 de la solution pr\u00e9c\u00e9demment\u00a0;</li> <li>en [8], le projet [RdvMedecins-SqlServer-01] a r\u00e9int\u00e9gr\u00e9 la solution.</li> </ul> <p>Le projet [RdvMedecins-Firebird-01] est identique au projet [RdvMedecins-SqlServer-01]. Il nous faut faire quelques modifications. Dans [App.config], nous allons modifier la cha\u00eene de connexion et le [DbProviderFactory] qu'on doit adapter \u00e0 chaque SGBD.</p> <pre><code>&lt;!-- cha\u00eene de connexion sur la base --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\" connectionString=\"User=SYSDBA;Password=masterkey;Database=D:\\data\\istia-1213\\c#\\dvp\\Entity Framework\\databases\\firebird\\RDVMEDECINS-EF.GDB;DataSource=localhost;\nPort=3050;Dialect=3;Charset=NONE;Role=;Connection lifetime=15;Pooling=true;MinPoolSize=0;MaxPoolSize=50;Packet Size=8192;ServerType=0;\" providerName=\"FirebirdSql.Data.FirebirdClient\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"Firebird Client Data Provider\" invariant=\"FirebirdSql.Data.FirebirdClient\" description=\".Net Framework Data Provider for Firebird\" type=\"FirebirdSql.Data.FirebirdClient.FirebirdClientFactory, FirebirdSql.Data.FirebirdClient, Version=2.7.7.0, Culture=neutral, PublicKeyToken=3750abcc3150b00c\" /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n</code></pre> <ul> <li>ligne 3\u00a0: l'utilisateur et son mot de passe, ainsi que le chemin complet de la base Firebird\u00a0;</li> <li>lignes8-10\u00a0: le DbProviderFactory. La ligne 9 r\u00e9f\u00e9rence une DLL [FirebirdSql.Data.FirebirdClient] que nous n'avons pas. On se la procure avec NuGet [1]\u00a0:</li> </ul> <ul> <li>en [2], dans la zone de recherche on tape le mot cl\u00e9 firebird\u00a0;</li> <li>en [3], on choisit le paquetage [Firebird ADO.NET Data Provider]. C'est un connecteur ADO.NET pour Firebird\u00a0;</li> </ul> <ul> <li>en [4], la nouvelle r\u00e9f\u00e9rence\u00a0;</li> <li>en [5], dans [App.config], il faut mettre la version correcte de la DLL. On la trouve dans ses propri\u00e9t\u00e9s.</li> </ul> <p>Dans le fichier [Entites.cs], il faut adapter le sch\u00e9ma des tables qui vont \u00eatre g\u00e9n\u00e9r\u00e9es\u00a0:</p> <pre><code>  [Table(\"MEDECINS\")]\n  public class Medecin : Personne\n  {...}\n\n  [Table(\"CLIENTS\")]\n  public class Client : Personne\n  {...}\n\n  [Table(\"CRENEAUX\")]\n  public class Creneau\n  {...}\n\n  [Table(\"RVS\")]\n  public class Rv\n  {...}\n</code></pre> <p>Ici, les tables n'ont pas de sch\u00e9ma.</p> <p>Nous configurons l'ex\u00e9cution du projet\u00a0:</p> <ul> <li>en [1], on donne un autre nom \u00e0 l'assembly qui va \u00eatre g\u00e9n\u00e9r\u00e9\u00a0;</li> <li>en [2], ainsi qu'un autre espace de noms par d\u00e9faut\u00a0;</li> <li>en [3], on d\u00e9signe le programme \u00e0 ex\u00e9cuter.</li> </ul> <p>A ce stade, il n'y a pas d'erreurs de compilation. Ex\u00e9cutons le programme [CreateDB_01]. On obtient l'exception suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: System.Data.MetadataException: Le sch\u00e9ma sp\u00e9cifi\u00e9 n'est pas valide. Erreurs :\n(11,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(23,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(33,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(43,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n   \u00e0 System.Data.Metadata.Edm.StoreItemCollection.Loader.ThrowOnNonWarningErrors\n()\n   ...\n   \u00e0 RdvMedecins_01.CreateDB_01.Main(String[] args) dans d:\\data\\istia-1213\\c#\\d\nvp\\Entity Framework\\RdvMedecins\\RdvMedecins-Oracle-01\\CreateDB_01.cs:ligne 15\n</code></pre> <p>On se rappelle avoir eu la m\u00eame erreur avec MySQL, Oracle et PostgreSQL. C'est li\u00e9 au type du champ Timestamp des entit\u00e9s. Nous faisons la m\u00eame modification qu'avec les deux SGBD pr\u00e9c\u00e9dents. Dans les entit\u00e9s, nous rempla\u00e7ons les trois lignes</p> <pre><code>    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n</code></pre> <p>par les suivantes\u00a0:</p> <pre><code>    [ConcurrencyCheck]\n    [Column(\"VERSIONING\")]\n    public int? Versioning { get; set; }\n</code></pre> <p>On change donc le type de la colonne qui passe de byte[] \u00e0 int?. Dans le SGBD, nous utiliserons des proc\u00e9dures stock\u00e9es pour incr\u00e9menter cet entier d'une unit\u00e9 \u00e0 chaque fois qu'une ligne sera ins\u00e9r\u00e9e ou modifi\u00e9e.</p> <p>Nous faisons la modification pr\u00e9c\u00e9dente pour les quatre entit\u00e9s puis nous r\u00e9ex\u00e9cutons l'application. Nous obtenons alors l'erreur suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: FirebirdSql.Data.FirebirdClient.FbException: lock time-out on wait transaction object D:\\DATA\\ISTIA-1213\\C#\\DVP\\ENTITY FRAMEWORK\\DATABASES\\FIREBIRD\\RDVMEDECINS-EF.GDB is in use ---&gt; FirebirdSql.Data.Common.IscException: lock time-out on wait transaction\nobject D:\\DATA\\ISTIA-1213\\C#\\DVP\\ENTITY FRAMEWORK\\DATABASES\\FIREBIRD\\RDVMEDECINS\n-EF.GDB is in use\n...\n   \u00e0 RdvMedecins_01.CreateDB_01.Main(String[] args) dans d:\\data\\istia-1213\\c#\\dvp\\Entity Framework\\RdvMedecins\\RdvMedecins-Firebird-01\\CreateDB_01.cs:ligne 15\n</code></pre> <p>La ligne 1 indique que la base est utilis\u00e9e. Ce n'\u00e9tait pas le cas me semble-t-il et je n'ai pas r\u00e9ussi \u00e0 r\u00e9gler ce probl\u00e8me.</p> <p>Peu importe. Nous allons construire la base de donn\u00e9es [RDVMEDECINS-EF] \u00e0 la main avec l'outil [EMS Manager for Firebird]. Nous ne d\u00e9crivons pas toutes les \u00e9tapes mais simplement les plus importantes.</p> <p>La base Firebird sera la suivante\u00a0:</p> <p>Les tables</p> <ul> <li>en [1], ID est une cl\u00e9 primaire avec l'attribut Autoincrement. Elle sera g\u00e9n\u00e9r\u00e9e automatiquement par le SGBD\u00a0;</li> </ul> <p>Les diff\u00e9rentes tables ont les cl\u00e9s primaires et \u00e9trang\u00e8res qu'avaient ces m\u00eames tables dans les exemples pr\u00e9c\u00e9dents. Les cl\u00e9s \u00e9trang\u00e8res ont l'attribut ON DELETE CASCADE.</p> <p>Les g\u00e9n\u00e9rateurs</p> <p>Comme avec Oracle et PostgreSQL, nous avons cr\u00e9\u00e9 des g\u00e9n\u00e9rateurs de nombres cons\u00e9cutifs. Il y en a 5 [1].</p> <ul> <li>[CLIENTS_ID_GEN] sera utilis\u00e9 pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [CLIENTS]\u00a0;</li> <li>[MEDECINS_ID_GEN] sera utilis\u00e9 pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [MEDECINS]\u00a0;</li> <li>[CRENEAUX_ID_GEN] sera utilis\u00e9 pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [CRENEAUX]\u00a0;</li> <li>[RVS_ID_GEN] sera utilis\u00e9 pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [RVS]\u00a0;</li> <li>[VERSIONS_GEN] sera utilis\u00e9 pour g\u00e9n\u00e9rer les valeurs des colonnes [VERSIONING] de toutes les tables.</li> </ul> <p>Les triggers</p> <p>Un trigger est une proc\u00e9dure ex\u00e9cut\u00e9e par le SGBD avant ou apr\u00e8s un \u00e9v\u00e9nement (Insertion, Modification, Suppression) dans une table. Nous en avons 8 [1]\u00a0:</p> <p>Regardons le code DDL du trigger [BI_CLIENTS_ID] qui alimente la colonne [ID] de la table [CLIENTS]\u00a0:</p> <pre><code>CREATE TRIGGER BI_CLIENTS_ID FOR CLIENTS\nACTIVE BEFORE INSERT\nPOSITION 0\nAS\nBEGIN\n  IF (NEW.ID IS NULL) THEN\n      NEW.ID = GEN_ID(CLIENTS_ID_GEN, 1);\nEND^\n</code></pre> <ul> <li>ligne 2\u00a0: avant chaque insertion dans la table [CLIENTS]\u00a0;</li> <li>lignes 6-7\u00a0: si la colonne ID est NULL, alors on lui affecte la valeur suivante du g\u00e9n\u00e9rateur de nombres [CLIENTS_ID_GEN].</li> </ul> <p>Les triggers [ BI_CLIENTS_ID,  BI_MEDECINS_ID,  BI_CRENEAUX_ID,  BI_RVS_ID] sont tous construits de la m\u00eame fa\u00e7on.</p> <p>Regardons maintenant le code DDL du trigger [CLIENTS_VERSION_TRIGGER] qui alimente la colonne [VERSIONING] de la table [CLIENTS]\u00a0:</p> <pre><code>CREATE TRIGGER CLIENTS_VERSION_TRIGGER FOR CLIENTS\nACTIVE BEFORE INSERT OR UPDATE\nPOSITION 1\nAS\nBEGIN\n  NEW.\"VERSIONING\" = GEN_ID(VERSIONS_GEN,1);\nEND^\n</code></pre> <ul> <li>lignes 1-3\u00a0: avant chaque op\u00e9ration INSERT ou UPDATE sur la table [CLIENTS]\u00a0;</li> <li>ligne 6\u00a0: la colonne [\"VERSIONING\"] re\u00e7oit la valeur suivante du g\u00e9n\u00e9rateur de nombres [VERSIONS_GEN]. Ce g\u00e9n\u00e9rateur alimente les colonnes [\"VERSIONING\"] des quatre tables.</li> </ul> <p>Les triggers [MEDECINS_VERSION_TRIGGER, CRENEAUX_VERSION_TRIGGER, RVS_VERSION_TRIGGER] sont analogues.</p> <p>Le script de g\u00e9n\u00e9ration des tables de la base Firebird [RDVMEDECINS-EF] a \u00e9t\u00e9 plac\u00e9 dans le dossier [RdvMedecins / databases / Firebird]. Le lecteur pourra le charger et l'ex\u00e9cuter pour cr\u00e9er ses tables.</p> <p>Ceci fait, les diff\u00e9rents programmes du projet peuvent \u00eatre ex\u00e9cut\u00e9s. Ils donnent les m\u00eames r\u00e9sultats qu'avec SQL Server sauf pour le programme [ModifyDetachedEntities] qui plante pour la m\u00eame raison qu'il avait plant\u00e9 avec Oracle et MySQL. On r\u00e9soud le probl\u00e8me de la m\u00eame fa\u00e7on. Il suffit de copier le programme [ModifyDetachedEntities] du projet [RdvMedecins-Oracle-01] dans le projet [RdvMedecins-Firebird-01].</p>"},{"location":"etude-de-cas-avec--firebird-21.html#73-architecture-multi-couche-sappuyant-sur-ef-5","title":"7.3. Architecture multi-couche s'appuyant sur EF 5","text":"<p>Nous revenons \u00e0 notre \u00e9tude de cas d\u00e9crite au paragraphe 2.</p> <p>Nous allons commencer par construire la couche [DAO] d'acc\u00e8s aux donn\u00e9es. Pour ce faire, nous dupliquons le projet console VS 2012 [RdvMedecins-SqlServer-02] dans [RdvMedecins-Firebird-02] [1]\u00a0:</p> <ul> <li>en [2], on supprime le projet [RdvMedecins-SqlServer-02]\u00a0;</li> </ul> <ul> <li>en [3], on ajoute un projet existant \u00e0 la solution. On le prend dans le dossier [RdvMedecins-Firebird-02] qui vient d'\u00eatre cr\u00e9\u00e9\u00a0;</li> <li>en [4], le nouveau projet porte le nom de celui qui a \u00e9t\u00e9 supprim\u00e9. On va changer son nom\u00a0;</li> </ul> <ul> <li>en [5], on a chang\u00e9 le nom du projet\u00a0;</li> <li>en [6], on modifie certaines de ses propri\u00e9t\u00e9s, comme ici le nom de l'assembly\u00a0;</li> <li>en [7], le dossier [Models] est supprim\u00e9 pour \u00eatre remplac\u00e9 par le dossier [Models] du projet [RdvMedecins-Firebird-01]. En effet, les deux projets partagent les m\u00eames mod\u00e8les.</li> </ul> <ul> <li>en [8], les r\u00e9f\u00e9rences actuelles du projet\u00a0;</li> <li>en [9], on y a ajout\u00e9 le connecteur ADO.NET de Firebird avec l'outil NuGet.</li> </ul> <p>Dans le fichier [App.config], on remplace les informations de la base SQL Server par celles de la base Firebird. On les trouve dans le fichier [App.config] du projet [RdvMedecins-Firebird-01]\u00a0:</p> <pre><code>&lt;!-- cha\u00eene de connexion sur la base --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\" connectionString=\"User=SYSDBA;Password=masterkey;Database=D:\\data\\istia-1213\\c#\\dvp\\Entity Framework\\databases\\firebird\\RDVMEDECINS-EF.GDB;DataSource=localhost;\nPort=3050;Dialect=3;Charset=NONE;Role=;Connection lifetime=15;Pooling=true;MinPoolSize=0;MaxPoolSize=50;Packet Size=8192;ServerType=0;\" providerName=\"FirebirdSql.Data.FirebirdClient\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"Firebird Client Data Provider\" invariant=\"FirebirdSql.Data.FirebirdClient\" description=\".Net Framework Data Provider for Firebird\" type=\"FirebirdSql.Data.FirebirdClient.FirebirdClientFactory, FirebirdSql.Data.FirebirdClient, Version=2.7.7.0, Culture=neutral, PublicKeyToken=3750abcc3150b00c\" /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n</code></pre> <p>Les objets g\u00e9r\u00e9s par Spring changent \u00e9galement. Actuellement on a\u00a0:</p> <pre><code>  &lt;!-- configuration Spring --&gt;\n  &lt;spring&gt;\n    &lt;context&gt;\n      &lt;resource uri=\"config://spring/objects\" /&gt;\n    &lt;/context&gt;\n    &lt;objects xmlns=\"http://www.springframework.net\"&gt;\n      &lt;object id=\"rdvmedecinsDao\" type=\"RdvMedecins.Dao.Dao,RdvMedecins-SqlServer-02\" /&gt;\n    &lt;/objects&gt;\n&lt;/spring&gt;\n</code></pre> <p>La ligne 7 r\u00e9f\u00e9rence l'assembly du projet [RdvMedecins-SqlServer-02]. L'assembly est d\u00e9sormais [RdvMedecins-Firebird-02].</p> <p>Ceci fait, nous sommes pr\u00eats \u00e0 ex\u00e9cuter le test de la couche [DAO]. Il faut auparavant prendre soin de remplir la base (programme [Fill] du projet [RdvMedecins-Firebird-01]. Le programme de test passe.</p> <p>Nous cr\u00e9ons la DLL du projet comme il a \u00e9t\u00e9 fait pour le projet [RdvMedecins-SqlServer-02] et nous rassemblons l'ensemble des DLL du projet dans un dossier [lib] cr\u00e9\u00e9 dans [RdvMedecins-Firebird-02]. Ce seront les r\u00e9f\u00e9rences du projet web [RdvMedecins-Firebird-03] qui va suivre.</p> <p>Nous sommes d\u00e9sormais pr\u00eats pour construire la couche [ASP.NET] de notre aplication\u00a0:</p> <p>Nous allons partir du projet [RdvMedecins-SqlServer-03]. Nous dupliquons le dossier de ce projet dans [RdvMedecins-Firebird-03] [1]\u00a0:</p> <ul> <li>en [2], avec VS 2012 Express pour le web, nous ouvrons la solution du dossier [RdvMedecins-Firebird-03]\u00a0;</li> <li>en [3], nous changeons et le nom de la solution et le nom du projet\u00a0;</li> </ul> <ul> <li>en [4], les r\u00e9f\u00e9rences actuellesdu projet\u00a0;</li> <li>en [5], on les supprime\u00a0;</li> <li>en [6], pour les remplacer par des r\u00e9f\u00e9rences sur les DLL que nous venons de stocker dans un dossier [lib] du projet [RdvMedecins-Firebird-02].</li> </ul> <p>Il ne nous reste plus qu'\u00e0 modifier le fichier [Web.config] On remplace son contenu actuel par le contenu du fichier [App.config] du projet [RdvMedecins-Firebird-02]. Ceci fait, on ex\u00e9cute le projet web. Il marche. On n'oubliera pas de remplir la base avant d'ex\u00e9cuter l'application web.</p>"},{"location":"etude-de-cas-avec--oracle-database-express-edition-11g-release-2.html","title":"5. Etude de cas avec  Oracle Database Express Edition 11g Release 2","text":""},{"location":"etude-de-cas-avec--oracle-database-express-edition-11g-release-2.html#51-installation-des-outils","title":"5.1. Installation des outils","text":"<p>Les outils \u00e0 installer sont les suivants\u00a0:</p> <ul> <li>le SGBD\u00a0: [http://www.oracle.com/technetwork/products/express-edition/downloads/index.html]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for Oracle Freeware [http://www.sqlmanager.net/fr/products/oracle/manager/download]\u00a0;</li> <li>un client Oracle pour .NET : ODAC 11.2 Release 5 (11.2.0.3.20) with Oracle Developer Tools for Visual Studio\u00a0: [http://www.oracle.com/technetwork/developer-tools/visual-studio/downloads/index.html].</li> </ul> <p>Dans les exemples qui suivent, l'utilisateur system a le mot de passe system.</p> <p>Lan\u00e7ons Oracle [1] puis l'outil [SQL Manager Lite for Oracle] avec lequel on va administrer le SGBD [2].</p> <ul> <li>en [3], nous nous connectons \u00e0 une base existante\u00a0;</li> </ul> <ul> <li>en [4], nous utilisons le service Oracle XE pour se connecter\u00a0;</li> <li>en [5], on indique le nom de la base XE\u00a0;</li> <li>en [6], on se connecte en tant que system / system\u00a0;</li> <li>en [7], on termine l'assistant\u00a0;</li> </ul> <ul> <li>en [8], on se connecte \u00e0 la base\u00a0;</li> <li>en [9], on est connect\u00e9\u00a0;</li> <li>parce qu'on s'est connect\u00e9 en tant que l'utilisateur system / system qui a des droits \u00e9tendus, nous pourrons par exemple g\u00e9rer les utilisateurs [10]\u00a0;</li> </ul> <ul> <li>en [11], on cr\u00e9e un nouvel utilisateur\u00a0;</li> <li>en [12], il s'appellera [RDVMEDECINS-EF]\u00a0;</li> <li>en [13], et aura le mot de passe rdvmedecins\u00a0;</li> <li>en [14], on valide la cr\u00e9ation de l'utilisateur\u00a0;</li> <li>en [15], l'utilisateur a \u00e9t\u00e9 cr\u00e9\u00e9\u00a0;</li> </ul> <ul> <li>en [16], l'utilisateur [RDVMEDECINS-EF] est \u00e9galement un sch\u00e9ma de base de donn\u00e9es\u00a0;</li> <li>en [17], l'utilisateur tel qu'il a \u00e9t\u00e9 cr\u00e9\u00e9 n'a pas suffisamment de droits. Nous lui en donnons via un script SQL\u00a0;</li> </ul> <ul> <li>en [18], le script ex\u00e9cut\u00e9\u00a0;</li> <li>en [19], on va essayer de se connecter sous l'identit\u00e9 de [RDVMEDECINS-EF] afin de voir ce qu'il peut faire. Pour cela, nous commen\u00e7ons par enregistrer une nouvelle base dans [EMS Manager]\u00a0;</li> </ul> <ul> <li>en [19], on se connecte via le service XE\u00a0;</li> <li>en [20], on se connecte sous l'identit\u00e9 RDVMEDECINS-EF / rdvmedecins\u00a0;</li> <li>en [21], on donne un alias qui refl\u00e8te le nom de l'utilisateur connect\u00e9\u00a0;</li> <li>en [22], on se connecte \u00e0 Oracle avec les informations donn\u00e9es\u00a0;</li> </ul> <ul> <li>en [22], on a r\u00e9ussi \u00e0 se connecter\u00a0;</li> <li>en [23], on essaie de cr\u00e9er une table dans le sch\u00e9ma [RDVMEDECINS-EF]\u00a0;</li> <li>en [24], on d\u00e9finit une table quelconque\u00a0;</li> <li>en [25], on valide sa d\u00e9finition\u00a0;</li> </ul> <ul> <li>en [26], la table a \u00e9t\u00e9 cr\u00e9\u00e9e. On la supprime\u00a0;</li> <li>en [27], elle a \u00e9t\u00e9 supprim\u00e9e.</li> </ul> <p>Maintenant que nous avons un utilisateur avec suffisamment de droits, nous allons cr\u00e9er le projet VS 2012 qui va cr\u00e9er les tables  du sch\u00e9ma [RDVMEDECINS-EF] \u00e0 partir de la d\u00e9finition des entit\u00e9s.</p>"},{"location":"etude-de-cas-avec--oracle-database-express-edition-11g-release-2.html#52-creation-de-la-base-a-partir-des-entites","title":"5.2. Cr\u00e9ation de la base \u00e0 partir des entit\u00e9s","text":"<p>Nous commen\u00e7ons par dupliquer le dossier du projet [RdvMedecins-SqlServer-01] dans [RdvMedecins-Oracle-01] [1]\u00a0:</p> <ul> <li>en [2], dans VS 2012, nous supprimons le projet [RdvMedecins-SqlServer-01] de la solution\u00a0;</li> </ul> <ul> <li>en [3], le projet a \u00e9t\u00e9 supprim\u00e9\u00a0;</li> <li>en [4], on en rajoute un autre. Celui-ci est pris dans le dossier [RdvMedecins-Oracle-01] que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment\u00a0;</li> </ul> <ul> <li>en [5], le projet charg\u00e9 s'appelle [RdvMedecins-SqlServer-01]\u00a0;</li> <li>en [6], on change son nom en [RdvMedecins-Oracle-01]</li> </ul> <ul> <li>en [7], on rajoute un autre projet \u00e0 la solution. Celui-ci est pris dans le dossier [RdvMedecins-SqlServer-01] du projet que nous avons  supprim\u00e9 de la solution pr\u00e9c\u00e9demment\u00a0;</li> <li>en [8], le projet [RdvMedecins-SqlServer-01] a r\u00e9int\u00e9gr\u00e9 la solution.</li> </ul> <p>Le projet [RdvMedecins-Oracle-01] est identique au projet [RdvMedecins-SqlServer-01]. Il nous faut faire quelques modifications. Dans [App.config], nous allons modifier la cha\u00eene de connexion et le [DbProviderFactory] qu'on doit adapter \u00e0 chaque SGBD.</p> <pre><code>&lt;!-- cha\u00eene de connexion sur la base --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\" connectionString=\"Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=XE)));User Id=RDVMEDECINS-EF;Password=rdvmedecins;\" providerName=\"Oracle.DataAccess.Client\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;remove invariant=\"Oracle.DataAccess.Client\" /&gt;\n      &lt;add name=\"Oracle Data Provider for .NET\" invariant=\"Oracle.DataAccess.Client\" description=\"Oracle Data Provider for .NET\" type=\"Oracle.DataAccess.Client.OracleClientFactory, Oracle.DataAccess, Version=4.112.3.0, Culture=neutral, PublicKeyToken=89b483f429c47342\" /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n</code></pre> <ul> <li>ligne 3\u00a0: l'utilisateur et son mot de passe\u00a0;</li> <li>lignes 6-11\u00a0: le DbProviderFactory. La ligne 9 r\u00e9f\u00e9rence une DLL [Oracle.DataAccess] que nous n'avons pas. On se la procure avec NuGet [1]\u00a0:</li> </ul> <ul> <li>en [2], dans la zone de recherche on tape le mot cl\u00e9 oracle\u00a0;</li> <li>en [3], on choisit le paquetage [Oracle Data Provider] qui va bien. C'est le connecteur ADO.NET d'Oracle\u00a0;</li> </ul> <ul> <li>en [4], la r\u00e9f\u00e9rence ajout\u00e9e\u00a0;</li> <li>en [5], dans [App.config], il faut mettre la version correcte de la DLL. On la trouve dans ses propri\u00e9t\u00e9s.</li> </ul> <p>Dans le fichier [Entites.cs], il faut adapter le sch\u00e9ma des tables qui vont \u00eatre g\u00e9n\u00e9r\u00e9es. Le sch\u00e9ma utilis\u00e9 est le nom de l'utilisateur propri\u00e9taire des tables.</p> <pre><code>  [Table(\"MEDECINS\", Schema = \"RDVMEDECINS-EF\")]\n  public class Medecin : Personne\n  {...}\n\n  [Table(\"CLIENTS\", Schema = \"RDVMEDECINS-EF\")]\n  public class Client : Personne\n  {...}\n\n  [Table(\"RVS\", Schema = \"RDVMEDECINS-EF\")]\n  public class Rv\n  {...}\n\n  [Table(\"CRENEAUX\", Schema = \"RDVMEDECINS-EF\")]\n  public class Creneau\n  {...}\n</code></pre> <p>Nous configurons l'ex\u00e9cution du projet\u00a0:</p> <ul> <li>en [1], on donne un autre nom \u00e0 l'assembly qui va \u00eatre g\u00e9n\u00e9r\u00e9\u00a0;</li> <li>en [2], ainsi qu'un autre espace de noms par d\u00e9faut\u00a0;</li> <li>en [3], on d\u00e9signe le programme \u00e0 ex\u00e9cuter.</li> </ul> <p>A ce stade, il n'y a pas d'erreurs de compilation. Ex\u00e9cutons le programme [CreateDB_01]. On obtient l'exception suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: System.Data.MetadataException: Le sch\u00e9ma sp\u00e9cifi\u00e9 n'est pas valide. Erreurs :\n(11,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(23,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(33,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(43,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n   \u00e0 System.Data.Metadata.Edm.StoreItemCollection.Loader.ThrowOnNonWarningErrors\n()\n   ...\n   \u00e0 RdvMedecins_01.CreateDB_01.Main(String[] args) dans d:\\data\\istia-1213\\c#\\d\nvp\\Entity Framework\\RdvMedecins\\RdvMedecins-Oracle-01\\CreateDB_01.cs:ligne 15\n</code></pre> <p>On se rappelle avoir eu la m\u00eame erreur avec MySQL. C'est li\u00e9 au type du champ Timestamp des entit\u00e9s. Nous faisons la m\u00eame modification. Dans les entit\u00e9s, nous rempla\u00e7ons les trois lignes</p> <pre><code>    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n</code></pre> <p>par les suivantes\u00a0:</p> <pre><code>    [ConcurrencyCheck]\n    [Column(\"VERSIONING\")]\n    public int? Versioning { get; set; }\n</code></pre> <p>On change donc le type de la colonne qui passe de byte[] \u00e0 int?. On se rappelle qu'aussi bien pour SQL Server que pour MySQL, la colonne des tables qui servait \u00e0 g\u00e9rer la concurrence d'acc\u00e8s recevait une valeur du SGBD \u00e0 chaque fois qu'une ligne \u00e9tait ins\u00e9r\u00e9e ou modifi\u00e9e. A partir de maintenant, nous allons utiliser un champ d'entit\u00e9 qui sera un entier. Dans le SGBD, nous utiliserons des proc\u00e9dures stock\u00e9es pour incr\u00e9menter cet entier d'une unit\u00e9, \u00e0 chaque fois qu'une ligne sera ins\u00e9r\u00e9e ou modifi\u00e9e.</p> <p>Nous faisons la modification pr\u00e9c\u00e9dente pour les quatre entit\u00e9s puis nous r\u00e9ex\u00e9cutons l'application. Nous obtenons alors l'erreur suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: System.Data.DataException: An exception occurred while initializing the database. See the InnerException for details. ---&gt; System.Data.ProviderIncompatibleException: DeleteDatabase n'est pas pris en charge par le fournisseur.\n   \u00e0 System.Data.Common.DbProviderServices.DbDeleteDatabase(DbConnection connection, Nullable`1 commandTimeout, StoreItemCollection storeItemCollection)\n   ...\n   \u00e0 System.Data.Entity.Internal.LazyInternalContext.InitializeDatabase()\n   \u00e0 RdvMedecins_01.CreateDB_01.Main(String[] args) dans d:\\data\\istia-1213\\c#\\d\nvp\\Entity Framework\\RdvMedecins\\RdvMedecins-Oracle-01\\CreateDB_01.cs:ligne 15\n</code></pre> <p>La ligne 1 indique que le connecteur ADO.NET d'Oracle n'est pas capable de supprimer la base existante. Rappelons ce qui se passe. Le code de [CreateDB_01.cs] est le suivant\u00a0:</p> <pre><code>using System;\nusing System.Data.Entity;\nusing RdvMedecins.Models;\n\nnamespace RdvMedecins_01\n{\n  class CreateDB_01\n  {\n    static void Main(string[] args)\n    {\n      // on cr\u00e9e la base de donn\u00e9es\n      Database.SetInitializer(new RdvMedecinsInitializer());\n      using (var context = new RdvMedecinsContext())\n      {\n        context.Database.Initialize(false);\n      }\n    }\n  }\n}\n</code></pre> <p>La ligne 15 enclenche l'ex\u00e9cution de la classe [RdvMedecinsInitializer] (ligne 12). Celle-ci est la suivante\u00a0:</p> <pre><code>  public class RdvMedecinsInitializer : DropCreateDatabaseAlways&lt;RdvMedecinsContext&gt;\n</code></pre> <p>Elle d\u00e9rive de la classe [DropCreateDatabaseAlways] qui essaie de supprimer puis de recr\u00e9er la base. Nous changeons la d\u00e9finition de la classe en\u00a0:</p> <pre><code>  public class RdvMedecinsInitializer : CreateDatabaseIfNotExists&lt;RdvMedecinsContext&gt;\n</code></pre> <p>La cr\u00e9ation de la base n'est faite que si elle n'existe pas. On r\u00e9ex\u00e9cute [CreateDB_01.cs] et l\u00e0 il n'y a plus d'erreurs. Mais dans [EMS Manager], on constate que la base [RDVMEDECINS-EF] est rest\u00e9e vide. Parce qu'EF 5 a trouv\u00e9 une base existante, il n'a rien fait. Il ne fait quelque chose que si la base n'existe pas. A partir de l\u00e0, on tourne en rond. En effet, la cha\u00eene de connexion au SGBD est la suivante\u00a0:</p> <pre><code>  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\" connectionString=\"Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=XE)));User Id=RDVMEDECINS-EF;Password=rdvmedecins;\" providerName=\"Oracle.DataAccess.Client\" /&gt;\n&lt;/connectionStrings&gt;\n</code></pre> <p>Ligne 2, la cha\u00eene de connexion utilise non pas le nom d'une base de donn\u00e9es mais le nom d'un utilisateur. Celui-ci doit exister.</p> <p>Nous sommes amen\u00e9s alors \u00e0 construire la base de donn\u00e9es [RDVMEDECINS-EF] \u00e0 la main avec l'outil [EMS Manager for Oracle]. Nous ne d\u00e9crivons pas toutes les \u00e9tapes mais simplement les plus importantes.</p> <p>La base Oracle sera la suivante\u00a0:</p> <p>Les tables</p> <p>Les diff\u00e9rentes tables ont les cl\u00e9s primaires et \u00e9trang\u00e8res qu'avaient ces m\u00eames tables dans les deux exemples pr\u00e9c\u00e9dents. Les cl\u00e9s \u00e9trang\u00e8res ont notamment l'attribut ON DELETE CASCADE.</p> <p>Les s\u00e9quences</p> <p>On a cr\u00e9\u00e9 ici des s\u00e9quences Oracle. Ce sont des g\u00e9n\u00e9rateurs de nombres cons\u00e9cutifs. Il y en a 5 [1].</p> <ul> <li>en [2], nous voyons les propri\u00e9t\u00e9s de la s\u00e9quence [SEQUENCE_CLIENTS]. Elle g\u00e9n\u00e8re des nombres cons\u00e9cutifs de 1 en 1, \u00e0 partir de 1 jusqu'\u00e0 une valeur tr\u00e8s grande.</li> </ul> <p>Toutes les s\u00e9quences sont b\u00e2ties sur le m\u00eame mod\u00e8le. </p> <ul> <li>[SEQUENCE_CLIENTS] sera utilis\u00e9e pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [CLIENTS]\u00a0;</li> <li>[SEQUENCE_MEDECINS] sera utilis\u00e9e pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [MEDECINS]\u00a0;</li> <li>[SEQUENCE_CRENEAUX] sera utilis\u00e9e pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [CRENEAUX]\u00a0;</li> <li>[SEQUENCE_RVS] sera utilis\u00e9e pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [RVS]\u00a0;</li> <li>[SEQUENCE_VERSIONS] sera utilis\u00e9e pour g\u00e9n\u00e9rer les valeurs des colonnes [VERSIONING] de toutes les tables.</li> </ul> <p>Les triggers</p> <p>Un trigger est une proc\u00e9dure ex\u00e9cut\u00e9e par le SGBD avant ou apr\u00e8s un \u00e9v\u00e9nement (Insertion, Modification, Suppression) dans une table. Nous en avons 8 [1]\u00a0:</p> <p>Regardons le code DDL du trigger [TRIGGER_PK_CLIENTS] qui alimente la cl\u00e9 primaire de la table [CLIENTS]\u00a0:</p> <pre><code>CREATE TRIGGER \"RDVMEDECINS-EF\".TRIGGER_PK_CLIENTS\n BEFORE INSERT\n ON \"RDVMEDECINS-EF\".CLIENTS\nREFERENCING NEW AS NEW OLD AS OLD FOR EACH ROW\nBEGIN\n        SELECT SEQUENCE_CLIENTS.NEXTVAL INTO :new.ID from DUAL;\nEND;\n/\n</code></pre> <ul> <li>lignes 1-5\u00a0: avant chaque op\u00e9ration INSERT sur la table [CLIENTS]\u00a0;</li> <li>ligne 6\u00a0: la colonne [ID] prendra la valeur suivante de la s\u00e9quence [SEQUENCE_CLIENTS]. La cl\u00e9 primaire aura ainsi des valeurs cons\u00e9cutives fournies par la s\u00e9quence.</li> </ul> <p>Les triggers [TRIGGER_PK_MEDECINS, TRIGGER_PK_CRENEAUX, TRIGGER_PK_RVS] sont analogues.</p> <p>Regardons le code DDL du trigger [TRIGGER_VERSIONS_CLIENTS] qui alimente la colonne [VERSIONING] de la table [CLIENTS]\u00a0:</p> <pre><code>CREATE TRIGGER \"RDVMEDECINS-EF\".TRIGGER_VERSION_CLIENTS\n BEFORE INSERT OR UPDATE\n OF\n  VERSIONING\n ON \"RDVMEDECINS-EF\".CLIENTS\nREFERENCING NEW AS NEW OLD AS OLD FOR EACH ROW\nBEGIN\n        SELECT SEQUENCE_VERSIONS.NEXTVAL INTO :new.VERSIONING from DUAL;\nEND;\n/\n</code></pre> <ul> <li>lignes 1-2\u00a0: avant chaque op\u00e9ration INSERT ou UPDATE sur la table [CLIENTS]\u00a0;</li> <li>ligne 8\u00a0: la colonne [VERSIONING] prendra la valeur suivante de la s\u00e9quence [SEQUENCE_VERSIONS]. La colonne [VERSIONING] aura ainsi des valeurs cons\u00e9cutives fournies par la s\u00e9quence.</li> </ul> <p>Les triggers [TRIGGER_VERSION_MEDECINS, TRIGGER_VERSION_CRENEAUX, TRIGGER_VERSION_RVS] sont analogues. Les quatre colonnes [VERSIONING] tirent leur valeurs de la m\u00eame s\u00e9quence.</p> <p>Le script de g\u00e9n\u00e9ration des tables de la base Oracle [RDVMEDECINS-EF] a \u00e9t\u00e9 plac\u00e9 dans le dossier [RdvMedecins / databases / oracle]. Le lecteur pourra le charger et l'ex\u00e9cuter pour cr\u00e9er ses tables.</p> <p>Ceci fait, les diff\u00e9rents programmes du projet peuvent \u00eatre ex\u00e9cut\u00e9s. Ils donnent les m\u00eames r\u00e9sultats qu'avec SQL Server sauf pour le programme [ModifyDetachedEntities] qui plante pour la m\u00eame raison qu'il avait plant\u00e9 avec MySQL. On r\u00e9soud le probl\u00e8me de la m\u00eame fa\u00e7on. Il suffit de copier le programme [ModifyDetachedEntities] du projet [RdvMedecins-MySQL-01] dans le projet [RdvMedecins-Oracle-01]. On a alors un nouveau probl\u00e8me\u00a0:</p> <pre><code>1-----------------------------\nClient [206,x,x,x,616]\n2-----------------------------\nClient [206,x,x,y,617]\n\nException non g\u00e9r\u00e9e\u00a0: System.Data.Entity.Infrastructure.DbUpdateConcurrencyException: Une instruction de mise \u00e0 jour, d'insertion ou de suppression dans le magasin a affect\u00e9 un nombre inattendu de lignes (0). Des entit\u00e9s ont peut-\u00eatre \u00e9t\u00e9 modifi\u00e9es ou supprim\u00e9es depuis leur chargement. Actualisez les entr\u00e9es ObjectStateManager. ---&gt; System.Data.OptimisticConcurrencyException: Une instruction de mise \u00e0 jour, d'insertion ou de suppression dans le magasin a affect\u00e9 un nombre inattendu de lignes (0). Des entit\u00e9s ont peut-\u00eatre \u00e9t\u00e9 modifi\u00e9es ou supprim\u00e9es depuis leur chargement. Actualisez les entr\u00e9es ObjectStateManager.\n   ...\n   \u00e0 RdvMedecins_01.ModifyDetachedEntities.Main(String[] args) dans d:\\data\\istia-1213\\c#\\dvp\\Entity Framework\\RdvMedecins\\RdvMedecins-Oracle-01\\ModifyDetachedE\nntities.cs:ligne 56\n</code></pre> <ul> <li>lignes 1-4\u00a0: le client d\u00e9tach\u00e9 a bien \u00e9t\u00e9 mis \u00e0 jour\u00a0;</li> <li>ligne 6\u00a0: une exception connue. C'est celle qu'on obtient lorsqu'on veut modifier une entit\u00e9 sans avoir la bonne version. Or ici, on ne voulait pas modifier mais supprimer l'entit\u00e9\u00a0:</li> </ul> <pre><code>      // suppression entit\u00e9 hors contexte\n      using (var context = new RdvMedecinsContext())\n      {\n        // ici, on a un nouveau contexte vide\n        // on met client1 dans le contexte dans un \u00e9tat supprim\u00e9\n        context.Entry(client1).State = EntityState.Deleted;\n        // on sauvegarde le contexte\n        context.SaveChanges();\n}\n</code></pre> <p>EF 5 a refus\u00e9 de supprimer client1 en base, car client1 (ligne 6) n'avait pas la m\u00eame version. On n'avait pas rencontr\u00e9 ce probl\u00e8me avec MySQL. On s'aper\u00e7oit peu \u00e0 peu que les connecteurs ADO.NET de diff\u00e9rents SGBD pr\u00e9sentent de l\u00e9g\u00e8res diff\u00e9rences. On corrige comme suit\u00a0:</p> <pre><code>using (var context = new RdvMedecinsContext())\n      {\n        // ici, on a un nouveau contexte vide\n        // on met client1 dans le contexte pour le supprimer\n        context.Clients.Remove(context.Clients.Find(client1.Id));\n        // on sauvegarde le contexte\n        context.SaveChanges();\n      }\n</code></pre> <p>et \u00e7a marche. </p>"},{"location":"etude-de-cas-avec--oracle-database-express-edition-11g-release-2.html#53-architecture-multi-couche-sappuyant-sur-ef-5","title":"5.3. Architecture multi-couche s'appuyant sur EF 5","text":"<p>Nous revenons \u00e0 notre \u00e9tude de cas d\u00e9crite au paragraphe 2, page 6.</p> <p>Nous allons commencer par construire la couche [DAO] d'acc\u00e8s aux donn\u00e9es. Pour ce faire, nous dupliquons le projet console VS 2012 [RdvMedecins-SqlServer-02] dans [RdvMedecins-Oracle-02] [1]\u00a0:</p> <ul> <li>en [2], on supprime le projet [RdvMedecins-SqlServer-02]\u00a0;</li> </ul> <ul> <li>en [3], on ajoute un projet existant \u00e0 la solution. On le prend dans le dossier [RdvMedecins-Oracle-02] qui vient d'\u00eatre cr\u00e9\u00e9\u00a0;</li> <li>en [4], le nouveau projet porte le nom de celui qui a \u00e9t\u00e9 supprim\u00e9. On va changer son nom\u00a0;</li> </ul> <ul> <li>en [5], on a chang\u00e9 le nom du projet\u00a0;</li> <li>en [6], on modifie certaines de ses propri\u00e9t\u00e9s, comme ici le nom de l'assembly\u00a0;</li> <li>en [7], le dossier [Models] est supprim\u00e9 pour \u00eatre remplac\u00e9 par le dossier [Models] du projet [RdvMedecins-Oracle-01]. En effet, les deux projets partagent les m\u00eames mod\u00e8les.</li> </ul> <ul> <li>en [8], les r\u00e9f\u00e9rences actuelles du projet\u00a0;</li> <li>en [9], on y a ajout\u00e9 le connecteur ADO.NET d'Oracle avec l'outil NuGet.</li> </ul> <p>Dans le fichier [App.config], on remplace les informations de la base SQL Server par celles de la base Oracle. On les trouve dans le fichier [App.config] du projet [RdvMedecins-Oracle-01]\u00a0:</p> <pre><code>&lt;!-- cha\u00eene de connexion sur la base --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\" connectionString=\"Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=XE)));User Id=RDVMEDECINS-EF;Password=rdvmedecins;\" providerName=\"Oracle.DataAccess.Client\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;remove invariant=\"Oracle.DataAccess.Client\" /&gt;\n      &lt;add name=\"Oracle Data Provider for .NET\" invariant=\"Oracle.DataAccess.Client\" description=\"Oracle Data Provider for .NET\" type=\"Oracle.DataAccess.Client.OracleClientFactory, Oracle.DataAccess, Version=4.112.3.0, Culture=neutral, PublicKeyToken=89b483f429c47342\" /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n</code></pre> <p>Les objets g\u00e9r\u00e9s par Spring changent \u00e9galement. Actuellement on a\u00a0:</p> <pre><code>  &lt;!-- configuration Spring --&gt;\n  &lt;spring&gt;\n    &lt;context&gt;\n      &lt;resource uri=\"config://spring/objects\" /&gt;\n    &lt;/context&gt;\n    &lt;objects xmlns=\"http://www.springframework.net\"&gt;\n      &lt;object id=\"rdvmedecinsDao\" type=\"RdvMedecins.Dao.Dao,RdvMedecins-SqlServer-02\" /&gt;\n    &lt;/objects&gt;\n&lt;/spring&gt;\n</code></pre> <p>La ligne 7 r\u00e9f\u00e9rence l'assembly du projet [RdvMedecins-SqlServer-02]. L'assembly est d\u00e9sormais [RdvMedecins-Oracle-02].</p> <p>Ceci fait, nous sommes pr\u00eats \u00e0 ex\u00e9cuter le test de la couche [DAO]. Il faut auparavant prendre soin de remplir la base (programme [Fill] du projet [RdvMedecins-Oracle-01]. Le programme de test r\u00e9ussit.</p> <p>Nous cr\u00e9ons la DLL du projet comme il a \u00e9t\u00e9 fait pour le projet [RdvMedecins-SqlServer-02] et nous rassemblons l'ensemble des DLL du projet dans un dossier [lib] cr\u00e9\u00e9e dans [RdvMedecins-Oracle-02]. Ce seront les r\u00e9f\u00e9rences du projet web [RdvMedecins-Oracle-03] qui va suivre.</p> <p>Nous sommes d\u00e9sormais pr\u00eats pour construire la couche [ASP.NET] de notre application\u00a0:</p> <p>Nous allons partir du projet [RdvMedecins-SqlServer-03]. Nous dupliquons le dossier de ce projet dans [RdvMedecins-Oracle-03] [1]\u00a0:</p> <ul> <li>en [2], avec VS 2012 Express pour le web, nous ouvrons la solution du dossier [RdvMedecins-Oracle-03]\u00a0;</li> <li>en [3], nous changeons et le nom de la solution et le nom du projet\u00a0;</li> </ul> <ul> <li>en [4], les r\u00e9f\u00e9rences actuelles du projet\u00a0;</li> <li>en [5], on les supprime\u00a0;</li> <li>en [6], pour les remplacer par des r\u00e9f\u00e9rences sur les DLL que nous venons de stocker dans un dossier [lib] du projet [RdvMedecins-Oracle-02].</li> </ul> <p>Il ne nous reste plus qu'\u00e0 modifier le fichier [Web.config] On remplace son contenu actuel par le contenu du fichier [App.config] du projet [RdvMedecins-Oracle-02]. Ceci fait, on ex\u00e9cute le projet web. Il marche. On n'oubliera pas de remplir la base avant d'ex\u00e9cuter l'application web.</p>"},{"location":"etude-de-cas-avec--postgresql-921.html","title":"6. Etude de cas avec  PostgreSQL 9.2.1","text":""},{"location":"etude-de-cas-avec--postgresql-921.html#61-installation-des-outils","title":"6.1. Installation des outils","text":"<p>Les outils \u00e0 installer sont les suivants\u00a0:</p> <ul> <li>le SGBD\u00a0: [http://www.enterprisedb.com/products-services-training/pgdownload#windows]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for PostgreSQL Freeware [http://www.sqlmanager.net/fr/products/postgresql/manager/download].</li> </ul> <p>Dans les exemples qui suivent, l'utilisateur postgres a le mot de passe postgres.</p> <p>Lan\u00e7ons PostgreSQL puis l'outil [SQL Manager Lite for PostgreSQL] avec lequel on va administrer le SGBD.</p> <ul> <li>en [1], nous lan\u00e7ons le SGBD PostgreSQL \u00e0 partir des services Windows\u00a0;</li> <li>en [2], le service est d\u00e9marr\u00e9\u00a0;</li> </ul> <p>Nous lan\u00e7ons maintenant l'outil [SQL Manager Lite for MySQL] avec lequel on va administrer le SGBD [3].</p> <ul> <li>en [4], nous cr\u00e9ons une nouvelle base\u00a0;</li> <li>en [5], on indique le nom de la base\u00a0;</li> </ul> <ul> <li>en [5], on se connecte en tant que postgres / postgres\u00a0;</li> <li>en [6], on donne quelques informations\u00a0;</li> <li>en [7], on valide l'ordre SQL qui va \u00eatre ex\u00e9cut\u00e9\u00a0;</li> </ul> <ul> <li>en [8], la base a \u00e9t\u00e9 cr\u00e9\u00e9e. Elle doit maintenant \u00eatre enregistr\u00e9e dans [EMS Manager]. Les informations sont bonnes. On fait [OK]\u00a0;</li> <li>en [9], on s'y connecte\u00a0;</li> <li>en [10], [EMS Manager] affiche la base, pour l'instant vide. On notera que les tables appartiendront \u00e0 un sch\u00e9ma appel\u00e9 public [11].</li> </ul> <p>Nous allons maintenant connecter un projet VS 2012 \u00e0 cette base.</p>"},{"location":"etude-de-cas-avec--postgresql-921.html#62-creation-de-la-base-a-partir-des-entites","title":"6.2. Cr\u00e9ation de la base \u00e0 partir des entit\u00e9s","text":"<p>Nous commen\u00e7ons par dupliquer le dossier du projet [RdvMedecins-SqlServer-01] dans [RdvMedecins-PostgreSQL-01] [1]\u00a0:</p> <p>1</p><p>2</p> <ul> <li>en [2], dans VS 2012, nous supprimons le projet [RdvMedecins-SqlServer-01] de la solution\u00a0;</li> </ul> <ul> <li>en [3], le projet a \u00e9t\u00e9 supprim\u00e9\u00a0;</li> <li>en [4], on en rajoute un autre. Celui-ci est pris dans le dossier [RdvMedecins-PostgreSQL-01] que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment\u00a0;</li> </ul> <ul> <li>en [5], le projet charg\u00e9 s'appelle [RdvMedecins-SqlServer-01]\u00a0;</li> <li>en [6], on change son nom en [RdvMedecins-PostgreSQL-01]\u00a0;</li> </ul> <ul> <li>en [7], on rajoute un autre projet \u00e0 la solution. Celui-ci est pris dans le dossier [RdvMedecins-SqlServer-01] du projet que nous avons  supprim\u00e9 de la solution pr\u00e9c\u00e9demment\u00a0;</li> <li>en [8], le projet [RdvMedecins-SqlServer-01] a r\u00e9int\u00e9gr\u00e9 la solution.</li> </ul> <p>Le projet [RdvMedecins-PostgreSQL-01] est identique au projet [RdvMedecins-SqlServer-01]. Il nous faut faire quelques modifications. Dans [App.config], nous allons modifier la cha\u00eene de connexion et le [DbProviderFactory] qu'on doit adapter \u00e0 chaque SGBD.</p> <pre><code>&lt;!-- cha\u00eene de connexion sur la base --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\" connectionString=\"Server=127.0.0.1;Port=5432;Database=rdvmedecins-ef;User Id=postgres;Password=postgres;\" providerName=\"Npgsql\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"Npgsql Data Provider\" invariant=\"Npgsql\" support=\"FF\" description=\".Net Framework Data Provider for Postgresql Server\" type=\"Npgsql.NpgsqlFactory, Npgsql, Version=2.0.11.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7\" /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n</code></pre> <ul> <li>ligne 3\u00a0: l'utilisateur et son mot de passe\u00a0;</li> <li>lignes 7-9\u00a0: le DbProviderFactory. La ligne 8 r\u00e9f\u00e9rence une DLL [Npgsql] que nous n'avons pas. On se la procure avec NuGet [1]\u00a0:</li> </ul> <ul> <li>en [2], dans la zone de recherche on tape le mot cl\u00e9 postgresql\u00a0;</li> <li>en [3], on choisit le paquetage [Npgsql]. C'est un connecteur ADO.NET pour PostgreSQL\u00a0;</li> </ul> <ul> <li>en [4], deux r\u00e9f\u00e9rences ont \u00e9t\u00e9 ajout\u00e9es\u00a0;</li> <li>en [5], dans [App.config], il faut mettre la version correcte de la DLL. On la trouve dans ses propri\u00e9t\u00e9s.</li> </ul> <p>Dans le fichier [Entites.cs], il faut adapter le sch\u00e9ma des tables qui vont \u00eatre g\u00e9n\u00e9r\u00e9es\u00a0:</p> <pre><code>  [Table(\"MEDECINS\", Schema = \"public\")]\n  public class Medecin : Personne\n  {...}\n\n  [Table(\"CLIENTS\", Schema = \"public\")]\n  public class Client : Personne\n  {...}\n\n  [Table(\"CRENEAUX\", Schema = \"public\")]\n  public class Creneau\n  {...}\n\n  [Table(\"RVS\", Schema = \"public\")]\n  public class Rv\n  {...}\n</code></pre> <p>Nous avons vu pr\u00e9c\u00e9demment lors de la cr\u00e9ation d'une base PostgreSQL, que les tables appartenaient \u00e0 un sch\u00e9ma appel\u00e9 public.</p> <p>Nous configurons l'ex\u00e9cution du projet\u00a0:</p> <ul> <li>en [1], on donne un autre nom \u00e0 l'assembly qui va \u00eatre g\u00e9n\u00e9r\u00e9\u00a0;</li> <li>en [2], ainsi qu'un autre espace de noms par d\u00e9faut\u00a0;</li> <li>en [3], on d\u00e9signe le programme \u00e0 ex\u00e9cuter.</li> </ul> <p>A ce stade, il n'y a pas d'erreurs de compilation. Ex\u00e9cutons le programme [CreateDB_01]. On obtient l'exception suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: System.Data.MetadataException: Le sch\u00e9ma sp\u00e9cifi\u00e9 n'est pas valide. Erreurs :\n(11,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(23,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(33,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(43,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n   \u00e0 System.Data.Metadata.Edm.StoreItemCollection.Loader.ThrowOnNonWarningErrors\n()\n   ...\n   \u00e0 RdvMedecins_01.CreateDB_01.Main(String[] args) dans d:\\data\\istia-1213\\c#\\d\nvp\\Entity Framework\\RdvMedecins\\RdvMedecins-Oracle-01\\CreateDB_01.cs:ligne 15\n</code></pre> <p>On se rappelle avoir eu la m\u00eame erreur avec MySQL et Oracle. C'est li\u00e9 au type du champ Timestamp des entit\u00e9s. Nous faisons la m\u00eame modification qu'avec Oracle. Dans les entit\u00e9s, nous rempla\u00e7ons les trois lignes</p> <pre><code>    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n</code></pre> <p>par les suivantes\u00a0:</p> <pre><code>    [ConcurrencyCheck]\n    [Column(\"VERSIONING\")]\n    public int? Versioning { get; set; }\n</code></pre> <p>On change le type de la colonne qui passe de byte[] \u00e0 int?. Dans le SGBD, nous utiliserons des proc\u00e9dures stock\u00e9es pour incr\u00e9menter cet entier d'une unit\u00e9 \u00e0 chaque fois qu'une ligne sera ins\u00e9r\u00e9e ou modifi\u00e9e.</p> <p>Nous faisons la modification pr\u00e9c\u00e9dente pour les quatre entit\u00e9s puis nous r\u00e9ex\u00e9cutons l'application. Nous obtenons alors l'erreur suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: System.Data.DataException: An exception occurred while initializing the database. See the InnerException for details. ---&gt; System.Data.ProviderIncompatibleException: DeleteDatabase n'est pas pris en charge par le fournisseur.\n   \u00e0 System.Data.Common.DbProviderServices.DbDeleteDatabase(DbConnection connection, Nullable`1 commandTimeout, StoreItemCollection storeItemCollection)\n   ...\n   \u00e0 System.Data.Entity.Internal.LazyInternalContext.InitializeDatabase()\n   \u00e0 RdvMedecins_01.CreateDB_01.Main(String[] args) dans d:\\data\\istia-1213\\c#\\d\nvp\\Entity Framework\\RdvMedecins\\RdvMedecins-Oracle-01\\CreateDB_01.cs:ligne 15\n</code></pre> <p>La ligne 1 indique que le connecteur ADO.NET de PostgreSQL n'est pas capable de supprimer la base existante. Exactement comme avec Oracle. Nous sommes amen\u00e9s alors \u00e0 construire la base de donn\u00e9es [RDVMEDECINS-EF] \u00e0 la main avec l'outil [EMS Manager for PostgreSQL]. Nous ne d\u00e9crivons pas toutes les \u00e9tapes mais simplement les plus importantes.</p> <p>La base PostgreSQL sera la suivante\u00a0:</p> <p>Les tables</p> <ul> <li>en [1], ID est cl\u00e9 primaire de type serial. Ce type PostgreSQL est un entier g\u00e9n\u00e9r\u00e9 automatiquement par le SGBD.</li> </ul> <p>Les diff\u00e9rentes tables ont les cl\u00e9s primaires et \u00e9trang\u00e8res qu'avaient ces m\u00eames tables dans les exemples pr\u00e9c\u00e9dents. Les cl\u00e9s \u00e9trang\u00e8res ont l'attribut ON DELETE CASCADE.</p> <p>Les s\u00e9quences</p> <p>Comme avec Oracle, nous avons cr\u00e9\u00e9 ici des s\u00e9quences. Ce sont des g\u00e9n\u00e9rateurs de nombres cons\u00e9cutifs. Il y en a 5 [1].</p> <ul> <li>en [2], nous voyons les propri\u00e9t\u00e9s de la s\u00e9quence [CLIENTS_ID_SEQ]. Elle g\u00e9n\u00e8re des nombres cons\u00e9cutifs de 1 en 1, \u00e0 partir de 1 jusqu'\u00e0 une valeur tr\u00e8s grande.</li> </ul> <p>Toutes les s\u00e9quences sont b\u00e2ties sur le m\u00eame mod\u00e8le. </p> <ul> <li>[CLIENTS_ID_seq] sera utilis\u00e9e pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [CLIENTS]\u00a0;</li> <li>[MEDECINS_ID_seq] sera utilis\u00e9e pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [MEDECINS]\u00a0;</li> <li>[CRENEAUX_ID_seq] sera utilis\u00e9e pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [CRENEAUX]\u00a0;</li> <li>[RVS_ID_seq] sera utilis\u00e9e pour g\u00e9n\u00e9rer la cl\u00e9 primaire de la table [RVS]\u00a0;</li> <li>[sequence_versions] sera utilis\u00e9e pour g\u00e9n\u00e9rer les valeurs des colonnes [VERSIONING] de toutes les tables.</li> </ul> <p>Les triggers</p> <p>Un trigger est une proc\u00e9dure ex\u00e9cut\u00e9e par le SGBD avant ou apr\u00e8s un \u00e9v\u00e9nement (Insertion, Modification, Suppression) dans une table. Nous en avons 4 [1]\u00a0:</p> <p>Regardons le code DDL du trigger [CLIENTS_tr] qui alimente la colonne [VERSIONING] de la table [CLIENTS]\u00a0:</p> <pre><code>CREATE TRIGGER \"CLIENTS_tr\"\n  BEFORE INSERT OR UPDATE \n  ON public.\"CLIENTS\" FOR EACH ROW \nEXECUTE PROCEDURE public.trigger_versions();\n</code></pre> <ul> <li>lignes 1-3\u00a0: avant chaque op\u00e9ration INSERT ou UPDATE sur la table [CLIENTS]\u00a0;</li> <li>ligne 4\u00a0: la proc\u00e9dure [public.trigger_versions()] est ex\u00e9cut\u00e9e.</li> </ul> <p>La proc\u00e9dure [public.trigger_versions()] est la suivante\u00a0:</p> <pre><code>BEGIN\nNEW.\"VERSIONING\":=nextval('sequence_versions');\nreturn NEW;\nEND\n</code></pre> <ul> <li>ligne 2\u00a0: NEW repr\u00e9sente la ligne qui va \u00eatre ins\u00e9r\u00e9e ou modifi\u00e9e. NEW.\u00a0\"VERSIONING\u00a0\" est la colonne [VERSIONING] de cette ligne. On lui affecte la valeur suivante du g\u00e9n\u00e9rateur de nombres \"\u00a0sequence_versions\u00a0\". Ainsi la colonne [\"VERSIONING\"] change \u00e0 chaque INSERT / UPDATE fait sur la table [CLIENTS].</li> </ul> <p>Les triggers [MEDECINS_tr, CRENEAUX_tr, RVS_tr] sont analogues. Les quatre colonnes [\"VERSIONING\"] tirent leur valeurs de la m\u00eame s\u00e9quence.</p> <p>Le script de g\u00e9n\u00e9ration des tables de la base PostgreSQL [RDVMEDECINS-EF] a \u00e9t\u00e9 plac\u00e9 dans le dossier [RdvMedecins / databases / postgreSQL]. Le lecteur pourra le charger et l'ex\u00e9cuter pour cr\u00e9er ses tables.</p> <p>Ceci fait, les diff\u00e9rents programmes du projet peuvent \u00eatre ex\u00e9cut\u00e9s. Ils donnent les m\u00eames r\u00e9sultats qu'avec SQL Server sauf pour le programme [ModifyDetachedEntities] qui plante pour la m\u00eame raison qu'il avait plant\u00e9 avec Oracle. On r\u00e9soud le probl\u00e8me de la m\u00eame fa\u00e7on. Il suffit de copier le programme [ModifyDetachedEntities] du projet [RdvMedecins-Oracle-01] dans le projet [RdvMedecins-PostgreSQL-01].</p> <p>Le programme [LazyEagerLoading] plante avec l'exception suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: System.Data.EntityCommandExecutionException: Une erreur s'est produite lors de l'ex\u00e9cution de la d\u00e9finition de la commande. Pour plus de d\u00e9tails, consultez l'exception interne. ---&gt; Npgsql.NpgsqlException: ERREUR: 42601: erreur de syntaxe sur ou pr\u00e8s de \u00ab LEFT \u00bb\n   \u00e0 Npgsql.NpgsqlState.&lt;ProcessBackendResponses_Ver_3&gt;d__a.MoveNext()\n   ...\n   \u00e0 RdvMedecins_01.LazyEagerLoading.Main(String[] args) dans d:\\data\\istia-1213\\c#\\dvp\\Entity Framework\\RdvMedecins\\RdvMedecins-PostgreSQL-01\\LazyEagerLoading.cs:ligne 23\n</code></pre> <p>Le code erron\u00e9 est le suivant\u00a0:</p> <pre><code>      using (var context = new RdvMedecinsContext())\n      {\n        // creneau n\u00b0 0\n        creneau = context.Creneaux.Include(\"Medecin\").Single&lt;Creneau&gt;(c =&gt; c.Id == idCreneau);\n        Console.WriteLine(creneau.ShortIdentity());\n}\n</code></pre> <p>Ligne n\u00b0 1 de l'exception, l'erreur signal\u00e9e fait penser \u00e0 une jointure car LEFT est un mot cl\u00e9 de la jointure. Parce que la ligne 4 du code ci-dessus, demande le chargement imm\u00e9diat de la d\u00e9pendance [Medecin] d'une entit\u00e9 [Creneau], EF a fait une jointure entre les tables [CRENEAUX] et [MEDECINS]. Mais il semble que le connecteur ADO.NET ait g\u00e9n\u00e9r\u00e9 un ordre SQL incorrect. Nous r\u00e9\u00e9crivons le code de la fa\u00e7on suivante\u00a0:</p> <pre><code>      using (var context = new RdvMedecinsContext())\n      {\n        // creneau n\u00b0 0\n        creneau = context.Creneaux.Find(idCreneau);\n        Console.WriteLine(creneau.ShortIdentity());\n        // on force le chargement du m\u00e9decin associ\u00e9\n        // c'est possible car on est encore dans un contexte ouvert\n        Medecin medecin = creneau.Medecin;\n}\n</code></pre> <ul> <li>ligne 4\u00a0: on va chercher le cr\u00e9neau sans jointure\u00a0;</li> <li>ligne 8\u00a0: on r\u00e9cup\u00e8re la d\u00e9pendance manquante.</li> </ul> <p>Ca marche. De nouveau on constate que le changement de SGBD a un impact sur le code. En fait ce n'est pas le SGBD qui est en cause ici mais son connecteur ADO.NET.</p>"},{"location":"etude-de-cas-avec--postgresql-921.html#63-architecture-multi-couche-sappuyant-sur-ef-5","title":"6.3. Architecture multi-couche s'appuyant sur EF 5","text":"<p>Nous revenons \u00e0 notre \u00e9tude de cas d\u00e9crite au paragraphe 2.</p> <p>Nous allons commencer par construire la couche [DAO] d'acc\u00e8s aux donn\u00e9es. Pour ce faire, nous dupliquons le projet console VS 2012 [RdvMedecins-SqlServer-02] dans [RdvMedecins-PostgreSQL-02] [1]\u00a0:</p> <ul> <li>en [2], on supprime le projet [RdvMedecins-SqlServer-02]\u00a0;</li> </ul> <ul> <li>en [3], on ajoute un projet existant \u00e0 la solution. On le prend dans le dossier [RdvMedecins-PostgreSQL-02] qui vient d'\u00eatre cr\u00e9\u00e9\u00a0;</li> <li>en [4], le nouveau projet porte le nom de celui qui a \u00e9t\u00e9 supprim\u00e9. On va changer son nom\u00a0;</li> </ul> <ul> <li>en [5], on a chang\u00e9 le nom du projet\u00a0;</li> <li>en [6], on modifie certaines de ses propri\u00e9t\u00e9s, comme ici le nom de l'assembly\u00a0;</li> <li>en [7], le dossier [Models] est supprim\u00e9 pour \u00eatre remplac\u00e9 par le dossier [Models] du projet [RdvMedecins-PostgreSQL-01]. En effet, les deux projets partagent les m\u00eames mod\u00e8les.</li> </ul> <ul> <li>en [8], les r\u00e9f\u00e9rences actuelles du projet\u00a0;</li> <li>en [9], on y a ajout\u00e9 le connecteur ADO.NET de PostgreSQL avec l'outil NuGet.</li> </ul> <p>Dans le fichier [App.config], on remplace les informations de la base SQL Server par celles de la base PostgreSQL. On les trouve dans le fichier [App.config] du projet [RdvMedecins-PostgreSQL-01]\u00a0:</p> <pre><code>  &lt;!-- cha\u00eene de connexion sur la base --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\" connectionString=\"Server=127.0.0.1;Port=5432;Database=rdvmedecins-ef;User Id=postgres;Password=postgres;\" providerName=\"Npgsql\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"Npgsql Data Provider\" invariant=\"Npgsql\" support=\"FF\" description=\".Net Framework Data Provider for Postgresql Server\" type=\"Npgsql.NpgsqlFactory, Npgsql, Version=2.0.11.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7\" /&gt;\n    &lt;/DbProviderFactories&gt;\n&lt;/system.data&gt;\n</code></pre> <p>Les objets g\u00e9r\u00e9s par Spring changent \u00e9galement. Actuellement on a\u00a0:</p> <pre><code>  &lt;!-- configuration Spring --&gt;\n  &lt;spring&gt;\n    &lt;context&gt;\n      &lt;resource uri=\"config://spring/objects\" /&gt;\n    &lt;/context&gt;\n    &lt;objects xmlns=\"http://www.springframework.net\"&gt;\n      &lt;object id=\"rdvmedecinsDao\" type=\"RdvMedecins.Dao.Dao,RdvMedecins-SqlServer-02\" /&gt;\n    &lt;/objects&gt;\n&lt;/spring&gt;\n</code></pre> <p>La ligne 7 r\u00e9f\u00e9rence l'assembly du projet [RdvMedecins-SqlServer-02]. L'assembly est d\u00e9sormais [RdvMedecins-PostgreSQL-02].</p> <p>Ceci fait, nous sommes pr\u00eats \u00e0 ex\u00e9cuter le test de la couche [DAO]. Il faut auparavant prendre soin de remplir la base (programme [Fill] du projet [RdvMedecins-PostgreSQL-01]. Le programme de test plante avec l'exception suivante\u00a0:</p> <pre><code>2012/10/12 13:56:27:188 [INFO]  Spring.Context.Support.XmlApplicationContext - A\npplicationContext Refresh: Completed\nListe des clients :\nClient [47,Mr,Jules,Martin,468]\nClient [48,Mme,Christine,German,469]\nClient [49,Mr,Jules,Jacquard,470]\nClient [50,Melle,Brigitte,Bistrou,471]\nListe des m\u00e9decins :\nMedecin [42,Mme,Marie,Pelissier,472]\nMedecin [43,Mr,Jacques,Bromard,497]\nMedecin [44,Mr,Philippe,Jandot,510]\nMedecin [45,Melle,Justine,Jacquemot,511]\nL'erreur suivante s'est produite : RdvMedecinsException[3,GetCreneauxMedecin,Une erreur s'est produite lors de l'ex\u00e9cution de la d\u00e9finition de la commande. Pour plus de d\u00e9tails, consultez l'exception interne.]\n</code></pre> <p>Ligne 13, le message indique que l'erreur s'est produite dans la m\u00e9thode [GetCreneauxMedecin] de la couche [DAO]. Celle-ci est la suivante\u00a0:</p> <pre><code>    // liste des cr\u00e9neaux horaires d'un m\u00e9decin donn\u00e9\n    public List&lt;Creneau&gt; GetCreneauxMedecin(int idMedecin)\n    {\n      // liste des cr\u00e9neaux\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          // on r\u00e9cup\u00e8re le m\u00e9decin avec ses cr\u00e9neaux\n          Medecin medecin = context.Medecins.Include(\"Creneaux\").Single(m =&gt; m.Id == idMedecin);\n          // on retourne la liste des cr\u00e9neaux du m\u00e9decin\n          return medecin.Creneaux.ToList&lt;Creneau&gt;();\n        }\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(3, \"GetCreneauxMedecin\", ex);\n      }\n}\n</code></pre> <p>Ligne 11, on reconna\u00eet le mot cl\u00e9 Include qui a d\u00e9j\u00e0 fait planter un pr\u00e9c\u00e9dent programme. Le code pr\u00e9c\u00e9dent peut \u00eatre remplac\u00e9 par le suivant\u00a0:</p> <pre><code>    // liste des cr\u00e9neaux horaires d'un m\u00e9decin donn\u00e9\n    public List&lt;Creneau&gt; GetCreneauxMedecin(int idMedecin)\n    {\n      // liste des cr\u00e9neaux\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          // on retourne la liste des cr\u00e9neaux du m\u00e9decin\n          return context.Creneaux.Where(c =&gt; c.MedecinId == idMedecin).ToList&lt;Creneau&gt;(); \n        }\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(3, \"GetCreneauxMedecin\", ex);\n      }\n}\n</code></pre> <p>Le nouveau code para\u00eet m\u00eame plus coh\u00e9rent que l'ancien. Toujours est-il que cette fois-ci le programme de test passe.</p> <p>Nous cr\u00e9ons la DLL du projet comme il a \u00e9t\u00e9 fait pour le projet [RdvMedecins-SqlServer-02] et nous rassemblons l'ensemble des DLL du projet dans un dossier [lib] cr\u00e9\u00e9 dans [RdvMedecins-PostgreSQL-02]. Ce seront les r\u00e9f\u00e9rences du projet web [RdvMedecins-PostgreSQL-03] qui va suivre.</p> <p>Nous sommes d\u00e9sormais pr\u00eats pour construire la couche [ASP.NET] de notre aplication\u00a0:</p> <p>Nous allons partir du projet [RdvMedecins-SqlServer-03]. Nous dupliquons le dossier de ce projet dans [RdvMedecins-PostgreSQL-03] [1]\u00a0:</p> <ul> <li>en [2], avec VS 2012 Express pour le web, nous ouvrons la solution du dossier [RdvMedecins-PostgreSQL-03]\u00a0;</li> <li>en [3], nous changeons et le nom de la solution et le nom du projet\u00a0;</li> </ul> <ul> <li>en [4], les r\u00e9f\u00e9rences actuelles du projet\u00a0;</li> <li>en [5], on les supprime\u00a0;</li> <li>en [6], pour les remplacer par des r\u00e9f\u00e9rences sur les DLL que nous venons de stocker dans un dossier [lib] du projet [RdvMedecins-PostgreSQL-02].</li> </ul> <p>Il ne nous reste plus qu'\u00e0 modifier le fichier [Web.config] On remplace son contenu actuel par le contenu du fichier [App.config] du projet [RdvMedecins-PostgreSQL-02]. Ceci fait, on ex\u00e9cute le projet web. Il marche. On n'oubliera pas de remplir la base avant d'ex\u00e9cuter l'application web.</p>"},{"location":"etude-de-cas-avec-mysql-5528.html","title":"4. Etude de cas avec MySQL 5.5.28","text":""},{"location":"etude-de-cas-avec-mysql-5528.html#41-installation-des-outils","title":"4.1. Installation des outils","text":"<p>Les outils \u00e0 installer sont les suivants\u00a0:</p> <ul> <li>le SGBD\u00a0: [http://dev.mysql.com/downloads/]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for MySQL Freeware [http://www.sqlmanager.net/fr/products/mysql/manager/download].</li> </ul> <p>Dans les exemples qui suivent, l'utilisateur root a le mot de passe root.</p> <p>Lan\u00e7ons MySQL5. ici, nous le faisons \u00e0 partir de la fen\u00eatre des services Windows [1]. En [2], le SGBD est lanc\u00e9.</p> <p>Nous lan\u00e7ons maintenant l'outil [SQL Manager Lite for MySQL] avec lequel on va administrer le SGBD [3].</p> <ul> <li>en [4], nous cr\u00e9ons une nouvelle base\u00a0;</li> <li>en [5], on indique le nom de la base\u00a0;</li> </ul> <ul> <li>en [5], on se connecte en tant root / root\u00a0;</li> <li>en [6], on valide l'ordre SQL qui va \u00eatre ex\u00e9cut\u00e9\u00a0;</li> </ul> <ul> <li>en [7], la base a \u00e9t\u00e9 cr\u00e9\u00e9e. Elle doit maintennat \u00eatre enregistr\u00e9e dans [EMS Manager]. Les informations sont bonnes. On fait [OK]\u00a0;</li> <li>en [8], on s'y connecte\u00a0;</li> <li>en [9], [EMS Manager] affiche la base, pour l'instant vide.</li> </ul> <p>Nous allons maintenant connecter un projet VS 2012 \u00e0 cette base.</p>"},{"location":"etude-de-cas-avec-mysql-5528.html#42-creation-de-la-base-a-partir-des-entites","title":"4.2. Cr\u00e9ation de la base \u00e0 partir des entit\u00e9s","text":"<p>Nous cr\u00e9ons le projet console VS 2012 [RdvMedecins-MySQL-01] [1] ci-dessous\u00a0:</p> <ul> <li>en [2], on ajoute des r\u00e9f\u00e9rences au projet via NuGet\u00a0;</li> </ul> <ul> <li>en [3], on ajoute la r\u00e9f\u00e9rence EF 5\u00a0;</li> <li>en [4], elle est d\u00e9sormais dans les r\u00e9f\u00e9rences\u00a0;</li> </ul> <ul> <li>en [5], on recommence pour ajouter cette fois [MySQL.Data.Entities] qui est un connecteur ADO.NET pour Entity Framework. Pour trouver le paquetage, on peut se faire aider par la zone de recherche [6]\u00a0;</li> <li>en [7], apparaissent deux r\u00e9f\u00e9rences [MySQL.Data.Entities] et [MySQL.Data], la derni\u00e8re \u00e9tant une d\u00e9pendance de la premi\u00e8re.</li> </ul> <p>Maintenant, on va construire le projet [RdvMedecins-MySQL-01] \u00e0 partir du projet [RdvMedecins-SqlServer-01].</p> <ul> <li>en [1], on copie les \u00e9l\u00e9ments s\u00e9lectionn\u00e9s\u00a0;</li> <li>en [2], on les colle dans le projet [RdvMedecins-MySQL-01]\u00a0;</li> <li>en [3], parce qu'il y a plusieurs programmes avec une m\u00e9thode [Main], il nous faut pr\u00e9ciser le projet de d\u00e9marrage du projet.</li> </ul> <p>A ce stade, la g\u00e9n\u00e9ration du projet doit r\u00e9ussir. Maintenant, nous allons modifier le fichier de configuration [App.config] qui configure la cha\u00eene de connexion \u00e0 la base de donn\u00e9es et le DbProviderFactory. Il devient le suivant\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;configSections&gt;\n    &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt;\n    &lt;section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" /&gt;\n  &lt;/configSections&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;entityFramework&gt;\n    &lt;defaultConnectionFactory type=\"System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework\" /&gt;\n  &lt;/entityFramework&gt;\n\n  &lt;!-- cha\u00eene de connexion--&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\"\n         connectionString=\"Server=localhost;Database=rdvmedecins-ef;Uid=root;Pwd=root;\"\n         providerName=\"MySql.Data.MySqlClient\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"MySQL Data Provider\" invariant=\"MySql.Data.MySqlClient\" description=\".Net Framework Data Provider for MySQL\"\n          type=\"MySql.Data.MySqlClient.MySqlClientFactory, MySql.Data, Version=6.5.4.0, Culture=neutral, PublicKeyToken=C5687FC88969C44D\"\n        /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n\n&lt;/configuration&gt;\n</code></pre> <ul> <li>ligne 17\u00a0: la cha\u00eene de connexion \u00e0 la base MySQL [rdvmedecins-ef] que nous avons cr\u00e9\u00e9e\u00a0;</li> <li>ligne 24\u00a0: la version doit correspondre \u00e0 celle de la r\u00e9f\u00e9rence [MySql.Data] du projet [1]\u00a0:</li> </ul> <p>Il y a un peu de configuration \u00e9galement dans le fichier [Entites.cs] o\u00f9 on pr\u00e9cise le nom des tables ainsi que le sch\u00e9ma auquel elles appartiennent. Celui-ci peut changer selon les SGBD. C'est le cas ici, o\u00f9 il n'y aura pas de sch\u00e9ma. Le fichier [Entites.cs] \u00e9volue comme suit\u00a0:</p> <pre><code>  [Table(\"MEDECINS\")]\n  public class Medecin : Personne\n  {...}\n\n  [Table(\"CLIENTS\")]\n  public class Client : Personne\n  {...}\n\n  [Table(\"CRENEAUX\")]\n  public class Creneau\n  {...}\n\n  [Table(\"RVS\")]\n  public class Rv\n  {...}\n</code></pre> <p>Ex\u00e9cutons le programme [CreateDB_01] [2]. On obtient l'exception suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: System.Data.MetadataException: Le sch\u00e9ma sp\u00e9cifi\u00e9 n'est pas valide. Erreurs :\n(11,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(23,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(33,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n(43,6) : erreur 0040: Le type rowversion n'est pas qualifi\u00e9 avec un espace de noms ou un alias. Seuls les types primitifs peuvent \u00eatre utilis\u00e9s sans qualification.\n   \u00e0 System.Data.Metadata.Edm.StoreItemCollection.Loader.ThrowOnNonWarningErrors\n()\n   ....\n   \u00e0 RdvMedecins_01.CreateDB_01.Main(String[] args) dans d:\\data\\istia-1213\\c#\\d\nvp\\Entity Framework\\RdvMedecins\\RdvMedecins-MySQL-01\\CreateDB_01.cs:ligne 15\n</code></pre> <p>La m\u00eame erreur appara\u00eet quatre fois (lignes 2-5). Le type rowversion fait penser au champ ayant l'annotation [Timestamp] dans les entit\u00e9s\u00a0:</p> <pre><code>    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n</code></pre> <p>Nous d\u00e9cidons de remplacer ces trois lignes par les suivantes\u00a0:</p> <pre><code>    [ConcurrencyCheck]\n    [Column(\"VERSIONING\")]\n    public DateTime? Versioning { get; set; }\n</code></pre> <p>On change le type de la colonne qui passe de byte[] \u00e0 DateTime?. On fait cela parce que MySQL a un type [TIMESTAMP] qui repr\u00e9sente une date / heure et qu'une colonne ayant ce type est automatiquement mise \u00e0 jour par MySQL \u00e0 chaque fois que la ligne est mise \u00e0 jour. Cela nous permettra de g\u00e9rer les acc\u00e8s concurrents.</p> <p>L'annotation [Timestamp] ne peut s'appliquer qu'\u00e0 une colonne de type byte[]. On la remplace par l'annotation [ConcurrencyCheck]. Ces deux annotations g\u00e8rent toutes deux la concurrence d'acc\u00e8s. Nous faisons cela pour les quatre entit\u00e9s puis nous r\u00e9ex\u00e9cutons l'application. Nous obtenons alors l'erreur suivante\u00a0:</p> <pre><code>Exception non g\u00e9r\u00e9e\u00a0: MySql.Data.MySqlClient.MySqlException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'NOT NULL,        `ProductVersion` mediumtext NOT NULL);\n\nALTER TABLE `__MigrationH' at line 5\n   \u00e0 MySql.Data.MySqlClient.MySqlStream.ReadPacket()\n   \u00e0 MySql.Data.MySqlClient.NativeDriver.GetResult(Int32&amp; affectedRow, Int32&amp; insertedId)\n   ...\n   \u00e0 RdvMedecins_01.CreateDB_01.Main(String[] args) dans d:\\data\\istia-1213\\c#\\d\nvp\\Entity Framework\\RdvMedecins\\RdvMedecins-MySQL-01\\CreateDB_01.cs:ligne 15\n</code></pre> <p>La ligne 1 indique une erreur de syntaxe sur le SQL ex\u00e9cut\u00e9 par MySQL. Comme celui-ci n'a pas \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9 par nous mais par le provider ADO.NET de MySQL, nous ne pouvons pas corriger ce point. N\u00e9anmoins, on peut constater que des tables ont \u00e9t\u00e9 cr\u00e9\u00e9es [1] ci-dessous\u00a0:</p> <ul> <li>en [2], on voit la structure de la table [clients] [3].</li> </ul> <p>Il y a plusieurs modifications \u00e0 faire sur la base g\u00e9n\u00e9r\u00e9e\u00a0:</p> <ul> <li>le type de la colonne [VERSIONING] ne convient pas. Il faut lui donner le type MySQL [TIMESTAMP]\u00a0;</li> <li>on se rappelle que la table [rvs] a une contrainte d'unicit\u00e9. Elle n'a pas \u00e9t\u00e9 cr\u00e9\u00e9e par cette g\u00e9n\u00e9ration\u00a0;</li> <li>le connecteur ADO.NET de SQL Server avait g\u00e9n\u00e9r\u00e9 des cl\u00e9s \u00e9trang\u00e8res avec la clause ON DELETE CASCADE. Le connecteur ADO.NET de MySQL ne l'a pas fait.</li> </ul> <p>Comme nous l'avons fait avec SQL Server, il nous faut donc modifier la base g\u00e9n\u00e9r\u00e9e. Nous ne montrons pas comment faire les modifications. Nous donnons simplement le script de cr\u00e9ation de la base\u00a0:</p> <pre><code># SQL Manager Lite for MySQL 5.3.0.2\n# ---------------------------------------\n# Host     : localhost\n# Port     : 3306\n# Database : rdvmedecins-ef\n\n\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n/*!40101 SET NAMES utf8 */;\n\nSET FOREIGN_KEY_CHECKS=0;\n\nUSE `rdvmedecins-ef`;\n\n#\n# Structure for the `clients` table : \n#\n\nCREATE TABLE `clients` (\n  `ID` INTEGER(11) NOT NULL AUTO_INCREMENT,\n  `NOM` VARCHAR(30) COLLATE utf8_general_ci NOT NULL,\n  `PRENOM` VARCHAR(30) COLLATE utf8_general_ci NOT NULL,\n  `TITRE` VARCHAR(5) COLLATE utf8_general_ci NOT NULL,\n  `VERSIONING` TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY USING BTREE (`ID`) COMMENT ''\n)ENGINE=InnoDB\nAUTO_INCREMENT=96 AVG_ROW_LENGTH=4096 CHARACTER SET 'utf8' COLLATE 'utf8_general_ci'\nCOMMENT=''\n;\n\n#\n# Structure for the `medecins` table : \n#\n\nCREATE TABLE `medecins` (\n  `ID` INTEGER(11) NOT NULL AUTO_INCREMENT,\n  `NOM` VARCHAR(30) COLLATE utf8_general_ci NOT NULL,\n  `PRENOM` VARCHAR(30) COLLATE utf8_general_ci NOT NULL,\n  `TITRE` VARCHAR(5) COLLATE utf8_general_ci NOT NULL,\n  `VERSIONING` TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY USING BTREE (`ID`) COMMENT ''\n)ENGINE=InnoDB\nAUTO_INCREMENT=56 AVG_ROW_LENGTH=4096 CHARACTER SET 'utf8' COLLATE 'utf8_general_ci'\nCOMMENT=''\n;\n\n#\n# Structure for the `creneaux` table : \n#\n\nCREATE TABLE `creneaux` (\n  `ID` INTEGER(11) NOT NULL AUTO_INCREMENT,\n  `HDEBUT` INTEGER(11) NOT NULL,\n  `MDEBUT` INTEGER(11) NOT NULL,\n  `HFIN` INTEGER(11) NOT NULL,\n  `MFIN` INTEGER(11) NOT NULL,\n  `MEDECIN_ID` INTEGER(11) NOT NULL,\n  `VERSIONING` TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY USING BTREE (`ID`) COMMENT '',\n   INDEX `MEDECIN_ID` USING BTREE (`MEDECIN_ID`) COMMENT '',\n  CONSTRAINT `creneaux_ibfk_1` FOREIGN KEY (`MEDECIN_ID`) REFERENCES `medecins` (`ID`) ON DELETE CASCADE ON UPDATE NO ACTION\n)ENGINE=InnoDB\nAUTO_INCREMENT=472 AVG_ROW_LENGTH=455 CHARACTER SET 'utf8' COLLATE 'utf8_general_ci'\nCOMMENT=''\n;\n\n#\n# Structure for the `rvs` table : \n#\n\nCREATE TABLE `rvs` (\n  `ID` INTEGER(11) NOT NULL AUTO_INCREMENT,\n  `JOUR` DATE NOT NULL,\n  `CRENEAU_ID` INTEGER(11) NOT NULL,\n  `CLIENT_ID` INTEGER(11) NOT NULL,\n  `VERSIONING` TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY USING BTREE (`ID`) COMMENT '',\n  UNIQUE INDEX `CRENEAU_ID_JOUR` USING BTREE (`JOUR`, `CRENEAU_ID`) COMMENT '',\n   INDEX `CRENEAU_ID` USING BTREE (`CRENEAU_ID`) COMMENT '',\n   INDEX `CLIENT_ID` USING BTREE (`CLIENT_ID`) COMMENT '',\n  CONSTRAINT `rvs_ibfk_2` FOREIGN KEY (`CLIENT_ID`) REFERENCES `clients` (`ID`) ON DELETE CASCADE ON UPDATE NO ACTION,\n  CONSTRAINT `rvs_ibfk_1` FOREIGN KEY (`CRENEAU_ID`) REFERENCES `creneaux` (`ID`) ON DELETE CASCADE ON UPDATE NO ACTION\n)ENGINE=InnoDB\nAUTO_INCREMENT=28 AVG_ROW_LENGTH=16384 CHARACTER SET 'utf8' COLLATE 'utf8_general_ci'\nCOMMENT=''\n;\n</code></pre> <ul> <li>lignes 22, 38, 54, 74\u00a0: les cl\u00e9s primaires ID des tables sont de type AUTO_INCREMENT donc g\u00e9n\u00e9r\u00e9es par MySQL\u00a0;</li> <li>lignes 26, 42, 60, 78\u00a0: la colonne VERSIONING est de type TIMESTAMP et est mise \u00e0 jour lors d'un INSERT ou d'un UPDATE\u00a0;</li> <li>ligne 63\u00a0: la cl\u00e9 \u00e9trang\u00e8re de la table [creneaux] vers la table [medecins] avec la clause ON DELETE CASCADE\u00a0;</li> <li>ligne 80\u00a0: la contrainte d'unicit\u00e9 de la table [rvs]\u00a0;</li> <li>ligne 83\u00a0: la cl\u00e9 \u00e9trang\u00e8re de la table [rvs] vers la table [creneaux] avec la clause ON DELETE CASCADE\u00a0;</li> <li>ligne 84\u00a0: la cl\u00e9 \u00e9trang\u00e8re de la table [rvs] vers la table [clients] avec la clause ON DELETE CASCADE\u00a0;</li> </ul> <p>Le script de g\u00e9n\u00e9ration des tables de la base MySQL [rvmedecins-ef] a \u00e9t\u00e9 plac\u00e9 dans le dossier [RdvMedecins / databases / mysql]. Le lecteur pourra le charger et l'ex\u00e9cuter pour cr\u00e9er ses tables.</p> <p>Ceci fait, les diff\u00e9rents programmes du projet peuvent \u00eatre ex\u00e9cut\u00e9s. Ils donnent les m\u00eames r\u00e9sultats qu'avec SQL Server sauf pour le programme [ModifyDetachedEntities] qui plante. Pour comprendre pourquoi, on peut regarder le r\u00e9sultat du programme [ModifyAtttachedEntities]\u00a0:</p> <pre><code>client1--avant\nClient [,xx,xx,xx,]\nclient1--apr\u00e8s\nClient [86,xx,xx,xx,]\nclient2\nClient [86,xx,xx,xx,11/10/2012 11:31:12]\nclient3\nClient [86,xx,xx,yy,11/10/2012 11:31:12]\n</code></pre> <ul> <li>lignes 1-2\u00a0: un client avant sauvegarde du contexte\u00a0;</li> <li>lignes 3-4\u00a0: le client apr\u00e8s la sauvegarde. Il a une cl\u00e9 primaire mais pas de valeur pour son champ [Versioning] alors que SQL Server mettait \u00e0 jour le champ [Timestamp] de l'entit\u00e9.</li> </ul> <p>Maintenant examinons le code du programme [ModifyDetachedEntities] qui plante\u00a0:</p> <pre><code>using System;\n...\n\nnamespace RdvMedecins_01\n{\n  class ModifyDetachedEntities\n  {\n    static void Main(string[] args)\n    {\n      Client client1;\n\n      // on vide la base actuelle\n      Erase();\n      // on ajoute un client\n      using (var context = new RdvMedecinsContext())\n      {\n        // cr\u00e9ation client\n        client1 = new Client { Titre = \"x\", Nom = \"x\", Prenom = \"x\" };\n        // ajout du client au contexte\n        context.Clients.Add(client1);\n        // on sauvegarde le contexte\n        context.SaveChanges();\n      }\n      // affichage base\n      Dump(\"1-----------------------------\");\n      // client1 n'est pas dans le contexte - on le modifie\n      client1.Nom = \"y\";\n      // modification entit\u00e9 hors contexte\n      using (var context = new RdvMedecinsContext())\n      {\n        // ici, on a un nouveau contexte vide\n        // on met client1 dans le contexte dans un \u00e9tat modifi\u00e9\n        context.Entry(client1).State = EntityState.Modified;\n        // on sauvegarde le contexte\n        context.SaveChanges();\n      }\n      ...\n    }\n\n    static void Erase()\n    {\n      ...\n    }\n\n    static void Dump(string str)\n    {\n      ...\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 20\u00a0: un client est sauvegard\u00e9. Il a alors sa cl\u00e9 primaire mais par sa version\u00a0;</li> <li>ligne 33\u00a0: une modification est faite avec client1. Elle \u00e9choue car il n'a pas la version qui est en base.</li> </ul> <p>On r\u00e9soud le probl\u00e8me en intercalant le code suivant entre les lignes 25 et 26\u00a0:</p> <pre><code>      // on r\u00e9cup\u00e8re client1 pour avoir sa version\n      using (var context = new RdvMedecinsContext())\n      {\n        // client2 sera dans le contexte\n        Client client2 = context.Clients.Find(client1.Id);\n        // on fixe la version de client1 \u00e0 celle de client2\n        client1.Versioning = client2.Versioning;\n}\n</code></pre> <p>D\u00e9sormais, l'entit\u00e9 [client1] a la m\u00eame version qu'en base et peut donc \u00eatre utilis\u00e9e pour une mise \u00e0 jour de la ligne en base.</p>"},{"location":"etude-de-cas-avec-mysql-5528.html#43-architecture-multi-couche-sappuyant-sur-ef-5","title":"4.3. Architecture multi-couche s'appuyant sur EF 5","text":"<p>Nous revenons \u00e0 notre \u00e9tude de cas d\u00e9crite au paragraphe 2.</p> <p>Nous allons commencer par construire la couche [DAO] d'acc\u00e8s aux donn\u00e9es. Pour ce faire, nous cr\u00e9ons le projet console VS 2012 [RdvMedecins-MySQL-02] [1]\u00a0:</p> <ul> <li>en [2], les r\u00e9f\u00e9rences [Common.Logging, EntityFramework, MySql.Data, MySql.Data.Entity, Spring.Core] sont ajout\u00e9es avec NuGet\u00a0;</li> <li>en [3], le dossier [Models] est recopi\u00e9 du projet [RdvMedecins-MySQL-01]\u00a0;</li> </ul> <ul> <li>en [4], les dossiers [Dao, Exception, Tests] et le fichier [App.config] sont recopi\u00e9s du projet [RdvMedecins-SqlServer-02]\u00a0;</li> <li>en [5], le fichier [Program.cs] a \u00e9t\u00e9 supprim\u00e9\u00a0;</li> <li>en [6], le projet est configur\u00e9 pour ex\u00e9cuter le programme de test de la couche [DAO].</li> </ul> <p>Dans le fichier [App.config], on remplace les informations de la base SQL Server par celles de la base MySQL. On les trouve dans le fichier [App.config] du projet [RdvMedecins-MySQL-01]\u00a0:</p> <pre><code>&lt;!-- cha\u00eene de connexion--&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\"\n         connectionString=\"Server=localhost;Database=rdvmedecins-ef;Uid=root;Pwd=root;\"\n         providerName=\"MySql.Data.MySqlClient\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"MySQL Data Provider\" invariant=\"MySql.Data.MySqlClient\" description=\".Net Framework Data Provider for MySQL\"\n          type=\"MySql.Data.MySqlClient.MySqlClientFactory, MySql.Data, Version=6.5.4.0, Culture=neutral, PublicKeyToken=C5687FC88969C44D\"\n        /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n</code></pre> <p>Les objets g\u00e9r\u00e9s par Spring changent \u00e9galement. Actuellement on a\u00a0:</p> <pre><code>  &lt;!-- configuration Spring --&gt;\n  &lt;spring&gt;\n    &lt;context&gt;\n      &lt;resource uri=\"config://spring/objects\" /&gt;\n    &lt;/context&gt;\n    &lt;objects xmlns=\"http://www.springframework.net\"&gt;\n      &lt;object id=\"rdvmedecinsDao\" type=\"RdvMedecins.Dao.Dao,RdvMedecins-SqlServer-02\" /&gt;\n    &lt;/objects&gt;\n&lt;/spring&gt;\n</code></pre> <p>La ligne 7 r\u00e9f\u00e9rence l'assembly du projet [RdvMedecins-SqlServer-02]. L'assembly est d\u00e9sormais [RdvMedecins-MySQL-02].</p> <p>Ceci fait, nous sommes pr\u00eats \u00e0 ex\u00e9cuter le test de la couche [DAO]. Il faut auparavant prendre soin de remplir la base (programme [Fill] du projet [RdvMedecins-MySQL-01]). Le programme de test r\u00e9ussit.</p> <p>Nous cr\u00e9ons la DLL du projet comme il a \u00e9t\u00e9 fait pour le projet [RdvMedecins-SqlServer-02] et nous rassemblons l'ensemble des DLL du projet dans un dossier [lib] cr\u00e9\u00e9 dans [RdvMedecins-MySQL-02]. Ce seront les r\u00e9f\u00e9rences du projet web [RdvMedecins-MySQL-03] qui va suivre.</p> <p>Nous sommes d\u00e9sormais pr\u00eats pour construire la couche [ASP.NET] de notre aplication\u00a0:</p> <p>Nous allons partir du projet [RdvMedecins-SqlServer-03]. Nous dupliquons le dossier de ce projet dans [RdvMedecins-MySQL-03] [1]\u00a0:</p> <ul> <li>en [2], avec VS 2012 Express pour le web, nous ouvrons la solution du dossier [RdvMedecins-MySQL-03]\u00a0;</li> <li>en [3], nous changeons et le nom de la solution et le nom du projet\u00a0;</li> </ul> <ul> <li>en [4], les r\u00e9f\u00e9rences actuellesdu projet\u00a0;</li> <li>en [5], on les supprime\u00a0;</li> <li>en [6], pour les remplacer par des r\u00e9f\u00e9rences sur les DLL que nous venons de stocker dans un dossier [lib] du projet [RdvMedecins-MySQL-02].</li> </ul> <p>Il ne nous reste plus qu'\u00e0 modifier le fichier [Web.config] On remplace son contenu actuel par le contenu du fichier [App.config] du projet [RdvMedecins-MySQL-02]. Ceci fait, on ex\u00e9cute le projet web. Il marche.</p>"},{"location":"etude-de-cas-avec-mysql-5528.html#44-conclusion","title":"4.4. Conclusion","text":"<p>R\u00e9capitulons ce qui a \u00e9t\u00e9 fait pour passer du SGBD SQL server au SGBD MySQL\u00a0:</p> <ul> <li>le champ qui servait \u00e0 g\u00e9rer la concurrence d'acc\u00e8s aux entit\u00e9s a \u00e9t\u00e9 chang\u00e9. Sa version SQL Server \u00e9tait\u00a0:</li> </ul> <pre><code>    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n</code></pre> <p>Elle est devenue\u00a0:</p> <pre><code>    [ConcurrencyCheck]\n    [Column(\"VERSIONING\")]\n    public DateTime? Versioning { get; set; }\n</code></pre> <p>avec MySQL\u00a0;</p> <ul> <li>les annotations [Table] qui lient une entit\u00e9 \u00e0 une table ont \u00e9t\u00e9 chang\u00e9es\u00a0;</li> <li>la cha\u00eene de connexion \u00e0 la base et le [DbProviderFactory] ont \u00e9t\u00e9 modifi\u00e9s dans les fichiers de configuration [App.config] et [Web.config]\u00a0;</li> <li>apr\u00e8s sauvegarde en base, une entit\u00e9 SQL Server avait \u00e0 la fois sa cl\u00e9 primaire et son Timestamp. Avec MySQL, elle avait seulement sa cl\u00e9 primaire. Cela a amen\u00e9 la modification d'un code.</li> </ul> <p>Au final, c'est assez peu de modifications mais il a quand m\u00eame fallu revoir du code. Nous recommen\u00e7ons la m\u00eame d\u00e9marche pour trois autres SGBD\u00a0:</p> <ul> <li>Le SGBD Oracle Database Express Edition 11g Release 2\u00a0;</li> <li>Le SGBD PostgreSQL 9.2.1\u00a0;</li> <li>Le SGBD Firebird 2.1.</li> </ul>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html","title":"3. Etude de cas avec SQL Server Express 2012","text":""},{"location":"etude-de-cas-avec-sql-server-express-2012.html#31-introduction","title":"3.1. Introduction","text":"<p>Les exemples trouv\u00e9s sur le net pour Entity Framework sont dans leur majorit\u00e9 des exemples avec SQL Server. C'est assez normal. Il est probable que c'est le SGBD le plus r\u00e9pandu dans le monde .NET des entreprises. Nous allons suivre cette tendance. Les exemples seront ensuite \u00e9tendus \u00e0 toutes les bases de donn\u00e9es cit\u00e9es au paragraphe 1.2.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#32-installation-des-outils","title":"3.2. Installation des outils","text":"<p>Nous ne d\u00e9crirons pas l'installation des outils. En effet, cela n\u00e9cessiterait \u00e9norm\u00e9ment de copies d'\u00e9cran qui deviennent assez vite obsol\u00e8tes. C'est une t\u00e2che (pas toujours facile, il est vrai) que nous laissons au lecteur.</p> <p>Il nous faut installer les outils suivants\u00a0:</p> <ul> <li>le SGBD SQL Server Express 2012 : [http://www.microsoft.com/fr-fr/download/details.aspx?id=29062]. T\u00e9l\u00e9charger la version \"\u00a0With Tools\u00a0\" qui am\u00e8ne avec le SGBD un outil d'administration\u00a0:</li> </ul> <p>Une fois le SGBD install\u00e9, nous le lan\u00e7ons\u00a0:</p> <ul> <li>[1]\u00a0: dans le Menu D\u00e9marrer, lancer le \"\u00a0Gestionnaire de configuration SQL Server\u00a0\"\u00a0;</li> <li>[2]\u00a0: dans ce gestionnaire, lancer le serveur\u00a0;</li> <li>[3]\u00a0: il est lanc\u00e9.</li> </ul> <p>Nous lan\u00e7ons maintenant l'outil d'administration de SQL Server\u00a0:</p> <ul> <li>[1]\u00a0: dans le Menu D\u00e9marrer, lancer \"\u00a0SQL Server Management Studio\u00a0\"\u00a0;</li> <li>[2]\u00a0: l'outil d'administration.</li> </ul> <p>Nous allons nous connecter au serveur\u00a0:</p> <ul> <li>en [1], on connecte l'explorateur d'objets\u00a0;</li> <li>en [2], on donne les param\u00e8tres de la connexion\u00a0:</li> <li>[3]\u00a0: le serveur (local) (attention aux parenth\u00e8ses n\u00e9cessaires) d\u00e9signe le serveur install\u00e9 sur la machine,</li> <li>[4]\u00a0: on choisit l'authentification Windows. Il faut \u00eatre administrateur de son poste pour que cette connexion r\u00e9ussisse,</li> <li>[5]\u00a0: on se connecte\u00a0;</li> </ul> <ul> <li>[6]\u00a0: on est connect\u00e9\u00a0;</li> <li>[7]\u00a0: on veut modifier certaines propri\u00e9t\u00e9s du serveur\u00a0;</li> </ul> <ul> <li>[8]\u00a0: on demande \u00e0 ce qu'il y ait deux modes d'authentification\u00a0:</li> <li>authentification Windows comme il vient d'\u00eatre utilis\u00e9. Un utilisateur windows avec les bons droits peut alors se connecter,</li> <li>authentification SQL Server. L'utilisateur doit faire partie des utilisateurs enregistr\u00e9s dans le SGBD\u00a0;</li> </ul> <p>Ceci fait, on peut valider les propri\u00e9t\u00e9s du serveur\u00a0;</p> <ul> <li>[9]\u00a0: on \u00e9dite les propri\u00e9t\u00e9s de l'utilisateur sa (system administrator)\u00a0;</li> </ul> <ul> <li>en [10], on lui fixe un mot de passe. Dans la suite du document, celui-ci est sqlserver2012\u00a0;</li> </ul> <ul> <li>en [10], on lui donne l'autorisation de se connecter\u00a0;</li> <li>en [11], la connexion est activ\u00e9e. Ceci fait l'assistant peut \u00eatre valid\u00e9\u00a0;</li> <li>en [12], on se d\u00e9connecte du serveur.</li> </ul> <p>Maintenant, nous nous reconnectons avec le login sa/sqlserver2012\u00a0:</p> <ul> <li>en [1], on se reconnecte\u00a0;</li> <li>en [2], en authentification SQL Server\u00a0;</li> <li>en [3], l'utilisateur est sa\u00a0;</li> <li>en [4], son mot de passe est sqlserver2012\u00a0;</li> <li>en [5], on se connecte\u00a0;</li> </ul> <ul> <li>en [6], on est connect\u00e9.</li> </ul> <p>Nous allons maintenant cr\u00e9er une base de d\u00e9monstration\u00a0:</p> <ul> <li>en [1], on cr\u00e9e une nouvelle BD\u00a0;</li> <li>en [2], elle s'appellera demo\u00a0;</li> <li>en [3], on valide\u00a0;</li> </ul> <ul> <li>en [4], la base cr\u00e9\u00e9e\u00a0;</li> <li>en [5], on cr\u00e9e une nouvelle table \u00e0 la base demo\u00a0;</li> </ul> <ul> <li>en [6], on d\u00e9finit une table \u00e0 deux colonnes ID et NOM\u00a0;</li> <li>en [7], on fait de la colonne [ID] la cl\u00e9 primaire\u00a0;</li> <li>en [8], la cl\u00e9 primaire est symbolis\u00e9e par une cl\u00e9\u00a0;</li> <li>en [9], on sauvegarde la table\u00a0;</li> <li>en [10], on lui donne un nom\u00a0;</li> <li>en [11], pour que la table apparaisse dans la base [demo], il faut actualiser la base\u00a0;</li> <li>en [12], la table [PERSONNES] a bien \u00e9t\u00e9 cr\u00e9\u00e9e.</li> </ul> <p>Nous en savons assez pour l'instant sur l'utilisation de l'outil d'administration de SQL Server.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#33-le-serveur-embarque-localdbv110","title":"3.3. Le serveur embarqu\u00e9 (localdb)\\v11.0","text":"<p>VS Express 2012 vient avec un serveur SQL embarqu\u00e9. On suppose ici que VS Express 2012 a \u00e9t\u00e9 install\u00e9 [http://www.microsoft.com/visualstudio/fra/downloads]. On lance VS 2012 [1]\u00a0:</p> <p>On lance l'outil d'administration de SQL Server 2012 [2] et on se connecte [3].</p> <ul> <li>en [4], on se connecte au serveur (localdb)\\v11.0\u00a0;</li> <li>en [5], avec une authentification Windows\u00a0;</li> <li>en [6], la connexion r\u00e9ussie affiche les bases de donn\u00e9es du serveur. On pourrait comme pr\u00e9c\u00e9demment cr\u00e9er une nouvelle base.</li> </ul> <p>Nous n'utiliserons pas ce serveur embarqu\u00e9 dans VS 2012.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#34-creation-de-la-base-a-partir-des-entites","title":"3.4. Cr\u00e9ation de la base \u00e0 partir des entit\u00e9s","text":"<p>Entity Framework 5 Code First permet de cr\u00e9er une base de donn\u00e9es \u00e0 partir des entit\u00e9s. C'est ce que nous voyons maintenant. Avec VS Express 2012, nous cr\u00e9ons un premier projet console en C#\u00a0:</p> <ul> <li>en [1], la d\u00e9finition du projet\u00a0;</li> <li>en [2], le projet cr\u00e9\u00e9.</li> </ul> <p>Tous nos projets vont avoir besoin de la DLL d'Entity Framework 5. Nous l'ajoutons\u00a0:</p> <ul> <li>en [1], l'outil NuGet permet de t\u00e9l\u00e9charger des d\u00e9pendances\u00a0;</li> </ul> <ul> <li>en [2], on t\u00e9l\u00e9charge la d\u00e9pendance Entity Framework\u00a0;</li> <li>en [3], la r\u00e9f\u00e9rence a \u00e9t\u00e9 ajout\u00e9e au projet.</li> </ul> <p>On peut en savoir plus en regardant les propri\u00e9t\u00e9s de la r\u00e9f\u00e9rence ajout\u00e9e\u00a0:</p> <ul> <li>en [1], la version de la DLL. Il faut la version 5\u00a0;</li> <li>en [2], sa place dans le syst\u00e8me de fichiers\u00a0: &lt;solution&gt;\\packages\\EntityFramework.5.0.0\\lib\\net45\\EntityFramework.dll o\u00f9 &lt;solution&gt; est le dossier de la solution VS. Tous les packages ajout\u00e9s par NuGet iront dans le dossier &lt;solution&gt;/packages\u00a0;</li> <li>en [3], un fichier [packages.config] a \u00e9t\u00e9 cr\u00e9\u00e9. Son contenu est le suivant\u00a0:</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;packages&gt;\n  &lt;package id=\"EntityFramework\" version=\"5.0.0\" targetFramework=\"net45\" /&gt;\n&lt;/packages&gt;\n</code></pre> <p>Il liste les paquetages import\u00e9s par NuGet.</p> <p>Revenons au projet VS et cr\u00e9ons un dossier [Models] dans le projet\u00a0:</p> <ul> <li>en [1], ajout d'un dossier au projet\u00a0;</li> <li>en [2], il s'appellera [Models].</li> </ul> <p>Nous garderons cette habitude par la suite de mettre la d\u00e9finition de nos entit\u00e9s dans le dossier [Models].</p> <p>Pour construire nos entit\u00e9s, nous allons nous aider de la d\u00e9finition de la base de donn\u00e9es MySQL 5 utilis\u00e9e dans le projet NHibernate. Rappelons le r\u00f4le des entit\u00e9s EF\u00a0:</p> <p>Les entit\u00e9s doivent refl\u00e9ter les tables de la base de donn\u00e9es. La couche d'acc\u00e8s aux donn\u00e9es utilise ces entit\u00e9s au lieu de travailler directement avec les tables. Commen\u00e7ons par la table [MEDECINS]\u00a0:</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#341-lentite-medecin","title":"3.4.1. L'entit\u00e9 [Medecin]","text":"<p>Elle contient des informations sur les m\u00e9decins g\u00e9r\u00e9s par l'application [RdvMedecins].</p> <ul> <li>ID : n\u00b0 identifiant le m\u00e9decin - cl\u00e9 primaire de la table</li> <li>VERSION : n\u00b0 identifiant la version de la ligne dans la table. Ce nombre est incr\u00e9ment\u00e9 de 1 \u00e0 chaque fois qu'une modification est apport\u00e9e \u00e0 la ligne.</li> <li>NOM : le nom du m\u00e9decin</li> <li>PRENOM : son pr\u00e9nom</li> <li>TITRE : son titre (Melle, Mme, Mr)</li> </ul> <p>Nous pourrions partir de la classe [Medecin] suivante\u00a0:</p> <pre><code>using System;\n\n[Table(\"MEDECINS\", Schema = \"dbo\")]\n  namespace RdvMedecins.Entites\n{\n  public class Medecin\n  {\n    // data\n    public int Id { get; set; }\n    public string Titre { get; set; }\n    public string Nom { get; set; }\n    public string Prenom { get; set; }\n}\n</code></pre> <ul> <li>ligne 3\u00a0: la classe [Medecin] est associ\u00e9e \u00e0 la table [MEDECINS] de la base de donn\u00e9es. Celle-ci se trouvera dans un sch\u00e9ma nomm\u00e9 \"\u00a0dbo\u00a0\".</li> </ul> <p>Nous mettons cette classe dans un fichier [Entites.cs] [1]. C'est l\u00e0 que nous placerons toutes nos entit\u00e9s.</p> <p>Toujours dans le dossier [Models], nous cr\u00e9ons le fichier [Context.cs] suivant\u00a0:</p> <pre><code>using System.Data.Entity;\nusing RdvMedecins.Entites;\n\nnamespace RdvMedecins.Models\n{\n\n  // le contexte\n  public class RdvMedecinsContext : DbContext\n  {\n    // les m\u00e9decins\n    public DbSet&lt;Medecin&gt; Medecins { get; set; }\n  }\n\n  // initialisation de la base\n  public class RdvMedecinsInitializer : DropCreateDatabaseAlways&lt;RdvMedecinsContext&gt;\n  {\n  }\n}\n</code></pre> <ul> <li>ligne 8\u00a0: la classe [RdvMedecinsContext] va repr\u00e9senter le contexte de persistance, c.-\u00e0-d. l'ensemble des entit\u00e9s g\u00e9r\u00e9es par l'ORM. Elle doit d\u00e9river de la classe [System.Data.Entity.DbContext]\u00a0;</li> <li>ligne 11\u00a0: le champ [Medecins] va repr\u00e9senter les entit\u00e9s de type [Medecin] du contexte de persistance. Il est de type DbSet&lt;Medecin&gt;. On trouvera g\u00e9n\u00e9ralement autant de [DbSet] que de tables dans la base, un par table\u00a0;</li> <li>ligne 15\u00a0: on d\u00e9finit une classe [RdvMedecinsInitializer] pour initialiser la base cr\u00e9\u00e9e. Ici elle d\u00e9rive de la classe [DropCreateDataBaseAlways] qui comme son nom l'indique supprime la base si elle existe d\u00e9j\u00e0 puis la recr\u00e9e. C'est pratique en phase de d\u00e9veloppement de la BD. Le param\u00e8tre de la classe [DropCreateDataBaseAlways] est le type de contexte de persistance associ\u00e9 \u00e0 la base. On peut utiliser d'autres classes m\u00e8res que [DropCreateDataBaseAlways] pour la classe d'initialisation\u00a0:</li> <li>[DropCreateDatabaseIfModelChanges]\u00a0: recr\u00e9e la base si les entit\u00e9s ont chang\u00e9,</li> <li>[CreateDatabaseIfNotExists]\u00a0: cr\u00e9e la base si elle n'existe pas\u00a0;</li> </ul> <p>Il nous reste \u00e0 cr\u00e9er un programme principal. Ce sera le suivant [CreateDB_01.cs]\u00a0:</p> <pre><code>using System;\nusing System.Data.Entity;\nusing RdvMedecins.Models;\n\nnamespace RdvMedecins_01\n{\n  class CreateDB_01\n  {\n    static void Main(string[] args)\n    {\n      // on cr\u00e9e la base\n      Database.SetInitializer(new RdvMedecinsInitializer());\n      using (var context = new RdvMedecinsContext())\n      {\n        context.Database.Initialize(false);\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 12\u00a0: [System.Data.Entity.DataBase] est une classe offrant des m\u00e9thodes statiques pour g\u00e9rer la base associ\u00e9e \u00e0 un contexte de persistance. La m\u00e9thode statique [SetInitializer] permet de pr\u00e9ciser la classe d'initialisation de la base. Cela ne lance pas l'initialisation\u00a0;</li> <li>ligne 13\u00a0: pour travailler avec un contexte de persistance, il faut instancier celui-ci. C'est ce qui est fait ici. On utilise une clause using afin que le contexte soit automatiquement ferm\u00e9 \u00e0 la sortie de la clause. Donc ligne 17, le contexte est ferm\u00e9\u00a0;</li> <li>ligne 15\u00a0: on lance explicitement la g\u00e9n\u00e9ration de la base associ\u00e9e au contexte de persistance [RdvMedecinsContext]. Le param\u00e8tre false indique que cette op\u00e9ration ne doit pas \u00eatre faite si elle a d\u00e9j\u00e0 \u00e9t\u00e9 faite pour ce contexte. Ici, on aurait tout aussi bien pu mettre true.</li> </ul> <p>Lorsqu'on travaille avec une base de donn\u00e9es, les param\u00e8tres de connexion sont g\u00e9n\u00e9ralement inscrits dans le fichier [App.config]. Constatons que pour l'instant, ils n'y sont pas\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;configSections&gt;\n    &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt;\n    &lt;section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" /&gt;\n  &lt;/configSections&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;entityFramework&gt;\n    &lt;defaultConnectionFactory type=\"System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework\" /&gt;\n  &lt;/entityFramework&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Les \u00e9l\u00e9ments ci-dessus ont \u00e9t\u00e9 inscrits dans [App.config] lorsqu'on a ajout\u00e9 la d\u00e9pendance Entity Framework aux r\u00e9f\u00e9rences du projet.</p> <p>Ex\u00e9cutons le projet (Ctrl-F5) apr\u00e8s avoir lanc\u00e9 SQL Server Express (c'est important)\u00a0:</p> <p>L'ex\u00e9cution doit se terminer sans erreur. Ouvrons maintenant l'outil d'administration de SQL Server et rafra\u00eechissons l'affichage\u00a0:</p> <p>On constate qu'une base portant le nom complet de la classe [RdvMedecinsContext] a \u00e9t\u00e9 cr\u00e9\u00e9e et qu'elle contient une table [dbo.MEDECINS] (c'est le nom qu'on lui avait donn\u00e9) avec des colonnes qui reprennent les noms des champs de l'entit\u00e9 [Medecin]. Si le code s'est bien ex\u00e9cut\u00e9 et que la base ci-dessus n'appara\u00eet pas, il faut regarder le serveur embarqu\u00e9 (localdb)\\v11.0 (cf. page 18). Avec VS 2012 pro, ce serveur est utilis\u00e9 si SQL server n'est pas actif au moment de l'ex\u00e9cution du code. Avec VS 2012 Express, non.</p> <p>Examinons la structure de la table [MEDECINS]\u00a0:</p> <ul> <li>elle reprend les noms des champs de l'entit\u00e9 [Medecin]\u00a0;</li> <li>la colonne [Id] est cl\u00e9 primaire. C'est une convention d'EF\u00a0: si l'entit\u00e9 E a un champ Id ou Eid (MedecinId), alors cette colonne est cl\u00e9 primaire dans la table associ\u00e9e\u00a0;</li> <li>les types des colonnes de la table sont ceux des champs de l'entit\u00e9\u00a0;</li> <li>pour les colonnes Titre, Nom, Prenom, un type [nvarchar(max)] a \u00e9t\u00e9 utilis\u00e9. On pourrait \u00eatre plus pr\u00e9cis, 5 caract\u00e8res pour le titre, 30 pour les nom et pr\u00e9nom\u00a0;</li> <li>les colonnes Titre, Nom, Prenom peuvent avoir la valeur NULL. Nous allons changer cela.</li> </ul> <p>Regardons les propri\u00e9t\u00e9s de la cl\u00e9 primaire [Id]\u00a0:</p> <p>En [1], on voit que la cl\u00e9 primaire est de type [Identit\u00e9], ce qui signifie que sa valeur est automatiquement g\u00e9n\u00e9r\u00e9e par SQL Server. Nous adopterons cette strat\u00e9gie avec tous les SGBD.</p> <p>Nous allons laisser moins de part aux conventions d'EF en utilisant des annotations. Le code de l'entit\u00e9 dans [Entites.cs] devient le suivant\u00a0:</p> <pre><code>using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace RdvMedecins.Entites\n{\n  [Table(\"MEDECINS\", Schema = \"dbo\")]\n  public class Medecin\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int Id { get; set; }\n    [Required]\n    [MaxLength(5)]\n    [Column(\"TITRE\")]\n    public string Titre { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"NOM\")]\n    public string Nom { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"PRENOM\")]\n    public string Prenom { get; set; }\n    [Required]\n    [Column(\"VERSION\")]\n    public int Version { get; set; }\n  }\n}\n</code></pre> <ul> <li>lignes 2 et 3\u00a0: les annotations sont trouv\u00e9es dans les espaces de noms [System.ComponentModel.DataAnnotations] (Key, Required, MaxLength] et [System.ComponentModel.DataAnnotations.Schema] (Column). On trouvera d'autres annotations \u00e0 l'URL [http://msdn.microsoft.com/en-us/data/gg193958.aspx];</li> <li>ligne 11\u00a0: [Key] d\u00e9signe la cl\u00e9 primaire\u00a0;</li> <li>ligne 12\u00a0: [Column] fixe le nom de la colonne correspondant au champ\u00a0;</li> <li>ligne 14\u00a0: [Required] indique que le champ est obligatoire (SQL NOT NULL)\u00a0;</li> <li>ligne 15\u00a0: [MaxLength] fixe la taille maxi de la cha\u00eene de caract\u00e8res, [MinLength] sa taille mini\u00a0;</li> </ul> <p>Ex\u00e9cutons le projet avec cette nouvelle d\u00e9finition de l'entit\u00e9 [Medecin]. La base cr\u00e9\u00e9e est alors la suivante\u00a0:</p> <ul> <li>les colonnes ont le nom qu'on leur a fix\u00e9\u00a0;</li> <li>l'annotation [Required] a \u00e9t\u00e9 traduite par un SQL NOT NULL\u00a0;</li> <li>l'annotation [MaxLength(N)] a \u00e9t\u00e9 traduite par un type SQL nvarchar(N).</li> </ul> <p>Dans l'application NHibernate, la colonne [VERSION] \u00e9tait l\u00e0 pour pr\u00e9venir les acc\u00e8s concurrents \u00e0 une m\u00eame ligne d'une table. Le principe est le suivant\u00a0:</p> <ul> <li>un processus P1 lit une ligne L de la table [MEDECINS] au temps T1. La ligne a la version V1\u00a0;</li> <li>un processus P2 lit la m\u00eame ligne L de la table [MEDECINS] au temps T2. La ligne a la version V1 parce que le processus P1 n'a pas encore valid\u00e9 sa modification\u00a0;</li> <li>le processus P1 valide sa modification de la ligne L. La version de la ligne L passe alors \u00e0 V2=V1+1\u00a0;</li> <li>le processus P2 valide sa modification de la ligne L. L'ORM lance alors une exception car le processus P2 a une version V1 de la ligne L diff\u00e9rente de la version V2 trouv\u00e9e en base.</li> </ul> <p>On appelle cela la gestion optimiste des acc\u00e8s concurrents. Avec EF 5, un champ jouant ce r\u00f4le doit avoir l'un des deux attributs [Timestamp] ou [ConcurrencyCheck]. SQL Server a un type [timestamp]. Une colonne ayant ce type voit sa valeur automatiquement g\u00e9n\u00e9r\u00e9e par SQL Server \u00e0 toute insertion / modification d'une ligne. Une telle colonne peut alors servir \u00e0 g\u00e9rer la concurrence d'acc\u00e8s. Pour reprendre l'exemple pr\u00e9c\u00e9dent, le processus P2 trouvera un timestamp diff\u00e9rent de celui qu'il a lu, car entre-temps la modification faite par le processus P1 l'aura modifi\u00e9.</p> <p>Notre entit\u00e9 [Medecin] \u00e9volue comme suit\u00a0:</p> <pre><code>using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace RdvMedecins.Entites\n{\n[Table(\"MEDECINS\", Schema = \"dbo\")]\npublic class Medecin\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int Id { get; set; }\n    [Required]\n    [MaxLength(5)]\n    [Column(\"TITRE\")]\n    public string Titre { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"NOM\")]\n    public string Nom { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"PRENOM\")]\n    public string Prenom { get; set; }\n    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n  }\n}\n</code></pre> <ul> <li>lignes 26-28\u00a0: la nouvelle colonne avec l'attribut [Timestamp] de la ligne 27. Le type du champ doit \u00eatre byte[] (ligne 28). Le nom du champ peut \u00eatre quelconque. On ne lui met pas l'attribut [Required] car ce n'est pas l'application qui fournira cette valeur mais le SGBD lui-m\u00eame.</li> </ul> <p>Si on ex\u00e9cute le projet avec cette nouvelle entit\u00e9, la base \u00e9volue comme suit\u00a0:</p> <p>Il nous reste \u00e0 r\u00e9gler un dernier point. Le contexte de persistance \"\u00a0sait\u00a0\" qu'une entit\u00e9 doit faire l'objet d'une insertion en base parce qu'alors elle a sa cl\u00e9 primaire \u00e9gale \u00e0 null. C'est l'insertion en base qui va donner une valeur \u00e0 la cl\u00e9 primaire. Ici, le type int donn\u00e9 \u00e0 la cl\u00e9 primaire [Id] ne convient pas parce que ce type n'accepte pas la valeur null. On lui donne alors le type int? qui accepte les valeurs int plus le pointeur null. L'entit\u00e9 [Medecin] utilis\u00e9e sera donc la suivante\u00a0:</p> <pre><code>public class Medecin\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int? Id { get; set; }\n    ...\n</code></pre> <p>Il nous reste \u00e0 voir comment repr\u00e9senter dans une entit\u00e9 le concept de cl\u00e9 \u00e9trang\u00e8re entre tables.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#342-lentite-creneau","title":"3.4.2. L'entit\u00e9 [Creneau]","text":"<p>La table [CRENEAUX] liste les cr\u00e9neaux horaires o\u00f9 les RV sont possibles : </p> <ul> <li>ID : n\u00b0 identifiant le cr\u00e9neau horaire - cl\u00e9 primaire de la table</li> <li>VERSION : n\u00b0 identifiant la version de la ligne dans la table. Ce nombre est incr\u00e9ment\u00e9 de 1 \u00e0 chaque fois qu'une modification est apport\u00e9e \u00e0 la ligne.</li> <li>ID_MEDECIN : n\u00b0 identifiant le m\u00e9decin auquel appartient ce cr\u00e9neau \u2013 cl\u00e9 \u00e9trang\u00e8re sur la colonne MEDECINS(ID).</li> <li>HDEBUT : heure d\u00e9but cr\u00e9neau</li> <li>MDEBUT : minutes d\u00e9but cr\u00e9neau</li> <li>HFIN : heure fin cr\u00e9neau</li> <li>MFIN : minutes fin cr\u00e9neau</li> </ul> <p>La seconde ligne de la table [CRENEAUX] (cf [1] ci-dessus) indique, par exemple, que le cr\u00e9neau n\u00b0 2 commence \u00e0 8 h 20 et se termine \u00e0 8 h 40 et appartient au m\u00e9decin n\u00b0 1 (Mme Marie PELISSIER).</p> <p>Avec ce que nous savons, nous pouvons d\u00e9finir l'entit\u00e9 [Creneau] comme suit dans [Entites.cs]\u00a0:</p> <pre><code>[Table(\"CRENEAUX\", Schema = \"dbo\")]\n  public class Creneau\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int? Id { get; set; }\n    [Required]\n    [Column(\"HDEBUT\")]\n    public int Hdebut { get; set; }\n    [Required]\n    [Column(\"MDEBUT\")]\n    public int Mdebut { get; set; }\n    [Required]\n    [Column(\"HFIN\")]\n    public int Hfin { get; set; }\n    [Required]\n    [Column(\"MFIN\")]\n    public int Mfin { get; set; }\n    [Required]\n    public virtual Medecin Medecin { get; set; }\n    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n}\n</code></pre> <p>La seule nouveaut\u00e9 r\u00e9side aux lignes 20-21. Le fait que la table [CRENEAUX] ait une cl\u00e9 \u00e9trang\u00e8re sur la table [MEDECINS] est refl\u00e9t\u00e9 dans l'entit\u00e9 [Creneau] par la pr\u00e9sence d'une r\u00e9f\u00e9rence sur l'entit\u00e9 [Medecin], ligne 21. Le nom du champ importe peu, seul le type est important. La propri\u00e9t\u00e9 doit \u00eatre d\u00e9clar\u00e9e virtuelle avec le mot cl\u00e9 virtual. En effet, EF est amen\u00e9 \u00e0 red\u00e9finir toutes les propri\u00e9t\u00e9s dites navigationnelles, c'-a-d celles qui correspondent \u00e0 une cl\u00e9 \u00e9trang\u00e8re et qui permettent de passer d'une table \u00e0 l'autre.</p> <p>Pour tester la nouvelle entit\u00e9, il nous faut faire quelques modifications dans [Context.cs]\u00a0:</p> <pre><code>using System.Data.Entity;\nusing RdvMedecins.Entites;\n\nnamespace RdvMedecins.Models\n{\n\n  // le contexte\n  public class RdvMedecinsContext : DbContext\n  {\n    // les entit\u00e9s\n    public DbSet&lt;Medecin&gt; Medecins { get; set; }\n    public DbSet&lt;Creneau&gt; Creneaux { get; set; }\n  }\n\n  // initialisation de la base\n  public class RdvMedecinsInitializer :  DropCreateDatabaseIfModelChanges&lt;RdvMedecinsContext&gt;\n  {\n  }\n}\n</code></pre> <p>La ligne 12 refl\u00e8te le fait que le contexte a une entit\u00e9 de plus \u00e0 g\u00e9rer. Lorsque nous ex\u00e9cutons le projet, nous obtenons la nouvelle base suivante\u00a0:</p> <p>La table [CRENEAUX] a bien \u00e9t\u00e9 cr\u00e9\u00e9e et la nouveaut\u00e9 est la pr\u00e9sence d'une cl\u00e9 \u00e9trang\u00e8re [1] et [2]. Son nom a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9 \u00e0 partir du nom du champ correspondant dans l'entit\u00e9 (Medecin) suffix\u00e9 par \"\u00a0_Id\u00a0\". Pour conna\u00eetre les propri\u00e9t\u00e9s de cette cl\u00e9 \u00e9trang\u00e8re, on essaie de la modifier [3].</p> <p>La copie d'\u00e9cran ci-dessus montre que [Medecin_Id] est cl\u00e9 \u00e9trang\u00e8re de la table [CRENEAUX] et qu'elle r\u00e9f\u00e9rence la cl\u00e9 primaire [ID] de la table [MEDECINS].</p> <p>Si on cr\u00e9e les entit\u00e9s pour une base existante, la colonne cl\u00e9 \u00e9trang\u00e8re ne s'appellera pas forc\u00e9ment [Medecin_Id]. Pour les autres colonnes, on avait vu que l'annotation [Column] r\u00e9glait ce probl\u00e8me. Bizarrement c'est plus compliqu\u00e9 pour une cl\u00e9 \u00e9trang\u00e8re. Il faut proc\u00e9der de la fa\u00e7on suivante\u00a0:</p> <pre><code>public class Creneau\n  {\n    // data\n    ...\n    [Required]\n    [Column(\"MEDECIN_ID\")]\n    public int MedecinId { get; set; }\n    [Required]\n    [ForeignKey(\"MedecinId\")]\n    public virtual Medecin Medecin { get; set; }\n    ...\n}\n</code></pre> <ul> <li>lignes 5-7\u00a0: on cr\u00e9e un champ du type de la cl\u00e9 \u00e9trang\u00e8re (int). A l'aide de l'attribut [Column], on pr\u00e9cise le nom de la colonne qui sera cl\u00e9 \u00e9trang\u00e8re dans la table associ\u00e9e \u00e0 l'entit\u00e9\u00a0;</li> <li>ligne 9\u00a0: on ajoute l'annotation [ForeignKey] au champ de type [Medecin]. L'argument de cette annotation est le nom du champ (pas de la colonne) qui est associ\u00e9 \u00e0 la colonne cl\u00e9 \u00e9trang\u00e8re de la table.</li> </ul> <p>L'ex\u00e9cution du projet cr\u00e9e cette fois-ci la table suivante\u00a0:</p> <p>Ci-dessus, la colonne cl\u00e9 \u00e9trang\u00e8re porte bien le nom qu'on lui a donn\u00e9. Il faut noter que les champs\u00a0:</p> <pre><code>    [Required]\n    [Column(\"MEDECIN_ID\")]\n    public int MedecinId { get; set; }\n    [Required]\n    [ForeignKey(\"MedecinId\")]\npublic virtual Medecin Medecin { get; set; }\n</code></pre> <p>n'ont donn\u00e9 naissance qu'\u00e0 une seule colonne, la colonne [MEDECIN_ID]. N\u00e9anmoins, la pr\u00e9sence du champ [MedecinId] est importante. Lors de la lecture d'une ligne de la table [CRENEAUX], elle recevra la valeur de la colonne [MEDECIN_ID], c'-\u00e0-d. la valeur de la cl\u00e9 \u00e9trang\u00e8re sur la table [MEDECINS]. Cela est souvent utile.</p> <p>Le champ [Medecin] ci-dessus refl\u00e8te la relation plusieurs \u00e0 un qui lie l'entit\u00e9 [Creneau] \u00e0 l'entit\u00e9 [Medecin]. Plusieurs objets [Creneau] sont reli\u00e9s \u00e0 un m\u00eame [Medecin]. La relation inverse, un objet [Medecin] est associ\u00e9 \u00e0 plusieurs objets [Creneau] peut \u00eatre mod\u00e9lis\u00e9e par un champ suppl\u00e9mentaire dans l'entit\u00e9 [Medecin]\u00a0:</p> <pre><code>public class Medecin\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int? Id { get; set; }\n    ...\n    public ICollection&lt;Creneau&gt; Creneaux { get; set; }\n    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n</code></pre> <p>Ligne 8, on a rajout\u00e9 le champ [Creneaux] qui est une collection d'objets [Creneau]. Ce champ nous donnera acc\u00e8s \u00e0 tous les cr\u00e9neaux horaires du m\u00e9decin.</p> <p>Lorsqu'on ex\u00e9cute de nouveau le projet, on constate que la table [MEDECINS] n'a pas boug\u00e9\u00a0:</p> <p>Aucune colonne n'a \u00e9t\u00e9 rajout\u00e9e. La relation de cl\u00e9 \u00e9trang\u00e8re qui existe entre la table [CRENEAUX] et la table [MEDECINS] est suffisante pour que EF sache g\u00e9n\u00e9rer les champs li\u00e9s \u00e0 celle-ci\u00a0:</p> <pre><code>  public class Medecin\n  {\n    ...\n    public ICollection&lt;Creneau&gt; Creneaux { get; set; }\n    ...\n  }\n</code></pre> <pre><code>  public class Creneau\n  {\n    ...\n    [Required]\n    [Column(\"MEDECIN_ID\")]\n    public int MedecinId { get; set; }\n    [Required]\n    [ForeignKey(\"MedecinId\")]\n    public virtual Medecin Medecin { get; set; }\n    ...\n  }\n</code></pre> <p>Nous savons l'essentiel. Nous pouvons terminer avec la cr\u00e9ation des deux autres entit\u00e9s.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#343-les-entites-client-et-rv","title":"3.4.3. Les entit\u00e9s [Client] et [Rv]","text":"<p>Avec ce que nous avons appris, nous pouvons \u00e9crire les entit\u00e9s [Client] et [Rv]. L'entit\u00e9 [Client] contient des informations sur les clients g\u00e9r\u00e9s par l'application [RdvMedecins].</p> <ul> <li>ID : n\u00b0 identifiant le client - cl\u00e9 primaire de la table</li> <li>VERSION : n\u00b0 identifiant la version de la ligne dans la table. Ce nombre est incr\u00e9ment\u00e9 de 1 \u00e0 chaque fois qu'une modification est apport\u00e9e \u00e0 la ligne.</li> <li>NOM : le nom du client</li> <li>PRENOM : son pr\u00e9nom</li> <li>TITRE : son titre (Melle, Mme, Mr)</li> </ul> <p>L'entit\u00e9 [Client] pourrait \u00eatre la suivante\u00a0:</p> <pre><code>  [Table(\"CLIENTS\", Schema = \"dbo\")]\n  public class Client\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int? Id { get; set; }\n    [Required]\n    [MaxLength(5)]\n    [Column(\"TITRE\")]\n    public string Titre { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"NOM\")]\n    public string Nom { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"PRENOM\")]\n    public string Prenom { get; set; }\n    // les Rvs du client\n    public ICollection&lt;Rv&gt; Rvs { get; set; }\n    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n}\n</code></pre> <p>La classe [Client] est quasi identique \u00e0 la classe [Medecin]. On pourrait les faire d\u00e9river d'une m\u00eame classe parent. La nouveaut\u00e9 est ligne 21. Elle refl\u00e8te le fait qu'un client peut avoir plusieurs rendez-vous et d\u00e9rive de la pr\u00e9sence d'une cl\u00e9 \u00e9trang\u00e8re de la table [RVS] vers la table [CLIENTS].</p> <p>L'entit\u00e9 [Rv] repr\u00e9sente un rendez-vous :</p> <ul> <li>ID : n\u00b0 identifiant le RV de fa\u00e7on unique \u2013 cl\u00e9 primaire</li> <li>JOUR : jour du RV</li> <li>ID_CRENEAU : cr\u00e9neau horaire du RV - cl\u00e9 \u00e9trang\u00e8re sur la colonne [ID] de la table [CRENEAUX] \u2013 fixe \u00e0 la fois le cr\u00e9neau horaire et le m\u00e9decin concern\u00e9.</li> <li>ID_CLIENT : n\u00b0 du client pour qui est faite la r\u00e9servation \u2013 cl\u00e9 \u00e9trang\u00e8re sur la colonne [ID] de la table [CLIENTS]</li> </ul> <p>L'entit\u00e9 [Rv] pourrait \u00eatre la suivante\u00a0:</p> <pre><code>[Table(\"MEDECINS\", Schema = \"dbo\")]\n  public class Rv\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int? Id { get; set; }\n    [Required]\n    [Column(\"JOUR\")]\n    public DateTime Jour { get; set; }\n    [Column(\"CLIENT_ID\")]\n    public int ClientId { get; set; }\n    [ForeignKey(\"ClientId\")]\n    [Required]\n    public virtual Client Client { get; set; }\n    [Column(\"CRENEAU_ID\")]\n    public int CreneauId { get; set; }\n    [ForeignKey(\"CreneauId\")]\n    [Required]\n    public virtual Creneau Creneau { get; set; }\n    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n}\n</code></pre> <ul> <li>lignes 5-7\u00a0: cl\u00e9 primaire\u00a0;</li> <li>lignes 8-10\u00a0: date du rendez-vous\u00a0;</li> <li>lignes 11-12\u00a0: la cl\u00e9 \u00e9trang\u00e8re de la table [RVS] vers la table [CLIENTS]\u00a0;</li> <li>lignes 13-15\u00a0: le client qui a rendez-vous\u00a0;</li> <li>lignes 16-17\u00a0: la cl\u00e9 \u00e9trang\u00e8re de la table [RVS] vers la table [CRENEAUX]\u00a0;</li> <li>lignes 18-20\u00a0: le cr\u00e9neau horaire du rendez-vous\u00a0;</li> <li>lignes 21-23\u00a0: le champ de gestion des acc\u00e8s concurrents.</li> </ul> <p>Ligne 17, on voit une relation plusieurs \u00e0 un\u00a0: \u00e0 un cr\u00e9neau horaire peuvent correspondre plusieurs rendez-vous (pas le m\u00eame jour). La relation inverse peut \u00eatre refl\u00e9t\u00e9e dans l'entit\u00e9 [Creneau]\u00a0:</p> <pre><code>public class Creneau\n  {\n    // les Rvs du cr\u00e9neau\n    public ICollection&lt;Rv&gt; Rvs { get; set; }\n    ...\n}\n</code></pre> <p>Ligne 4, la collection des rendez-vous pris sur ce cr\u00e9neau horaire.</p> <p>Lorsqu'on ex\u00e9cute le projet, la base g\u00e9n\u00e9r\u00e9e est la suivante\u00a0:</p> <p>Les tables [MEDECINS] et [CRENEAUX] n'ont pas chang\u00e9. Les tables [CLIENTS] et [RVS] sont les suivantes\u00a0:</p> <p>C'est ce qui \u00e9tait attendu. Il nous reste quelques d\u00e9tails \u00e0 r\u00e9gler\u00a0:</p> <ul> <li>g\u00e9rer le nom de la base. Ici il a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9 par EF\u00a0;</li> <li>remplir la base avec des donn\u00e9es.</li> </ul>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#344-fixer-le-nom-de-la-base","title":"3.4.4. Fixer le nom de la base","text":"<p>Pour fixer le nom de la base g\u00e9n\u00e9r\u00e9e par EF, nous utiliserons une cha\u00eene de connexion d\u00e9finie dans [App.config]. Ce fichier de configuration \u00e9volue comme suit\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;configSections&gt;\n    &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt;\n    &lt;section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" /&gt;\n  &lt;/configSections&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;entityFramework&gt;\n    &lt;defaultConnectionFactory type=\"System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework\" /&gt;\n  &lt;/entityFramework&gt;\n\n  &lt;!-- cha\u00eene de connexion sur la base --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"RdvMedecinsContext\"\n         connectionString=\"Data Source=localhost;Initial Catalog=rdvmedecins-ef;User Id=sa;Password=sqlserver2012;\"\n         providerName=\"System.Data.SqlClient\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"SqlClient Data Provider\"\n       invariant=\"System.Data.SqlClient\"\n       description=\".Net Framework Data Provider for SqlServer\"\n       type=\"System.Data.SqlClient.SqlClientFactory, System.Data,\n     Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\"\n    /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n\n&lt;/configuration&gt;\n</code></pre> <ul> <li>lignes 15-19\u00a0: la cha\u00eene de connexion \u00e0 la base\u00a0;</li> <li>ligne 16\u00a0: l'attribut [name] reprend le nom de la classe [RdvMedecinsContext] utilis\u00e9 pour le contexte de persistance. Il est important de s'en souvenir. Cette contrainte peut \u00eatre contourn\u00e9e dans le constructeur du contexte\u00a0:</li> </ul> <pre><code>    // constructeur\n    public RdvMedecinsContext()\n      : base(\"monContexte\")\n    {\n    }\n</code></pre> <p>Dans ce cas, on pourra avoir name=\u00a0\"monContexte\u00a0\". C'est ce que nous aurons dans la suite du document.</p> <ul> <li>ligne 17\u00a0: la cha\u00eene de connexion. [Data Source]\u00a0: le nom du serveur sur lequel se trouve le SGBD, [Initial Catalog]\u00a0: le nom de la base de donn\u00e9es, donc ici [rdvmedecins-ef], [User Id]\u00a0: le propri\u00e9taire de la connexion, [Password]\u00a0: son mot de passe. Le lecteur adaptera cette cha\u00eene \u00e0 son environnement\u00a0;</li> <li>lignes 21-29\u00a0: d\u00e9finissent un [DbProviderFactory]. Je ne sais pas ce que c'est. Si j'en crois le nom, ce pourrait \u00eatre une classe permettant de g\u00e9n\u00e9rer la couche [ADO.NET] qui s\u00e9pare EF du SGBD\u00a0:</li> </ul> <p>En fait, ces lignes sont inutiles pour SQL Server mais j'ai du les ajouter pour les autres SGBD. Aussi c'est pour m\u00e9moire que je les mets l\u00e0. Elles ne g\u00eanent pas. Le seul point important est la version de la ligne 27. C'est celle de la DLL [System.Data] pr\u00e9sente dans les r\u00e9f\u00e9rences du projet\u00a0:</p> <p>Voil\u00e0. Nous sommes pr\u00eats. Nous ex\u00e9cutons le projet et nous obtenons la base [rdvmedecins-ef] suivante\u00a0:</p> <p>Ce sera notre base d\u00e9finitive. Il nous reste \u00e0 mettre des donn\u00e9es dedans.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#345-remplissage-de-la-base","title":"3.4.5. Remplissage de la base","text":"<p>La classe d'initialisation de la base peut \u00eatre utilis\u00e9e pour y ins\u00e9rer des donn\u00e9es\u00a0:</p> <pre><code>public class RdvMedecinsInitializer : DropCreateDatabaseIfModelChanges&lt;RdvMedecinsContext&gt;\n  {\n    // initialisation de la base\n    public class RdvMedecinsInitializer : DropCreateDatabaseAlways&lt;RdvMedecinsContext&gt;\n    {\n      protected override void Seed(RdvMedecinsContext context)\n      {\n        base.Seed(context);\n        // on initialise la base\n        // les clients\n        Client[] clients ={\n        new Client { Titre = \"Mr\", Nom = \"Martin\", Prenom = \"Jules\" },\n        new Client { Titre = \"Mme\", Nom = \"German\", Prenom = \"Christine\" },\n        new Client { Titre = \"Mr\", Nom = \"Jacquard\", Prenom = \"Jules\" },\n        new Client { Titre = \"Melle\", Nom = \"Bistrou\", Prenom = \"Brigitte\" }\n     };\n        foreach (Client client in clients)\n        {\n          context.Clients.Add(client);\n        }\n        // les m\u00e9decins\n        Medecin[] medecins ={\n        new Medecin { Titre = \"Mme\", Nom = \"Pelissier\", Prenom = \"Marie\" },\n        new Medecin { Titre = \"Mr\", Nom = \"Bromard\", Prenom = \"Jacques\" },\n        new Medecin { Titre = \"Mr\", Nom = \"Jandot\", Prenom = \"Philippe\" },\n        new Medecin { Titre = \"Melle\", Nom = \"Jacquemot\", Prenom = \"Justine\" }\n     };\n        foreach (Medecin medecin in medecins)\n        {\n          context.Medecins.Add(medecin);\n        }\n        // les cr\u00e9neaux horaires\n        Creneau[] creneaux ={\n        new Creneau{ Hdebut=8,Mdebut=0,Hfin=8,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=8,Mdebut=20,Hfin=8,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=8,Mdebut=40,Hfin=9,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=9,Mdebut=0,Hfin=9,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=9,Mdebut=20,Hfin=9,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=9,Mdebut=40,Hfin=10,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=10,Mdebut=0,Hfin=10,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=10,Mdebut=20,Hfin=10,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=10,Mdebut=40,Hfin=11,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=11,Mdebut=0,Hfin=11,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=11,Mdebut=20,Hfin=11,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=11,Mdebut=40,Hfin=12,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=14,Mdebut=0,Hfin=14,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=14,Mdebut=20,Hfin=14,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=14,Mdebut=40,Hfin=15,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=15,Mdebut=0,Hfin=15,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=15,Mdebut=20,Hfin=15,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=15,Mdebut=40,Hfin=16,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=16,Mdebut=0,Hfin=16,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=16,Mdebut=20,Hfin=16,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=16,Mdebut=40,Hfin=17,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=17,Mdebut=0,Hfin=17,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=17,Mdebut=20,Hfin=17,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=17,Mdebut=40,Hfin=18,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=8,Mdebut=0,Hfin=8,Mfin=20,Medecin=medecins[1]},\n        new Creneau{ Hdebut=8,Mdebut=20,Hfin=8,Mfin=40,Medecin=medecins[1]},\n        new Creneau{ Hdebut=8,Mdebut=40,Hfin=9,Mfin=0,Medecin=medecins[1]},\n        new Creneau{ Hdebut=9,Mdebut=0,Hfin=9,Mfin=20,Medecin=medecins[1]},\n        new Creneau{ Hdebut=9,Mdebut=20,Hfin=9,Mfin=40,Medecin=medecins[1]},\n        new Creneau{ Hdebut=9,Mdebut=40,Hfin=10,Mfin=0,Medecin=medecins[1]},\n        new Creneau{ Hdebut=10,Mdebut=0,Hfin=10,Mfin=20,Medecin=medecins[1]},\n        new Creneau{ Hdebut=10,Mdebut=20,Hfin=10,Mfin=40,Medecin=medecins[1]},\n        new Creneau{ Hdebut=10,Mdebut=40,Hfin=11,Mfin=0,Medecin=medecins[1]},\n        new Creneau{ Hdebut=11,Mdebut=0,Hfin=11,Mfin=20,Medecin=medecins[1]},\n        new Creneau{ Hdebut=11,Mdebut=20,Hfin=11,Mfin=40,Medecin=medecins[1]},\n        new Creneau{ Hdebut=11,Mdebut=40,Hfin=12,Mfin=0,Medecin=medecins[1]},\n      };\n        foreach (Creneau creneau in creneaux)\n        {\n          context.Creneaux.Add(creneau);\n        }\n        // les Rdv\n        context.Rvs.Add(new Rv { Jour = new System.DateTime(2012, 10, 8), Client = clients[0], Creneau = creneaux[0] });\n      }\n\n    }\n  }\n</code></pre> <ul> <li>ligne 6\u00a0: l'initialisation se passe dans la m\u00e9thode [Seed]. Celle-ci existe dans la classe m\u00e8re. Elle est ici red\u00e9finie. L'argument est le contexte de persistance [RdvMedecinsContext] de l'application\u00a0;</li> <li>ligne 8\u00a0: l'argument est pass\u00e9 \u00e0 la classe m\u00e8re\u00a0; il est probable que celle-ci ouvre le contexte de persistance qu'on lui a pass\u00e9 car cette ouverture n'est plus n\u00e9cessaire par la suite\u00a0;</li> <li>lignes 11-16\u00a0: cr\u00e9ation de 4 clients\u00a0;</li> <li>lignes 17-20\u00a0: ceux-ci sont ajout\u00e9s au contexte de persistance, plus exactement aux m\u00e9decins de celui-ci. On notera la m\u00e9thode [Add] qui permet cela. Il faut se rappeler ici la d\u00e9finition du contexte\u00a0:</li> </ul> <pre><code>  public class RdvMedecinsContext : DbContext\n  {\n    // les entit\u00e9s\n    public DbSet&lt;Medecin&gt; Medecins { get; set; }\n    public DbSet&lt;Creneau&gt; Creneaux { get; set; }\n    public DbSet&lt;Client&gt; Clients { get; set; }\npublic DbSet&lt;Rv&gt; Rvs { get; set; }\n...\n</code></pre> <p>On dit aussi que les clients ont \u00e9t\u00e9 attach\u00e9s au contexte, c'-\u00e0-d. qu'ils sont d\u00e9sormais g\u00e9r\u00e9s par EF. Avant ils en \u00e9taient d\u00e9tach\u00e9s. Ils existaient en tant qu'objets mais n'\u00e9taient pas g\u00e9r\u00e9s par EF\u00a0;</p> <ul> <li>lignes 21-27\u00a0: cr\u00e9ation de 4 m\u00e9decins\u00a0;</li> <li>lignes 28-31\u00a0: on les met dans le contexte de persistance\u00a0;</li> <li>lignes 33-70\u00a0: cr\u00e9ation de cr\u00e9neaux horaires. Lignes 34-57, pour le m\u00e9decin medecins[0], lignes 58-69,  pour le m\u00e9decin medecins[1]. Les autres m\u00e9decins sont sans cr\u00e9neaux horaires\u00a0;</li> <li>lignes 71-74\u00a0: on met ces cr\u00e9neaux dans le contexte de persistance\u00a0;</li> <li>ligne 76\u00a0: cr\u00e9ation d'un rendez-vous pour le 1er client avec le 1er cr\u00e9neau horaire et sa mise dans le contexte de persistance.</li> </ul> <p>Lorsqu'on ex\u00e9cute le projet, on obtient la base suivante\u00a0:</p> <p>Ci-dessus, on voit la table [CLIENTS] remplie.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#346-modification-des-entites","title":"3.4.6. Modification des entit\u00e9s","text":"<p>Actuellement, les classes [Medecin] et [Client] sont quasi identiques. En fait si on enl\u00e8ve les champs ajout\u00e9s pour la gestion de la persistance avec EF 5, elles sont identiques. Nous allons les faire d\u00e9river d'une classe [Personne]. Ces deux entit\u00e9s deviennent alors les suivantes\u00a0:</p> <pre><code>// une personne\n  public abstract class Personne\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int? Id { get; set; }\n    [Required]\n    [MaxLength(5)]\n    [Column(\"TITRE\")]\n    public string Titre { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"NOM\")]\n    public string Nom { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"PRENOM\")]\n    public string Prenom { get; set; }\n    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n\n    // signature\n    public override string ToString()\n    {\n      return String.Format(\"[{0},{1},{2},{3},{4}]\", Id, Titre, Prenom, Nom, dump(Timestamp));\n    }\n    // signature courte\n    public string ShortIdentity()\n    {\n      ...\n    }\n\n    // utilitaire\n    private string dump(byte[] timestamp)\n    {\n      ...\n    }\n\n  }\n\n  [Table(\"MEDECINS\", Schema = \"dbo\")]\n  public class Medecin : Personne\n  {\n    // les cr\u00e9neaux horaires du m\u00e9decin\n    public ICollection&lt;Creneau&gt; Creneaux { get; set; }\n    // signature\n    public override string ToString()\n    {\n      return String.Format(\"Medecin {0}\", base.ToString());\n    }\n  }\n\n[Table(\"CLIENTS\", Schema = \"dbo\")]\n    public class Client : Personne\n  {\n    // les Rvs du client\n    public ICollection&lt;Rv&gt; Rvs { get; set; }\n    // signature\n    public override string ToString()\n    {\n      return String.Format(\"Client {0}\", base.ToString());\n    }\n  }\n</code></pre> <p>Lorsqu'on ex\u00e9cute le projet, on obtient la m\u00eame base. EF 5 a mapp\u00e9 les classes les plus basses de l'h\u00e9ritage chacune dans une table. En fait, EF 5 a diff\u00e9rentes strat\u00e9gies de g\u00e9n\u00e9ration de tables pour repr\u00e9senter l'h\u00e9ritage d'entit\u00e9s. Nous ne les pr\u00e9senterons pas ici. On pourra lire par exemple \"\u00a0Entity Framework Code First Inheritance : Table Per Hierarchy and Table Per Type\u00a0\", \u00e0 l'URL [http://www.codeproject.com/Articles/393228/Entity-Framework-Code-First-Inheritance-Table-Per].</p> <p>Nous utiliserons d\u00e9sormais cette version des entit\u00e9s.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#347-ajouter-des-contraintes-a-la-base","title":"3.4.7. Ajouter des contraintes \u00e0 la base","text":"<p>Il nous reste un d\u00e9tail \u00e0 r\u00e9gler. La table [RVS] des rendez-vous est la suivante\u00a0:</p> <p>Cette table doit avoir une contrainte d'unicit\u00e9\u00a0: pour un jour donn\u00e9, un cr\u00e9neau horaire d'un m\u00e9decin ne peut \u00eatre r\u00e9serv\u00e9 qu'une fois pour un rendez-vous. En termes de table, cela signifie que le couple (JOUR,CRENEAU_ID) doit \u00eatre unique. Je ne sais pas si cette contrainte peut \u00eatre exprim\u00e9e directement dans le code, soit sur les entit\u00e9s soit sur le contexte. C'est probable mais je n'ai pas v\u00e9rifi\u00e9. Nous allons prendre une autre d\u00e9marche. Nous allons utiliser un client d'administration de SQL Server pour ajouter cette contrainte.</p> <p>Avec \"\u00a0SQL Server Management Studio\u00a0\", je n'ai pas trouv\u00e9 de m\u00e9thode simple pour ajouter cette contrainte hormis ex\u00e9cuter l'ordre SQL qui la cr\u00e9e\u00a0:</p> <ul> <li>en [1] on cr\u00e9e une requ\u00eate SQL pour la base [rdvmedecins-ef]\u00a0;</li> <li>en [2], la requ\u00eate SQL qui cr\u00e9e la contrainte d'unicit\u00e9\u00a0;</li> <li>en [3], l'ex\u00e9cution de cette requ\u00eate a cr\u00e9\u00e9 un nouvel index dans la table [RVS].</li> </ul> <p>Il existe d'autres outils d'administration de SQL Server. Nous allons utiliser ici l'outil EMS SQL Manager for SQL Server Freeware [http://www.sqlmanager.net/fr/products/mssql/manager/download]. Une fois install\u00e9, nous le lan\u00e7ons\u00a0:</p> <ul> <li>en [1], on enregistre une base de donn\u00e9es\u00a0;</li> <li>en [2], on se connecte au serveur (local)\u00a0;</li> <li>en [3], avec une authentification SQL Server\u00a0;</li> <li>en [4], sous l'identit\u00e9 sa\u00a0;</li> <li>en [5], et le mot de passe sqlserver2012\u00a0;</li> <li>en [6], on passe \u00e0 l'\u00e9tape suivante\u00a0;</li> </ul> <ul> <li>en [7], on choisit la base [rdvmedecins-ef]\u00a0;</li> <li>en [8], on termine l'assistant\u00a0;</li> <li>en [9], la base appara\u00eet dans l'arborescence des bases. On s'y connecte [10]\u00a0;</li> <li>en [11], on est connect\u00e9.</li> </ul> <p>\"\u00a0SQL Manager Lite for SQL Server\u00a0\" permet de cr\u00e9er la contrainte d'unicit\u00e9 sur la table [RVS].</p> <ul> <li>en [1], on voit la contrainte d'unicit\u00e9 que nous avons cr\u00e9\u00e9e pr\u00e9c\u00e9demment\u00a0;</li> <li>en [2], on la supprime\u00a0;</li> <li>en [3], l'indice correspondant \u00e0 cette contrainte d'unicit\u00e9 a disparu.</li> </ul> <p>On recr\u00e9e la contrainte supprim\u00e9e\u00a0:</p> <ul> <li>en [1], on cr\u00e9e un nouvel index pour la table [RVS]\u00a0;</li> <li>en [2], on lui donne un nom\u00a0;</li> <li>en [3], c'est une contrainte d'unicit\u00e9\u00a0;</li> <li>en [4], sur les colonnes JOUR et CRENEAU_ID\u00a0;</li> </ul> <p>L'onglet DDL nous donne le code SQL qui va \u00eatre ex\u00e9cut\u00e9\u00a0:</p> <ul> <li>en [6], on compile l'ordre SQL\u00a0;</li> </ul> <ul> <li>en [7], on confirme\u00a0;</li> <li>en [8], le nouvel indice est apparu.</li> </ul> <p>L'interface offerte par \"\u00a0SQL Manager Lite for SQL server\u00a0\" est analogue \u00e0 celle offerte par \"\u00a0SQL Server Management Studio\u00a0\". On peut trouver des interfaces analogues pour les SGBD Oracle, PostgreSQL, Firebird, MySQL. Aussi continueron-nous d\u00e9sormais avec cette famille d'outils d'administration de SGBD.</p> <p>Pour avoir acc\u00e8s aux informations d'une table, il suffit de double-cliquer dessus\u00a0:</p> <p>Les informations sur la table s\u00e9lectionn\u00e9e sont disponibles dans des onglets. Ci-dessus, on voit l'onglet [Fields] de la table [CLIENTS]. L'onglet [Data] affiche le contenu de la table\u00a0:</p> <p></p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#348-la-base-definitive","title":"3.4.8. La base d\u00e9finitive","text":"<p>Nous avons notre base d\u00e9finitive. Nous exportons son script SQL afin de pouvoir la r\u00e9g\u00e9n\u00e9rer si besoin est.</p> <ul> <li>en [1], d\u00e9but de l'assistant\u00a0;</li> <li>en [2], le serveur\u00a0;</li> <li>en [3], la base de donn\u00e9es qui va \u00eatre export\u00e9e\u00a0;</li> </ul> <ul> <li>en [4], pr\u00e9cisez le nom du fichier o\u00f9 sera enregistr\u00e9 le script SQL\u00a0;</li> <li>en [5], pr\u00e9cisez son encodage\u00a0;</li> <li>en [6], pr\u00e9cisez ce que vous voulez extraire (tables, contraintes, donn\u00e9es)\u00a0;</li> </ul> <ul> <li>en [7], vous pouvez affiner le script qui va \u00eatre g\u00e9n\u00e9r\u00e9\u00a0;</li> <li>en [8], terminez l'assistant.</li> </ul> <p>Le script a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9 et charg\u00e9 dans l'\u00e9diteur de script. Vous pouvez consulter le code SQL g\u00e9n\u00e9r\u00e9. Nous allons reconstruire la base de donn\u00e9es \u00e0 partir de ce script.</p> <ul> <li>en [1], on supprime la base\u00a0;</li> <li>en [2] et [3], on la recr\u00e9e\u00a0;</li> </ul> <ul> <li>en [4], on s'authentifie\u00a0;</li> <li>en [5], on ex\u00e9cute le script SQL de cr\u00e9ation de la base\u00a0;</li> </ul> <ul> <li>en [6], on l'enregistre dans \"\u00a0SQL Manager\u00a0\"\u00a0;</li> <li>en [7], on se connecte \u00e0 la base qui vient d'\u00eatre cr\u00e9\u00e9e\u00a0;</li> </ul> <ul> <li>en [8], la base n'a pour l'instant pas de tables\u00a0;</li> <li>en [9a], on ouvre un \u00e9diteur de script SQL\u00a0;</li> </ul> <ul> <li>en [9b], on ouvre le script SQL cr\u00e9\u00e9 pr\u00e9c\u00e9demment\u00a0;</li> <li>en [10], on l'ex\u00e9cute\u00a0;</li> </ul> <ul> <li>en [11], les tables ont \u00e9t\u00e9 cr\u00e9\u00e9es\u00a0;</li> <li>en [12], elles sont remplies\u00a0;</li> </ul> <ul> <li>en [14], nous retrouvons la contrainte d'unicit\u00e9 que nous avions cr\u00e9\u00e9e pour la table [RVS].</li> </ul> <p>Nous allons d\u00e9sormais travailler avec cette base existante. Si elle est d\u00e9truite ou d\u00e9t\u00e9rior\u00e9e, nous savons la r\u00e9g\u00e9n\u00e9rer.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#35-exploitation-de-la-base-avec-entity-framework","title":"3.5. Exploitation de la base avec Entity Framework","text":"<p>Nous allons :</p> <ul> <li>ajouter, supprimer, modifier des \u00e9l\u00e9ments de la base\u00a0;</li> <li>requ\u00eater la base avec LINQ to Entities\u00a0;</li> <li>g\u00e9rer les acc\u00e8s concurrents \u00e0 un m\u00eame \u00e9l\u00e9ment de la base\u00a0;</li> <li>comprendre les notions de Lazy Loading / Eager Loading\u00a0;</li> <li>d\u00e9couvrir que la mise \u00e0 jour de la base par le contexte de persistance se fait dans une transaction.</li> </ul>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#351-suppression-delements-du-contexte-de-persistance","title":"3.5.1. Suppression d'\u00e9l\u00e9ments du contexte de persistance","text":"<p>Nous avons une base remplie. Nous allons la vider. Nous cr\u00e9ons une nouvelle classe [Erase.cs] dans le projet actuel [1]\u00a0:</p> <p>La classe [Erase] est la suivante\u00a0:</p> <pre><code>using RdvMedecins.Models;\n\nnamespace RdvMedecins_01\n{\n  class Erase\n  {\n    static void Main(string[] args)\n    {\n      using (var context = new RdvMedecinsContext())\n      {\n        // on vide la base actuelle\n        // les clients\n        foreach (var client in context.Clients)\n        {\n          context.Clients.Remove(client);\n        }\n        // les m\u00e9decins\n        foreach (var medecin in context.Medecins)\n        {\n          context.Medecins.Remove(medecin);\n        }\n        // on sauve le contexte de persistance\n        context.SaveChanges();\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 9\u00a0: les op\u00e9rations sur un contexte de persistance se font toujours dans une clause [using]. Cela assure qu'\u00e0 la sortie du [using], le contexte a \u00e9t\u00e9 ferm\u00e9\u00a0;</li> <li>ligne 13\u00a0: on parcourt le contexte des clients [context.Clients]. Tous les clients de la base vont \u00eatre mis dans le contexte de persistance\u00a0;</li> <li>ligne 15\u00a0: pour chacun d'eux on fait l'op\u00e9ration [Remove] qui les supprime du contexte. En fait, ils sont toujours dans le contexte mais dans un \u00e9tat \"\u00a0supprim\u00e9\u00a0\"\u00a0;</li> <li>lignes 18-21\u00a0: on fait la m\u00eame chose pour les m\u00e9decins\u00a0;</li> <li>ligne 23\u00a0: on sauvegarde le contexte de persistance en base.</li> </ul> <p>Lors de la sauvegarde du contexte en base, les entit\u00e9s du contexte qui\u00a0:</p> <ul> <li>ont une cl\u00e9 primaire null font l'objet d'une op\u00e9ration SQL INSERT\u00a0;</li> <li>sont dans un \u00e9tat \"\u00a0supprim\u00e9\u00a0\" font l'objet d'une op\u00e9ration SQL DELETE\u00a0;</li> <li>sont dans un \u00e9tat \"\u00a0modifi\u00e9\u00a0\" font l'objet d'une op\u00e9ration SQL UPDATE\u00a0;</li> </ul> <p>Comme nous le constaterons ult\u00e9rieurement, ces op\u00e9rations SQL se font \u00e0 l'int\u00e9rieur d'une transaction. Si l'une d'elles \u00e9choue, tout ce qui a \u00e9t\u00e9 fait pr\u00e9c\u00e9demment est d\u00e9fait.</p> <p>Faisons du programme [Erase] le nouvel objet de d\u00e9marrage du projet [1] puis ex\u00e9cutons le projet.</p> <p>V\u00e9rifions la base. On constatera que toutes les tables sont vides [2]. C'est \u00e9tonnant, car nous avions demand\u00e9 simplement la suppression des m\u00e9decins et des clients. C'est par le jeu des cl\u00e9s \u00e9trang\u00e8res que les autres tables ont \u00e9t\u00e9 vid\u00e9es en cascade.</p> <p>La d\u00e9finition de la cl\u00e9 \u00e9trang\u00e8re de la table [CRENEAUX] vers la table [MEDECINS] a \u00e9t\u00e9 d\u00e9finie comme suit par le provider d'EF 5\u00a0:</p> <ul> <li>en [1], on s\u00e9lectionne la table [CRENEAUX]\u00a0;</li> <li>en [2], on s\u00e9lectionne l'onglet des cl\u00e9s \u00e9trang\u00e8res\u00a0;</li> <li>en [3], on \u00e9dite l'unique cl\u00e9 \u00e9trang\u00e8re\u00a0;</li> </ul> <ul> <li>en [4], dans l'onglet DDL , la d\u00e9finition SQL de la contrainte de cl\u00e9 \u00e9trang\u00e8re\u00a0;</li> <li>en [5], la clause ON DELETE CASCADE fait que la suppression d'un m\u00e9decin entra\u00eene la suppression des cr\u00e9neaux qui lui sont associ\u00e9s.</li> </ul> <p>Les contraintes de cl\u00e9 \u00e9trang\u00e8res de la table [RVS] sont d\u00e9finies de fa\u00e7on analogue\u00a0:</p> <pre><code>ALTER TABLE [dbo].[RVS]\nADD CONSTRAINT [FK_dbo.RVS_dbo.CLIENTS_CLIENT_ID] FOREIGN KEY ([CLIENT_ID]) \n  REFERENCES [dbo].[CLIENTS] ([ID]) \n  ON UPDATE NO ACTION\n  ON DELETE CASCADE\nGO\n</code></pre> <ul> <li>lignes 1-6\u00a0: supprimer un client supprimera l\u00e0 \u00e9galement les rendez-vous qui lui sont associ\u00e9s\u00a0;</li> </ul> <pre><code>ALTER TABLE [dbo].[RVS]\nADD CONSTRAINT [FK_dbo.RVS_dbo.CRENEAUX_CRENEAU_ID] FOREIGN KEY ([CRENEAU_ID]) \n  REFERENCES [dbo].[CRENEAUX] ([ID]) \n  ON UPDATE NO ACTION\n  ON DELETE CASCADE\nGO\n</code></pre> <ul> <li>lignes 1-6\u00a0:  supprimer un cr\u00e9neau supprimera \u00e9galement tous les rendez-vous qui lui sont associ\u00e9s.</li> </ul>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#352-ajout-delements-au-contexte-de-persistance","title":"3.5.2. Ajout d'\u00e9l\u00e9ments au contexte de persistance","text":"<p>Maintenant que nous avons vid\u00e9 la base, nous allons la remplir de nouveau. Nous ajoutons au projet le programme [Fill.cs] [1].</p> <p>Le programme [Fill.cs] est le suivant\u00a0:</p> <pre><code>using RdvMedecins.Entites;\nusing RdvMedecins.Models;\n\nnamespace RdvMedecins_01\n{\n  class Fill\n  {\n    static void Main(string[] args)\n    {\n      using (var context = new RdvMedecinsContext())\n      {\n        // on vide la base actuelle\n        foreach (var client in context.Clients)\n        {\n          context.Clients.Remove(client);\n        }\n        foreach (var medecin in context.Medecins)\n        {\n          context.Medecins.Remove(medecin);\n        }\n        // on la r\u00e9initialise\n        // les clients\n        Client[] clients ={\n        new Client { Titre = \"Mr\", Nom = \"Martin\", Prenom = \"Jules\" },\n        new Client { Titre = \"Mme\", Nom = \"German\", Prenom = \"Christine\" },\n        new Client { Titre = \"Mr\", Nom = \"Jacquard\", Prenom = \"Jules\" },\n        new Client { Titre = \"Melle\", Nom = \"Bistrou\", Prenom = \"Brigitte\" }\n     };\n        foreach (Client client in clients)\n        {\n          context.Clients.Add(client);\n        }\n        // les m\u00e9decins\n        Medecin[] medecins ={\n        new Medecin { Titre = \"Mme\", Nom = \"Pelissier\", Prenom = \"Marie\" },\n        new Medecin { Titre = \"Mr\", Nom = \"Bromard\", Prenom = \"Jacques\" },\n        new Medecin { Titre = \"Mr\", Nom = \"Jandot\", Prenom = \"Philippe\" },\n        new Medecin { Titre = \"Melle\", Nom = \"Jacquemot\", Prenom = \"Justine\" }\n     };\n        foreach (Medecin medecin in medecins)\n        {\n          context.Medecins.Add(medecin);\n        }\n        // les cr\u00e9neaux horaires\n        Creneau[] creneaux ={\n        new Creneau{ Hdebut=8,Mdebut=0,Hfin=8,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=8,Mdebut=20,Hfin=8,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=8,Mdebut=40,Hfin=9,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=9,Mdebut=0,Hfin=9,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=9,Mdebut=20,Hfin=9,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=9,Mdebut=40,Hfin=10,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=10,Mdebut=0,Hfin=10,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=10,Mdebut=20,Hfin=10,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=10,Mdebut=40,Hfin=11,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=11,Mdebut=0,Hfin=11,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=11,Mdebut=20,Hfin=11,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=11,Mdebut=40,Hfin=12,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=14,Mdebut=0,Hfin=14,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=14,Mdebut=20,Hfin=14,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=14,Mdebut=40,Hfin=15,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=15,Mdebut=0,Hfin=15,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=15,Mdebut=20,Hfin=15,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=15,Mdebut=40,Hfin=16,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=16,Mdebut=0,Hfin=16,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=16,Mdebut=20,Hfin=16,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=16,Mdebut=40,Hfin=17,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=17,Mdebut=0,Hfin=17,Mfin=20,Medecin=medecins[0]},\n        new Creneau{ Hdebut=17,Mdebut=20,Hfin=17,Mfin=40,Medecin=medecins[0]},\n        new Creneau{ Hdebut=17,Mdebut=40,Hfin=18,Mfin=0,Medecin=medecins[0]},\n        new Creneau{ Hdebut=8,Mdebut=0,Hfin=8,Mfin=20,Medecin=medecins[1]},\n        new Creneau{ Hdebut=8,Mdebut=20,Hfin=8,Mfin=40,Medecin=medecins[1]},\n        new Creneau{ Hdebut=8,Mdebut=40,Hfin=9,Mfin=0,Medecin=medecins[1]},\n        new Creneau{ Hdebut=9,Mdebut=0,Hfin=9,Mfin=20,Medecin=medecins[1]},\n        new Creneau{ Hdebut=9,Mdebut=20,Hfin=9,Mfin=40,Medecin=medecins[1]},\n        new Creneau{ Hdebut=9,Mdebut=40,Hfin=10,Mfin=0,Medecin=medecins[1]},\n        new Creneau{ Hdebut=10,Mdebut=0,Hfin=10,Mfin=20,Medecin=medecins[1]},\n        new Creneau{ Hdebut=10,Mdebut=20,Hfin=10,Mfin=40,Medecin=medecins[1]},\n        new Creneau{ Hdebut=10,Mdebut=40,Hfin=11,Mfin=0,Medecin=medecins[1]},\n        new Creneau{ Hdebut=11,Mdebut=0,Hfin=11,Mfin=20,Medecin=medecins[1]},\n        new Creneau{ Hdebut=11,Mdebut=20,Hfin=11,Mfin=40,Medecin=medecins[1]},\n        new Creneau{ Hdebut=11,Mdebut=40,Hfin=12,Mfin=0,Medecin=medecins[1]},\n      };\n        foreach (Creneau creneau in creneaux)\n        {\n          context.Creneaux.Add(creneau);\n        }\n        // les Rdv\n        context.Rvs.Add(new Rv { Jour = new System.DateTime(2012, 10, 8), Client = clients[0], Creneau = creneaux[0] });\n        // on sauve le contexte de persistance\n        context.SaveChanges();\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 10\u00a0: on ouvre le contexte de persistance\u00a0;</li> <li>lignes 13-20\u00a0: les lignes des tables [CLIENTS] et [MEDECINS] sont mises dans le contexte puis supprim\u00e9es de celui-ci. Nous venons de voir que cela vidait totalement la base\u00a0;</li> <li>lignes 22-88\u00a0: des \u00e9l\u00e9ments sont ajout\u00e9s au contexte de persistance. Ils ont tous leur cl\u00e9 primaire \u00e0 null. Ils seront donc ins\u00e9r\u00e9s dans la base\u00a0;</li> <li>ligne 90\u00a0: les changements op\u00e9r\u00e9s sur le contexte sont synchronis\u00e9s avec la base. Celle-ci va faire l'objet d'une s\u00e9rie d'op\u00e9rations SQL DELETE suivie d'une s\u00e9rie d'op\u00e9rations SQL INSERT\u00a0;</li> </ul> <p>On fait du programme [Fill], le nouvel objet de d\u00e9marrage du projet [1] puis on ex\u00e9cute ce dernier.</p> <p>On constate en [2] que les tables ont \u00e9t\u00e9 remplies.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#353-affichage-du-contenu-de-la-base","title":"3.5.3. Affichage du contenu de la base","text":"<p>Nous allons maintenant afficher le contenu de la base \u00e0 l'aide de requ\u00eates LINQ to Entity. LINQ (Language INtegrated Query) est apparu avec le framework .NET 3.5 en 2007. Il appara\u00eet comme une extension des langages .NET, c.a.d qu'il est int\u00e9gr\u00e9 au langage et sa syntaxe est v\u00e9rifi\u00e9e par le compilateur. Il permet de requ\u00eater diff\u00e9rentes collections avec une syntaxe pr\u00e9sentant des similitudes avec le langage SQL (Structured Query Language) de requ\u00eatage des bases de donn\u00e9es. Il existe diff\u00e9rentes moutures de LINQ\u00a0:</p> <ul> <li>LINQ to Object, pour requ\u00eater des collections en m\u00e9moire\u00a0;</li> <li>LINQ to XML, pour requ\u00eater du XML\u00a0;</li> <li>LINQ to Entity, pour requ\u00eater des bases de donn\u00e9es\u00a0;</li> </ul> <p>Pour exister, LINQ s'appuie sur de nombreuses extensions faites aux langages .NET. Celles-ci peuvent \u00eatre utilis\u00e9es en-dehors de LINQ. Nous n'allons pas les pr\u00e9senter mais simplement donner deux r\u00e9f\u00e9rences o\u00f9 le lecteur trouvera une description approfondie de LINQ\u00a0:</p> <ul> <li>LINQ in Action, Fabrice Marguerie, Steve Eichert, Jim Wooley aux \u00e9ditions Manning\u00a0;</li> <li>LINQ pocket reference, Joseph et Ben Albahari aux \u00e9ditions O'Reilly.</li> </ul> <p>J'ai lu le premier et l'ai trouv\u00e9 excellent. Je n'ai pas lu le second mais ai lu des m\u00eames auteurs \"\u00a0C# 3.0 in a nutshell\u00a0\" \u00e0 la sortie de LINQ. J'ai trouv\u00e9 ce livre tr\u00e8s au-dessus de la moyenne des livres que j'ai l'habitude de lire. Il semble que les autres livres de ces deux auteurs soient du m\u00eame niveau. Nous allons par ailleurs utiliser LINQPad, un outil d'apprentissage de LINQ \u00e9crit par Joseph Albahari.</p> <p>Nous allons afficher les entit\u00e9s pr\u00e9sentes dans la base. Pour cela, nous ajoutons \u00e0 leurs classes deux m\u00e9thodes d'affichage. Commen\u00e7ons par l'entit\u00e9 [Medecin]\u00a0:</p> <pre><code>// un m\u00e9decin\n  public class Medecin\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int? Id { get; set; }\n    [Required]\n    [MaxLength(5)]\n    [Column(\"TITRE\")]\n    public string Titre { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"NOM\")]\n    public string Nom { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"PRENOM\")]\n    public string Prenom { get; set; }\n    // les cr\u00e9neaux horaires du m\u00e9decin\n    public ICollection&lt;Creneau&gt; Creneaux { get; set; }\n    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n\n    // signature\n    public override string ToString()\n    {\n      return String.Format(\"Medecin[{0},{1},{2},{3},{4}]\", Id, Titre, Prenom, Nom, dump(Timestamp));\n    }\n    // signature courte\n    public string ShortIdentity()\n    {\n      return ToString();\n    }\n\n    // utilitaire\n    private string dump(byte[] timestamp){\n      string str = \"\";\n      foreach (byte b in timestamp)\n      {\n        str += b;\n      }\n      return str;\n    }\n  }\n</code></pre> <ul> <li>lignes 27-30\u00a0: la m\u00e9thode ToString de la classe. On notera qu'elle n'affiche pas la collection de la ligne 21\u00a0;</li> <li>lignes 32-37\u00a0: la m\u00e9thode ShortIdentity qui fait la m\u00eame chose.</li> </ul> <p>Il nous faut ici expliquer les notions de Lazy et Eager Loading pour mesurer l'impact des deux m\u00e9thodes pr\u00e9c\u00e9dentes. Nous avons vu qu'une entit\u00e9 pouvait avoir des d\u00e9pendances sur une autre entit\u00e9. Elles sont de deux natures\u00a0:</p> <ul> <li>de un \u00e0 plusieurs, comme ci-dessus o\u00f9 un m\u00e9decin est reli\u00e9 \u00e0 plusieurs cr\u00e9neaux horaires\u00a0;</li> <li>de plusieurs \u00e0 un, comme dans l'entit\u00e9 [Creneau] ci-dessous o\u00f9 un plusieurs cr\u00e9neaux sont reli\u00e9s au m\u00eame m\u00e9decin\u00a0;</li> </ul> <pre><code>public class Creneau\n  {\n    // data\n    ...\n    [Required]\n    [Column(\"MEDECIN_ID\")]\n    public int MedecinId { get; set; }\n    [Required]\n    [ForeignKey(\"MedecinId\")]\n    public virtual Medecin Medecin { get; set; }\n    ...\n  }\n</code></pre> <p>Lorsque les d\u00e9pendances sont charg\u00e9es en m\u00eame temps que les entit\u00e9s auxquelles elles sont attach\u00e9es, on parle d'Eager Loading. Sinon, on parle de Lazy Loading\u00a0: les d\u00e9pendances ne sont charg\u00e9es que lorsqu'elles sont r\u00e9f\u00e9renc\u00e9es la premi\u00e8re fois. Par d\u00e9faut, EF 5 utilise le Lazy Loading\u00a0: les d\u00e9pendances ne sont pas charg\u00e9es en m\u00eame temps que l'entit\u00e9.</p> <p>Voyons notre m\u00e9thode [ToString] ci-dessus\u00a0:</p> <pre><code>    // les cr\u00e9neaux horaires du m\u00e9decin\n    public ICollection&lt;Creneau&gt; Creneaux { get; set; }\n\n    // signature\n    public override string ToString()\n    {\n      return String.Format(\"Medecin[{0},{1},{2},{3},{4}]\", Id, Titre, Prenom, Nom, dump(Timestamp));\n    }\n    // signature courte\n    public string ShortIdentity()\n    {\n      return ToString();\n}\n</code></pre> <p>La m\u00e9thode [ToString] n'affiche pas la d\u00e9pendance [Creneaux] de la ligne 2. Si elle l'avait fait, elle aurait alors forc\u00e9 le chargement de tous les cr\u00e9neaux du m\u00e9decin avant son ex\u00e9cution. C'est pour \u00e9viter ce chargement co\u00fbteux que la d\u00e9pendance n'a pas \u00e9t\u00e9 incluse dans la signature de l'entit\u00e9. De fa\u00e7on g\u00e9n\u00e9rale, nous allons inclure deux signatures dans chaque entit\u00e9\u00a0:</p> <ul> <li>une m\u00e9thode ToString qui affichera l'entit\u00e9 et ses \u00e9ventuelles d\u00e9pendances plusieurs \u00e0 un. Comme il vient d'\u00eatre expliqu\u00e9 cela provoquera le chargement de la d\u00e9pendance\u00a0;</li> <li>une m\u00e9thode ShortIdentity qui ne r\u00e9f\u00e9rencera aucune d\u00e9pendance. Il n'y aura donc aucun chargement de d\u00e9pendance\u00a0;</li> </ul> <p>Les m\u00e9thodes d'affichage des autres entit\u00e9s seront les suivantes\u00a0:</p> <p>L'entit\u00e9 [Client]\u00a0:</p> <pre><code>  public class Client\n  {\n    // data\n    ...\n    // les Rvs du client\n    public ICollection&lt;Rv&gt; Rvs { get; set; }\n\n    // signature\n    public override string ToString()\n    {\n      return String.Format(\"Client[{0},{1},{2},{3},{4}]\", Id, Titre, Prenom, Nom, dump(Timestamp));\n    }\n    // signature courte\n    public string ShortIdentity()\n    {\n      return ToString();\n    }\n\n}\n</code></pre> <ul> <li>lignes 9-12\u00a0: la m\u00e9thode [ToString] n'affiche pas la d\u00e9pendance de la ligne 6\u00a0;</li> </ul> <p>L'entit\u00e9 [Creneau]\u00a0:</p> <pre><code>public class Creneau\n  {\n    ...\n    [Required]\n    [Column(\"MEDECIN_ID\")]\n    public int MedecinId { get; set; }\n    [Required]\n    [ForeignKey(\"MedecinId\")]\n    public virtual Medecin Medecin { get; set; }\n    // les Rvs du cr\u00e9neau\n    public ICollection&lt;Rv&gt; Rvs { get; set; }\n\n    // signature\n    public override string ToString()\n    {\n      return String.Format(\"Creneau[{0},{1},{2},{3},{4}, {5}]\", Id, Hdebut, Mdebut, Hfin, Mfin, Medecin, dump(Timestamp));\n    }\n    // signature courte\n    public string ShortIdentity()\n    {\n      return String.Format(\"Creneau[{0},{1},{2},{3},{4}, {5}, {6}]\", Id, Hdebut, Mdebut, Hfin, Mfin, Timestamp, MedecinId, dump(Timestamp));\n    }\n  }\n</code></pre> <ul> <li>ligne 16\u00a0: la m\u00e9thode [ToString] r\u00e9f\u00e9rence la d\u00e9pendance de la ligne 9. Cela va forcer son chargement\u00a0;</li> <li>ligne 11\u00a0: la d\u00e9pendance [Rvs] n'est pas r\u00e9f\u00e9renc\u00e9e. Elle ne sera pas charg\u00e9e\u00a0;</li> <li>lignes 21-22\u00a0: la m\u00e9thode [ShortIdentity] ne r\u00e9f\u00e9rence plus la r\u00e9f\u00e9rence [Medecin] de la ligne 9. Celle-ci ne sera donc pas charg\u00e9e.</li> </ul> <p>L'entit\u00e9 [Rv]\u00a0:</p> <pre><code>public class Rv\n  {\n    // data\n    ...\n    [Column(\"CLIENT_ID\")]\n    public int ClientId { get; set; }\n    [ForeignKey(\"ClientId\")]\n    [Required]\n    public virtual Client Client { get; set; }\n    [Column(\"CRENEAU_ID\")]\n    public int CreneauId { get; set; }\n    [ForeignKey(\"CreneauId\")]\n    [Required]\n    public virtual Creneau Creneau { get; set; }\n\n    // signature\n    public override string ToString()\n    {\n      return String.Format(\"Rv[{0},{1},{2},{3},{4}]\", Id, Jour, Client, Creneau, dump(Timestamp));\n    }\n    // signature courte\n    public string ShortIdentity()\n    {\n      return String.Format(\"Rv[{0},{1},{2},{3},{4}]\", Id, Jour, ClientId, CreneauId, dump(Timestamp));\n    }\n\n  }\n</code></pre> <ul> <li>lignes 17-20\u00a0: la m\u00e9thode [ToString] r\u00e9f\u00e9rence les d\u00e9pendances des lignes 9 et 14. Cela va forcer leur chargement\u00a0;</li> <li>lignes 17-20\u00a0: la m\u00e9thode [ShortIdentity] \u00e9vite cela et donc les d\u00e9pendances ne seront pas charg\u00e9es.</li> </ul> <p>En conclusion, on pr\u00eatera attention aux m\u00e9thodes [ToString] des entit\u00e9s. Si on n'y pr\u00eate pas attention, afficher une table peut charger la moiti\u00e9 de la base si la table a de nombreuses d\u00e9pendances.</p> <p>Ceci expliqu\u00e9, on \u00e9crit le nouveau code [Dump.cs] suivant\u00a0:</p> <pre><code>using RdvMedecins.Entites;\nusing RdvMedecins.Models;\nusing System;\nusing System.Linq;\n\nnamespace RdvMedecins_01\n{\n  class Dump\n  {\n    static void Main(string[] args)\n    {\n      // dump de la base\n      using (var context = new RdvMedecinsContext())\n      {\n        // les clients\n        Console.WriteLine(\"Clients--------------------------------------\");\n        var clients = from client in context.Clients select client;\n        foreach (Client client in clients)\n        {\n          Console.WriteLine(client);\n        }\n        // les m\u00e9decins\n        Console.WriteLine(\"M\u00e9decins--------------------------------------\");\n        var medecins = from medecin in context.Medecins select medecin;\n        foreach (Medecin medecin in medecins)\n        {\n          Console.WriteLine(medecin);\n        }\n        // les cr\u00e9neaux horaires\n        Console.WriteLine(\"Cr\u00e9neaux horaires--------------------------------------\");\n        var creneaux = from creneau in context.Creneaux select creneau;\n        foreach (Creneau creneau in creneaux)\n        {\n          Console.WriteLine(creneau);\n        }\n        // les Rdvs\n        Console.WriteLine(\"Rendez-vous--------------------------------------\");\n        var rvs = from rv in context.Rvs select rv;\n        foreach (Rv rv in rvs)\n        {\n          Console.WriteLine(rv);\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Nous allons expliquer les lignes 17-21 qui affiche les entit\u00e9s [Client]. L'explication donn\u00e9e vaudra pour les autres entit\u00e9s.</p> <pre><code>        // les clients\n        Console.WriteLine(\"Clients--------------------------------------\");\n        var clients = from client in context.Clients select client;\n        foreach (Client client in clients)\n        {\n          Console.WriteLine(client);\n}\n</code></pre> <ul> <li>ligne 3\u00a0: le mot cl\u00e9 var a \u00e9t\u00e9 introduit avec C# 3.0. Il permet d'\u00e9viter d'indiquer le type pr\u00e9cis d'une variable. Le compilateur d\u00e9duit alors celui-ci du type de l'expression affect\u00e9e \u00e0 la variable\u00a0;</li> <li>ligne 3\u00a0: l'expression affect\u00e9e \u00e0 la variable clients est une requ\u00eate LINQ to Entity. On y reconna\u00eet des mots cl\u00e9s du langage SQL port\u00e9s dans LINQ. La syntaxe utilis\u00e9e ici est la suivante\u00a0:</li> </ul> <pre><code>from variable in DbSet select variable\n</code></pre> <p>Une syntaxe plus g\u00e9n\u00e9rale de LINQ est</p> <pre><code>from variable in collection select variable\n</code></pre> <p>La collection va \u00eatre parcourue et pour chaque \u00e9l\u00e9ment de celle-ci, la variable va \u00eatre \u00e9valu\u00e9e. Ceci n'est fait que lorsque la variable [clients] de la ligne 3 va \u00eatre \u00e9num\u00e9r\u00e9e par le for / each des lignes 4-7. Tant que ceci n'est pas fait, la variable [clients] n'est qu'une requ\u00eate non \u00e9valu\u00e9e\u00a0;</p> <ul> <li>ligne 4\u00a0: la requ\u00eate [clients] est \u00e9num\u00e9r\u00e9e. Cela va forcer l'\u00e9valuation de la requ\u00eate. Les lignes de la table [CLIENTS] vont \u00eatre amen\u00e9es tour \u00e0 tour dans le contexte de persistance\u00a0;</li> <li>ligne 6\u00a0: la m\u00e9thode [ToString] de l'entit\u00e9 [Client] est utilis\u00e9e pour l'affichage. Il n'y a aucun chargement de d\u00e9pendances\u00a0;</li> </ul> <p>Passons aux lignes suivantes du code\u00a0:</p> <ul> <li>lignes 24-28\u00a0: les lignes de la table [MEDECINS] sont amen\u00e9es dans le contexte de persistance et affich\u00e9es. Il n'y a aucun chargement de d\u00e9pendances\u00a0;</li> <li>lignes 31-35\u00a0: les lignes de la table [CRENEAUX] sont amen\u00e9es dans le contexte de persistance et affich\u00e9es. Nous avons vu que la m\u00e9thode [ToString] de cette entit\u00e9 affichait la d\u00e9pendance [Medecin]. Or celle-ci est d\u00e9j\u00e0 charg\u00e9e. Il n'y aura donc pas de nouveau chargement\u00a0;</li> <li>lignes 38-42\u00a0: les lignes de la table [RVS] sont amen\u00e9es dans le contexte de persistance et affich\u00e9es. Nous avons vu que la m\u00e9thode [ToString] de cette entit\u00e9 affichait les d\u00e9pendances [Client] et [Creneau]. Or celles-ci sont d\u00e9j\u00e0 charg\u00e9es. Il n'y aura donc pas de nouveaux chargements.</li> </ul> <p>On notera que l'ordre d'affichage n'est pas neutre. Si on avait voulu afficher d'abord les entit\u00e9s [Rv], la m\u00e9thode [ToString] de celle-ci aurait provoqu\u00e9 le chargement des entit\u00e9s [Client] et [Creneau] li\u00e9es \u00e0 ces rendez-vous. Les autres n'auraient pas \u00e9t\u00e9 charg\u00e9es. Elles l'auraient \u00e9t\u00e9 plus tard dans un autre affichage. Cela a un impact sur les performances. Le code pr\u00e9c\u00e9dent a besoin de quatre ordres SQL pour faire afficher toutes les entit\u00e9s. Supposons maintenant qu'on exploite d'abord la tables [RVS] des rendez-vous. Une premi\u00e8re requ\u00eate SQL est n\u00e9cessaire pour la table [RVS]. Ensuite, la m\u00e9thode [ToString] de l'entit\u00e9 [Rv] va provoquer le chargement \u00e9ventuel des entit\u00e9s [Client] et [Creneau] associ\u00e9es. Il faut une requ\u00eate SQL pour chacune. En supposant qu'il y ait N2 clients et N3 cr\u00e9neaux et que toutes ces entit\u00e9s soient r\u00e9f\u00e9renc\u00e9es dans la table [RVS], l'affichage de celle-ci n\u00e9cessitera 1+N2+N3 requ\u00eates SQL. Donc, on n'est moins performant que dans la version \u00e9tudi\u00e9e. Pour afficher la table [RVS] avec ses d\u00e9pendances, une jointure entre tables serait n\u00e9cessaire. Il est possible de la r\u00e9aliser avec LINQ. Nous y reviendrons sur un exemple. Pour l'instant, nous nous rappellerons que nous devons pr\u00eater attention aux requ\u00eates SQL sous-jacentes \u00e0 notre code LINQ.</p> <p>On param\u00e8tre le projet pour ex\u00e9cuter ce nouveau code [1] et [2] puis on l'ex\u00e9cute\u00a0:</p> <p>L'affichage console est le suivant\u00a0:</p> <pre><code>Clients--------------------------------------\nClient[9,Mr,Jules,Martin,000000844]\nClient[10,Mme,Christine,German,000000845]\nClient[11,Mr,Jules,Jacquard,000000846]\nClient[12,Melle,Brigitte,Bistrou,000000847]\nM\u00e9decins--------------------------------------\nMedecin[9,Mme,Marie,Pelissier,000000848]\nMedecin[10,Mr,Jacques,Bromard,000000873]\nMedecin[11,Mr,Philippe,Jandot,000000886]\nMedecin[12,Melle,Justine,Jacquemot,000000887]\nCr\u00e9neaux horaires--------------------------------------\nCreneau[73,8,0,8,20, Medecin[9,Mme,Marie,Pelissier,000000848],000000849]\nCreneau[74,8,20,8,40, Medecin[9,Mme,Marie,Pelissier,000000848],000000850]\nCreneau[75,8,40,9,0, Medecin[9,Mme,Marie,Pelissier,000000848],000000851]\nCreneau[76,9,0,9,20, Medecin[9,Mme,Marie,Pelissier,000000848],000000852]\nCreneau[77,9,20,9,40, Medecin[9,Mme,Marie,Pelissier,000000848],000000853]\nCreneau[78,9,40,10,0, Medecin[9,Mme,Marie,Pelissier,000000848],000000854]\nCreneau[79,10,0,10,20, Medecin[9,Mme,Marie,Pelissier,000000848],000000855]\nCreneau[80,10,20,10,40, Medecin[9,Mme,Marie,Pelissier,000000848],000000856]\nCreneau[81,10,40,11,0, Medecin[9,Mme,Marie,Pelissier,000000848],000000857]\nCreneau[82,11,0,11,20, Medecin[9,Mme,Marie,Pelissier,000000848],000000858]\nCreneau[83,11,20,11,40, Medecin[9,Mme,Marie,Pelissier,000000848],000000859]\nCreneau[84,11,40,12,0, Medecin[9,Mme,Marie,Pelissier,000000848],000000860]\nCreneau[85,14,0,14,20, Medecin[9,Mme,Marie,Pelissier,000000848],000000861]\nCreneau[86,14,20,14,40, Medecin[9,Mme,Marie,Pelissier,000000848],000000862]\nCreneau[87,14,40,15,0, Medecin[9,Mme,Marie,Pelissier,000000848],000000863]\nCreneau[88,15,0,15,20, Medecin[9,Mme,Marie,Pelissier,000000848],000000864]\nCreneau[89,15,20,15,40, Medecin[9,Mme,Marie,Pelissier,000000848],000000865]\nCreneau[90,15,40,16,0, Medecin[9,Mme,Marie,Pelissier,000000848],000000866]\nCreneau[91,16,0,16,20, Medecin[9,Mme,Marie,Pelissier,000000848],000000867]\nCreneau[92,16,20,16,40, Medecin[9,Mme,Marie,Pelissier,000000848],000000868]\nCreneau[93,16,40,17,0, Medecin[9,Mme,Marie,Pelissier,000000848],000000869]\nCreneau[94,17,0,17,20, Medecin[9,Mme,Marie,Pelissier,000000848],000000870]\nCreneau[95,17,20,17,40, Medecin[9,Mme,Marie,Pelissier,000000848],000000871]\nCreneau[96,17,40,18,0, Medecin[9,Mme,Marie,Pelissier,000000848],000000872]\nCreneau[97,8,0,8,20, Medecin[10,Mr,Jacques,Bromard,000000873],000000874]\nCreneau[98,8,20,8,40, Medecin[10,Mr,Jacques,Bromard,000000873],000000875]\nCreneau[99,8,40,9,0, Medecin[10,Mr,Jacques,Bromard,000000873],000000876]\nCreneau[100,9,0,9,20, Medecin[10,Mr,Jacques,Bromard,000000873],000000877]\nCreneau[101,9,20,9,40, Medecin[10,Mr,Jacques,Bromard,000000873],000000878]\nCreneau[102,9,40,10,0, Medecin[10,Mr,Jacques,Bromard,000000873],000000879]\nCreneau[103,10,0,10,20, Medecin[10,Mr,Jacques,Bromard,000000873],000000880]\nCreneau[104,10,20,10,40, Medecin[10,Mr,Jacques,Bromard,000000873],000000881]\nCreneau[105,10,40,11,0, Medecin[10,Mr,Jacques,Bromard,000000873],000000882]\nCreneau[106,11,0,11,20, Medecin[10,Mr,Jacques,Bromard,000000873],000000883]\nCreneau[107,11,20,11,40, Medecin[10,Mr,Jacques,Bromard,000000873],000000884]\nCreneau[108,11,40,12,0, Medecin[10,Mr,Jacques,Bromard,000000873],000000885]\nRendez-vous--------------------------------------\nRv[3,08/10/2012 00:00:00,Client[9,Mr,Jules,Martin,000000844],Creneau[73,8,0,8,20\n, Medecin[9,Mme,Marie,Pelissier,000000848],000000849],000000888]\nAppuyez sur une touche pour continuer...\n</code></pre>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#354-apprentissage-de-linq-avec-linqpad","title":"3.5.4. Apprentissage de LINQ avec LINQPad","text":"<p>Nous avons utilis\u00e9 ci-dessus, des requ\u00eates LINQ to Entity pour afficher le contenu des tables de la base de donn\u00e9es. Joseph Albahari a \u00e9crit un programme d'apprentissage des diff\u00e9rentes formes de LINQ. Nous le pr\u00e9sentons maintenant.</p> <p>LINQPad est disponible \u00e0 l'URL suivante [http://www.linqpad.net/]. Une fois install\u00e9, nous le lan\u00e7ons [1]\u00a0:</p> <p>Le d\u00e9butant LINQ pourra s'initier avec les exemples de l'onglet [Samples] [2] qui montrent de tr\u00e8s nombreux exemples. S\u00e9lectionnons l'exemple [3] qui s'affiche alors dans une autre fen\u00eatre [4]. Le code complet de l'exemple est celui-ci\u00a0:</p> <pre><code>// Now for a simple LINQ-to-objects query expression (notice no semicolon):\n\nfrom word in \"The quick brown fox jumps over the lazy dog\".Split()\norderby word.Length\nselect word\n\n\n// Feel free to edit this... (no-one's watching!) You'll be prompted to save any\n// changes to a separate file.\n//\n// Tip:  You can execute part of a query by highlighting it, and then pressing F5.\n</code></pre> <p>Les lignes 3-5 sont un exemple de requ\u00eate LINQ to Object. La requ\u00eate LINQ suit la syntaxe\u00a0:</p> <pre><code>from variable in collection orderby \u00e9l\u00e9ment1 select \u00e9l\u00e9ment2\n</code></pre> <ul> <li>variable d\u00e9signe l'\u00e9l\u00e9ment courant de la collection. Dans notre exemple, cette collection est la liste de mots r\u00e9sultats de la cha\u00eene splitt\u00e9e\u00a0;</li> <li>la collection est ordonn\u00e9e selon le param\u00e8tre \u00e9l\u00e9ment1 de orderby. Dans notre exemple, la collection de mots sera ordonn\u00e9e selon leur longueur\u00a0;</li> <li>le mot cl\u00e9 select d\u00e9signe ce qu'on veut retirer de l'\u00e9l\u00e9ment courant variable de la collection. Dans notre exemple, ce sera le mot.</li> </ul> <p>Ex\u00e9cutons cette requ\u00eate LINQ\u00a0:</p> <ul> <li>en [1]\u00a0: une expression LINQ est ex\u00e9cut\u00e9e par [F5] ou bien via le bouton d'ex\u00e9cution\u00a0;</li> <li>en [2]\u00a0: l'affichage. Les mots sont affich\u00e9s dans l'ordre de leur longueur. Ce simple exemple montre la puissance de LINQ\u00a0;</li> <li>en [3], il est possible de t\u00e9l\u00e9charger d'autres exemples, notamment ceux du livre \"\u00a0LINQ in action\u00a0\" [4]\u00a0;</li> </ul> <ul> <li>en [5], nous choisissons un exemple du livre\u00a0;</li> </ul> <pre><code>string[] words = { \"hello\", \"wonderful\", \"linq\", \"beautiful\", \"world\" };\n\n// Group words by length\nvar groups =\n  from word in words\n  orderby word ascending\n  group word by word.Length into lengthGroups\n  orderby lengthGroups.Key descending\n  select new { Length = lengthGroups.Key, Words = lengthGroups };\n\n// Print each group out\nforeach (var group in groups)\n{\n  Console.WriteLine(\"Words of length \" + group.Length);\n  foreach (string word in group.Words)\n    Console.WriteLine(\"  \" + word);\n}\n</code></pre> <ul> <li>ligne 4\u00a0: une nouvelle requ\u00eate LINQ avec de nouveaux mots cl\u00e9s\u00a0;</li> <li>ligne 5\u00a0: la collection requ\u00eat\u00e9e est le tableau de mots de la ligne 1\u00a0;</li> <li>ligne 6\u00a0: la collection est tri\u00e9e dans l'ordre alphab\u00e9tique des mots\u00a0;</li> <li>ligne 7\u00a0: la collection est regroup\u00e9e dans (mot cl\u00e9 into) une nouvelle collection lengthGroups. lengthGroups.Key repr\u00e9sente le facteur de regroupement (mot cl\u00e9 by), ici la longueur des mots.  lengthGroups rassemble les mots ayant le m\u00eame facteur de regroupement donc la m\u00eame longueur\u00a0;</li> <li>ligne 8\u00a0: la collection lengthGroups est ordonn\u00e9e par cl\u00e9 de regroupement descendant, donc ici par taille d\u00e9croissante des mots\u00a0;</li> <li>ligne 9\u00a0: de cette collection, on produit de nouveaux objets (classes anonymes) ayant deux champs\u00a0:</li> <li>Length\u00a0: la longueur des mots,</li> <li>Words\u00a0: les mots ayant cette longueur\u00a0;</li> </ul> <p>Ici, on voit particuli\u00e8rement l'int\u00e9r\u00eat du mot cl\u00e9 var de la ligne 4. Parce qu'on a utilis\u00e9 une classe anonyme ligne 9, on ne sait pas d\u00e9signer le type de la variable groups. Le compilateur lui, va donner un nom interne \u00e0 la classe anonyme et va typer avec, la variable groups. Il sera capable ensuite de dire si la variable groups est utilis\u00e9e correctement </p> <ul> <li>ligne 12\u00a0: parcours de la requ\u00eate de la ligne 4. Ce n'est qu'\u00e0 ce moment qu'elle est \u00e9valu\u00e9e. On se rappelle que son ex\u00e9cution va produire une collection d'objets, pr\u00e9cis\u00e9s ligne 9\u00a0;</li> <li>ligne 14\u00a0: on affiche la propri\u00e9t\u00e9 Length de l'\u00e9l\u00e9ment courant, donc une longueur de mots\u00a0;</li> <li>lignes 15-17\u00a0: on affiche chaque \u00e9l\u00e9ment de la collection de la propri\u00e9t\u00e9 Words, donc l'ensemble des mots ayant la longueur affich\u00e9e pr\u00e9c\u00e9demment.</li> </ul> <p>Lorsque nous ex\u00e9cutons cette requ\u00eate, nous obtenons le r\u00e9sultat suivant dans LINQPad\u00a0:</p> <p>Maintenant que nous avons vu quelques exemples de requ\u00eates [LINQ to Object], voyons des requ\u00eates [LINQ to Entity] qui vont nous permettre de requ\u00eater des bases de donn\u00e9es. Nous allons tout d'abord nous connecter \u00e0 la base de donn\u00e9es SQL Server que nous avons cr\u00e9\u00e9e et remplie\u00a0:</p> <ul> <li>en [1], on ajoute une connexion \u00e0 une base de donn\u00e9es\u00a0;</li> <li>en [2], les moyens d'acc\u00e8s \u00e0 la source de donn\u00e9es. Pour acc\u00e9der \u00e0 la base SQL Server, nous utiliserons [LINQPad Driver]\u00a0;</li> <li>en [3], il est \u00e9galement possible de r\u00e9cup\u00e9rer un contexte de persistance [DbContext] d\u00e9fini dans un assembly .exe ou .dll (option 3). Malheureusement, \u00e0 ce jour (8 octobre 2012), Entity Framework 5 n'est pas support\u00e9\u00a0;</li> <li>en [4], il est possible de t\u00e9l\u00e9charger des pilotes pour d'autres SGBD que SQL Server\u00a0;</li> <li>en [5], on t\u00e9l\u00e9chargera le driver pour les SGBD MySQL et Oracle\u00a0;</li> </ul> <ul> <li>en [6], le pilote t\u00e9l\u00e9charg\u00e9\u00a0;</li> <li>en [7], nous nous connectons \u00e0 une base SQL Server\u00a0;</li> </ul> <ul> <li>en [8], la base est sur le serveur de nom (local)\u00a0;</li> <li>en [9], on se connecte avec l'authentification sa / sqlserver2012\u00a0;</li> <li>en [10], \u00e0 la base [rdvmedecins-ef] que nous avons cr\u00e9\u00e9e\u00a0;</li> <li>en [11], on peut tester la connexion\u00a0;</li> <li>en [12], on termine l'assistant\u00a0;</li> <li>en [13], la connexion appara\u00eet dans LINQPad.</li> </ul> <p>Les entit\u00e9s ont \u00e9t\u00e9 cr\u00e9\u00e9es \u00e0 partir de la table [rdvmedecins-ef]. Ce sont les suivantes\u00a0:</p> <ul> <li>en [1], [CLIENTS] repr\u00e9sente l'ensemble des entit\u00e9s [Client]. Chaque entit\u00e9 a\u00a0: </li> <li>les propri\u00e9t\u00e9s (ID, TITRE, NOM, PRENOM, TIMESTAMP),</li> <li>une relation 1 \u00e0 plusieurs [CLIENTRVS]\u00a0;</li> <li>en [2], [CRENEAUXes] repr\u00e9sente l'ensemble des entit\u00e9s [Creneau]. Chaque entit\u00e9 a\u00a0: </li> <li>les propri\u00e9t\u00e9s (ID, HDEBUT, MDEBUT, HFIN, MFIN, MEDECIN_ID, TIMESTAMP),</li> <li>une relation 1 \u00e0 plusieurs [CRENEAURVS],</li> <li>une relation plusieurs \u00e0 1 [MEDECIN]\u00a0;</li> <li>en [3], l'entit\u00e9 [MEDECINS] repr\u00e9sente l'ensemble des entit\u00e9s [Medecin]. Chaque entit\u00e9 a\u00a0: </li> <li>les propri\u00e9t\u00e9s (ID, TITRE, NOM, PRENOM, TIMESTAMP),</li> <li>une relation 1 \u00e0 plusieurs [MEDECINCRENEAUXes]\u00a0;</li> <li>en [4], l'entit\u00e9 [RVS] repr\u00e9sente l'ensemble des entit\u00e9s [Rv]. Chaque entit\u00e9 a\u00a0: </li> <li>les propri\u00e9t\u00e9s (ID, JOUR, CLIET_ID, CRENEAU_ID, TIMESTAMP),</li> <li>une relation plusieurs \u00e0 1 [CLIENT],</li> <li>une relation plusieurs \u00e0 1 [CRENEAU].</li> </ul> <p>On notera que les noms des propri\u00e9t\u00e9s ci-dessus sont diff\u00e9rentes des noms que nous avons utilis\u00e9s jusqu'\u00e0 maintenant. Cela importe peu. Nous voulons juste apprendre les principes de base du requ\u00eatage sur base de donn\u00e9es.</p> <p>Voyons comment nous pouvons requ\u00eater cette base d'entit\u00e9s. Par exemple, nous voulons la liste des m\u00e9decins ordonn\u00e9e par leur TITRE et NOM\u00a0:</p> <ul> <li>en [1], on cr\u00e9e une nouvelle requ\u00eate\u00a0;</li> <li>en [2], le texte de la requ\u00eate\u00a0;</li> </ul> <ul> <li>en [3], le r\u00e9sultat de la requ\u00eate\u00a0;</li> <li>en [4], la m\u00eame requ\u00eate avec des expressions lambda. Une requ\u00eate avec des expressions lambda est moins lisible qu'une requ\u00eate texte et on pourrait vouloir s'en passer. Elles sont cependant parfois indispensables car elles permettent certaines choses que les requ\u00eates texte ne permettent pas. Une expression lambda d\u00e9signe une fonction \u00e0 un param\u00e8tre d'entr\u00e9e a et un param\u00e8tre de sortie b, sous la forme a=&gt;b. La m\u00e9thode OrderBy ci-dessus admet une fonction lambda comme unique param\u00e8tre. Celle-ci lui fournit le param\u00e8tre selon lequel doit \u00eatre ordonn\u00e9e une collection. Ainsi MEDECINS.OrderBy(m=&gt;m.TITRE) est la liste des m\u00e9decins ordonn\u00e9e par les titres. Il faut lire l'instruction comme un pipe-line sur une collection. La collection des m\u00e9decins est fournie en entr\u00e9e \u00e0 la m\u00e9thode OrderBy. Celle-ci va exploiter les entit\u00e9s [Medecin] une par une. Dans l'expression lambda m=&gt;m.TITRE, m repr\u00e9sente l'entr\u00e9e de la fonction lambda. On peut la nommer comme on veut. Ici, l'entr\u00e9e de la fonction lambda sera une entit\u00e9 [Medecin]. La fonction m=&gt;m.TITRE se lit comme suit\u00a0: si j'appelle m mon entr\u00e9e (une entit\u00e9 [Medecin]) alors ma sortie est m.TITRE, donc le titre du m\u00e9decin. MEDECINS.OrderBy(m=&gt;m.TITRE) est a son tour une collection, la collection des m\u00e9decins ordonn\u00e9e par les titres. Cette nouvelle collection peut alimenter une autre m\u00e9thode, dans l'exemple la m\u00e9thode ThenBy. Celle-ci fonctionne sur le m\u00eame principe. Elle sert \u00e0 indiquer des param\u00e8tres suppl\u00e9mentaires pour le tri de la collection.</li> </ul> <p>Lire le code lambda \u00e9quivalent au code texte que nous tapons habituellement est une bonne fa\u00e7on de l'apprendre\u00a0;</p> <ul> <li>en [5], l'ordre SQL \u00e9mis sur la base. L\u00e0 encore, on lira attentivement ce code. Il permet d'\u00e9valuer le co\u00fbt r\u00e9el d'une requ\u00eate LINQ.</li> </ul> <p>Dans la suite, nous pr\u00e9sentons quelques exemples de requ\u00eate LINQ. A chaque fois, nous montrons les r\u00e9sultats affich\u00e9s et les codes lambda et SQL \u00e9quivalents. Pour comprendre ces requ\u00eates, il faut rappeler les relations plusieurs \u00e0 un qui relient les entit\u00e9s les unes aux autres. C'est par elles qu'on navigue d'une entit\u00e9 \u00e0 l'autre. On les appelle des propri\u00e9t\u00e9s navigationnelles.</p> <p>// les clients dont le titre est Mr class\u00e9s par ordre d\u00e9croissant des noms</p> <p>R\u00e9sultats\u00a0:</p> <p>LINQ</p> <pre><code>from client in CLIENTS where client.TITRE==\"Mr\" orderby client.NOM descending  select client\n</code></pre> <p>Lambda</p> <pre><code>CLIENTS\n.Where (client =&gt; (client.TITRE == \"Mr\"))\n.OrderByDescending (client =&gt; client.NOM)\n</code></pre> <p>SQL</p> <pre><code>-- Region Parameters\nDECLARE @p0 NVarChar(1000) = 'Mr'\n-- EndRegion\nSELECT [t0].[ID], [t0].[TITRE], [t0].[NOM], [t0].[PRENOM], [t0].[TIMESTAMP]\nFROM [CLIENTS] AS [t0]\nWHERE [t0].[TITRE] = @p0\nORDER BY [t0].[NOM] DESC\n</code></pre> <p>// tous les cr\u00e9neaux horaires avec le m\u00e9decin associ\u00e9</p> <p>R\u00e9sultats (partiels)\u00a0:</p> <p>LINQ</p> <pre><code>from creneau in CRENEAUXes select new { hd=creneau.HDEBUT, md=creneau.MDEBUT, hf=creneau.HFIN, mf=creneau.MFIN, medecin=creneau.MEDECIN}\n</code></pre> <p>Lambda</p><p>SQL</p> <pre><code>SELECT [t0].[HDEBUT] AS [hd], [t0].[MDEBUT] AS [md], [t0].[HFIN] AS [hf], [t0].[MFIN] AS [mf], [t1].[ID], [t1].[TITRE], [t1].[NOM], [t1].[PRENOM], [t1].[TIMESTAMP]\nFROM [CRENEAUX] AS [t0]\nINNER JOIN [MEDECINS] AS [t1] ON [t1].[ID] = [t0].[MEDECIN_ID]\n</code></pre> <p>// tous les rv avec le client et le m\u00e9decin associ\u00e9s</p> <p>R\u00e9sultats\u00a0:</p> <p>LINQ</p> <pre><code>from rv in RVS select new { rv=rv.CLIENT, medecin=rv.CRENEAU.MEDECIN}\n</code></pre> <p>Lambda</p><p>SQL</p> <pre><code>SELECT [t1].[ID], [t1].[TITRE], [t1].[NOM], [t1].[PRENOM], [t1].[TIMESTAMP], [t3].[ID] AS [ID2], [t3].[TITRE] AS [TITRE2], [t3].[NOM] AS [NOM2], [t3].[PRENOM] AS [PRENOM2], [t3].[TIMESTAMP] AS [TIMESTAMP2]\nFROM [RVS] AS [t0]\nINNER JOIN [CLIENTS] AS [t1] ON [t1].[ID] = [t0].[CLIENT_ID]\nINNER JOIN [CRENEAUX] AS [t2] ON [t2].[ID] = [t0].[CRENEAU_ID]\nINNER JOIN [MEDECINS] AS [t3] ON [t3].[ID] = [t2].[MEDECIN_ID]\n</code></pre> <p>// les m\u00e9decins n'ayant pas de Rdv</p> <p>R\u00e9sultats\u00a0:</p> <p>LINQ</p> <p>Lambda</p><p>SQL</p> <pre><code>SELECT [t0].[ID], [t0].[TITRE], [t0].[NOM], [t0].[PRENOM], [t0].[TIMESTAMP]\nFROM [MEDECINS] AS [t0]\nWHERE NOT (EXISTS(\n    SELECT NULL AS [EMPTY]\n    FROM [RVS] AS [t1]\n    INNER JOIN [CRENEAUX] AS [t2] ON [t2].[ID] = [t1].[CRENEAU_ID]\n    INNER JOIN [MEDECINS] AS [t3] ON [t3].[ID] = [t2].[MEDECIN_ID]\n    WHERE [t3].[ID] = [t0].[ID]\n    ))\n</code></pre> <p>Il n'y a pas de requ\u00eate LINQ pour cette demande. Il faut passer par des expressions lambda. Celle-ci se lit de la fa\u00e7on suivante\u00a0: je prends la collection des m\u00e9decins (MEDECINS) et je ne garde (Where) que les m\u00e9decins (m) tels que je ne suis pas capable de trouver dans la collection des rendez-vous (RVS) un rendez-vous (rv) avec ce m\u00e9decin (m).</p> <p>// cr\u00e9neaux horaires de Mme P\u00e9lissier</p> <p>R\u00e9sultats (partiels)\u00a0:</p> <p>LINQ</p> <pre><code>from creneau in CRENEAUXes where creneau.MEDECIN.NOM==\"Pelissier\" select creneau\n</code></pre> <p>Lambda</p><p>SQL</p> <pre><code>-- Region Parameters\nDECLARE @p0 NVarChar(1000) = 'Pelissier'\n-- EndRegion\nSELECT [t0].[ID], [t0].[HDEBUT], [t0].[MDEBUT], [t0].[HFIN], [t0].[MFIN], [t0].[MEDECIN_ID], [t0].[TIMESTAMP]\nFROM [CRENEAUX] AS [t0]\nINNER JOIN [MEDECINS] AS [t1] ON [t1].[ID] = [t0].[MEDECIN_ID]\nWHERE [t1].[NOM] = @p0\n</code></pre> <p>// nombre de Rdv de Mme P\u00e9lissier le 08/10/2012</p> <p>R\u00e9sultats\u00a0:</p> <p>LINQ</p> <pre><code>(from rv in RVS where rv.CRENEAU.MEDECIN.NOM==\"Pelissier\" &amp;&amp; rv.JOUR==new DateTime(2012,10,08)  select rv).Count()\n</code></pre> <p>Lambda</p> <p>SQL</p> <pre><code>-- Region Parameters\nDECLARE @p0 NVarChar(1000) = 'Pelissier'\nDECLARE @p1 DateTime = '2012-10-08 00:00:00.000'\n-- EndRegion\nSELECT COUNT(*) AS [value]\nFROM [RVS] AS [t0]\nINNER JOIN [CRENEAUX] AS [t1] ON [t1].[ID] = [t0].[CRENEAU_ID]\nINNER JOIN [MEDECINS] AS [t2] ON [t2].[ID] = [t1].[MEDECIN_ID]\nWHERE ([t2].[NOM] = @p0) AND ([t0].[JOUR] = @p1)\n</code></pre> <p>// liste des clients ayant pris Rdv avec Mme P\u00e9lissier le 08/10/2012</p> <p>R\u00e9sultats\u00a0:</p> <p>LINQ</p> <pre><code>from rv in RVS where (rv.JOUR==new DateTime(2012,10,08) &amp;&amp; rv.CRENEAU.MEDECIN.NOM==\"Pelissier\") select rv.CLIENT\n</code></pre> <p>Lambda</p><p>SQL</p> <pre><code>-- Region Parameters\nDECLARE @p0 DateTime = '2012-10-08 00:00:00.000'\nDECLARE @p1 NVarChar(1000) = 'Pelissier'\n-- EndRegion\nSELECT [t3].[ID], [t3].[TITRE], [t3].[NOM], [t3].[PRENOM], [t3].[TIMESTAMP]\nFROM [RVS] AS [t0]\nINNER JOIN [CRENEAUX] AS [t1] ON [t1].[ID] = [t0].[CRENEAU_ID]\nINNER JOIN [MEDECINS] AS [t2] ON [t2].[ID] = [t1].[MEDECIN_ID]\nINNER JOIN [CLIENTS] AS [t3] ON [t3].[ID] = [t0].[CLIENT_ID]\nWHERE ([t0].[JOUR] = @p0) AND ([t2].[NOM] = @p1)\n</code></pre> <p>// nombre de cr\u00e9neaux horaires par m\u00e9decin</p> <p>R\u00e9sultats\u00a0:</p> <p>LINQ</p> <pre><code>from creneau in CRENEAUXes \ngroup creneau by creneau.MEDECIN into creneauxMedecin \nselect new { nom=creneauxMedecin.Key.NOM, prenom=creneauxMedecin.Key.PRENOM, nbRv=creneauxMedecin.Count()}\n</code></pre> <p>Lambda</p><p>SQL</p> <pre><code>SELECT [t2].[NOM] AS [nom], [t2].[PRENOM] AS [prenom], [t1].[value] AS [nbRv]\nFROM (\n    SELECT COUNT(*) AS [value], [t0].[MEDECIN_ID]\n    FROM [CRENEAUX] AS [t0]\n    GROUP BY [t0].[MEDECIN_ID]\n    ) AS [t1]\nINNER JOIN [MEDECINS] AS [t2] ON [t2].[ID] = [t1].[MEDECIN_ID]\n</code></pre>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#355-modification-dune-entite-attachee-au-contexte-de-persistance","title":"3.5.5. Modification d'une entit\u00e9 attach\u00e9e au contexte de persistance","text":"<p>Nous avons vu les op\u00e9rations suivantes sur le contexte de persistance\u00a0:</p> <ul> <li>ajouter un \u00e9l\u00e9ment au contexte ([dbContext].[DbSet].Add)\u00a0;</li> <li>supprimer un \u00e9l\u00e9ment du contexte ([dbContext].[DbSet].Remove)\u00a0;</li> <li>requ\u00eater un contexte avec des requ\u00eates LINQ.</li> </ul> <p>Lorsqu'on veut synchroniser le contexte avec la base, on \u00e9crit [dbContext].SaveChanges().</p> <p>Le code [ModifyAttachedEntity] illustre la modification d'une entit\u00e9 attach\u00e9e au contexte\u00a0:</p> <pre><code>using System;\nusing System.Data;\nusing System.Linq;\nusing RdvMedecins.Entites;\nusing RdvMedecins.Models;\n\nnamespace RdvMedecins_01\n{\n  class ModifyAttachedEntity\n  {\n    static void Main(string[] args)\n    {\n      Client client1, client2, client3;\n      // 1er contexte\n      using (var context = new RdvMedecinsContext())\n      {\n        // on vide la base actuelle\n        foreach (var client in context.Clients)\n        {\n          context.Clients.Remove(client);\n        }\n        foreach (var medecin in context.Medecins)\n        {\n          context.Medecins.Remove(medecin);\n        }\n        // on ajoute un client\n        client1 = new Client { Nom = \"xx\", Prenom = \"xx\", Titre = \"xx\" };\n        context.Clients.Add(client1);\n        // suivi\n        Console.WriteLine(\"client1--avant\");\n        Console.WriteLine(client1);\n        // sauvegarde contexte\n        context.SaveChanges();\n        // suivi\n        Console.WriteLine(\"client1--apr\u00e8s\");\n        Console.WriteLine(client1);\n      }\n      // 2i\u00e8me contexte\n      using (var context = new RdvMedecinsContext())\n      {\n        // on r\u00e9cup\u00e8re client1 dans client2\n        client2 = context.Clients.Find(client1.Id);\n        // suivi\n        Console.WriteLine(\"client2\");\n        Console.WriteLine(client2);\n        // on modifie client2\n        client2.Nom = \"yy\";\n        // sauvegarde contexte\n        context.SaveChanges();\n      }\n      // 3i\u00e8me contexte\n      using (var context = new RdvMedecinsContext())\n      {\n        // on r\u00e9cup\u00e8re client2 dans client3\n        client3 = context.Clients.Find(client2.Id);\n        // suivi\n        Console.WriteLine(\"client3\");\n        Console.WriteLine(client3);\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 15\u00a0: ouverture contexte de l'application\u00a0;</li> <li>lignes 18-25\u00a0: le contexte est vid\u00e9. Tr\u00e8s exactement, toutes les entit\u00e9s sont amen\u00e9es dans le contexte \u00e0 partir de la base de donn\u00e9es puis passent dans un \u00e9tat \"\u00a0supprim\u00e9\u00a0\". On notera qu'\u00e0 ce stade la base n'a pas boug\u00e9. Tant que le contexte n'est pas synchronis\u00e9 avec la base, celle-ci ne change pas. On se rappelle que supprimer les entit\u00e9s [Medecin] et [Client] suffit \u00e0 vider la base par le jeu des suppressions en cascade\u00a0;</li> <li>lignes 27-28\u00a0: un nouveau client est ajout\u00e9 \u00e0 la base\u00a0;</li> <li>lignes 30-31\u00a0: on l'affiche avant sa sauvegarde dans la base\u00a0;</li> <li>ligne 33\u00a0: on synchronise le contexte avec la base. Les entit\u00e9es marqu\u00e9es dans un \u00e9tat \"\u00a0supprim\u00e9\u00a0\" vont faire l'objet d'une op\u00e9ration SQL DELETE, l'entit\u00e9 ajout\u00e9e d'une op\u00e9ration SQL INSERT\u00a0;</li> <li>lignes 35-36\u00a0: on affiche le client apr\u00e8s la synchronisation avec la base\u00a0;</li> </ul> <p>Le r\u00e9sultat obtenu \u00e0 la console est le suivant\u00a0:</p> <pre><code>client1--avant\nClient[,xx,xx,xx,]\nclient1--apr\u00e8s\nClient[16,xx,xx,xx,000000132209]\n</code></pre> <p>On notera les points suivants\u00a0:</p> <ul> <li>avant la synchronisation avec la base, le client n'a ni cl\u00e9 primaire, ni timestamp,</li> <li>apr\u00e8s la synchronisation, il les a. On rappelle ici, que la cl\u00e9 primaire a \u00e9t\u00e9 configur\u00e9e pour \u00eatre g\u00e9n\u00e9r\u00e9e par SQL Server. De m\u00eame ce SGBD g\u00e9n\u00e8re automatiquement le timestamp\u00a0;</li> <li>ligne 37\u00a0: le contexte de persistance est ferm\u00e9. Les entit\u00e9s qu'il contenait deviennent \"\u00a0d\u00e9tach\u00e9es\u00a0\". Elles existent en tant qu'objets mais pas en tant qu'entit\u00e9s attach\u00e9es \u00e0 un contexte de persistance\u00a0;</li> <li>ligne 39\u00a0: on red\u00e9marre un nouveau contexte vide\u00a0;</li> <li>ligne 42\u00a0: on r\u00e9cup\u00e8re le client directement dans la base via sa cl\u00e9 primaire. Il est alors amen\u00e9 dans le contexte. S'il n'est pas trouv\u00e9, la m\u00e9thode Find rend le pointeur null\u00a0;</li> <li>lignes 48-49\u00a0: on l'affiche\u00a0;</li> </ul> <p>Cela donne le r\u00e9sultat suivant\u00a0:</p> <pre><code>client2\nClient[16,xx,xx,xx,000000132209]\n</code></pre> <ul> <li>ligne 47\u00a0: on le modifie\u00a0;</li> <li>ligne 49\u00a0: on synchronise le contexte avec la base. EF va d\u00e9tecter que certains \u00e9l\u00e9ments du contexte ont \u00e9t\u00e9 modifi\u00e9s depuis qu'ils y ont \u00e9t\u00e9 amen\u00e9s. Pour ces \u00e9l\u00e9ments, il va g\u00e9n\u00e9rer des ordres SQL UPDATE sur la base. Donc ici, la synchronisation va consister en un unique ordre UPDATE\u00a0;</li> <li>ligne 50\u00a0: le deuxi\u00e8me contexte est ferm\u00e9. L'entit\u00e9 client2 qui \u00e9tait attach\u00e9e au contexte devient maintenant d\u00e9tach\u00e9e de celui-ci\u00a0;</li> <li>ligne 52\u00a0: on ouvre un troisi\u00e8me contexte vide\u00a0;</li> <li>ligne 55\u00a0: on y am\u00e8ne de nouveau l'unique client de la base. On veut voir si la modification faite sur lui dans le contexte pr\u00e9c\u00e9dent a \u00e9t\u00e9 r\u00e9percut\u00e9e dans la base\u00a0;</li> <li>lignes 57-58\u00a0: on affiche le client. Cela donne le r\u00e9sultat suivant\u00a0:</li> </ul> <pre><code>client3\nClient[16,xx,xx,yy,000000132210]\n</code></pre> <p>Le nom du client a bien \u00e9t\u00e9 modifi\u00e9 en base. On notera avec int\u00e9r\u00eat que son timestamp a \u00e9t\u00e9 mis \u00e0 jour.</p> <ul> <li>ligne 59\u00a0: on ferme le contexte. Au passage, on notera que contrairement aux deux fois pr\u00e9c\u00e9dentes, on n'a pas eu besoin auparavant de synchroniser le contexte avec la base (SaveChanges) car le contexte n'avait pas \u00e9t\u00e9 modifi\u00e9.</li> </ul>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#356-gestion-des-entites-detachees","title":"3.5.6. Gestion des entit\u00e9s d\u00e9tach\u00e9es","text":"<p>Revenons \u00e0 l'architecture en couches d'une application telle que celle de l'\u00e9tude de cas\u00a0:</p> <p>La couche [DAO] utilise l'ORM EF5 pour acc\u00e9der aux donn\u00e9es. Nous avons les briques de base de cette couche. Chaque m\u00e9thode ouvrira un contexte de persistance, fera dessus les op\u00e9rations n\u00e9cessaires (insertion, modification, suppression, requ\u00eatage) puis le fermera. Les entit\u00e9s g\u00e9r\u00e9es par la couche [DAO] vont remonter jusqu'\u00e0 la couche web ASP.NET. Dans cette couche, elles sont hors contexte de persistance donc d\u00e9tach\u00e9es. Dans la couche web, un utilisateur peut modifier ces entit\u00e9s (ajout, modification, suppression). Lorsqu'elles reviennent \u00e0 la couche [DAO], elles sont toujours d\u00e9tach\u00e9es. Or la couche [DAO] va devoir r\u00e9percuter les modifications faites par l'utilisateur dans la base. Il va donc devoir travailler avec des entit\u00e9s d\u00e9tach\u00e9es. Voyons les trois cas possibles\u00a0:</p> <p>Ajouter une entit\u00e9 d\u00e9tach\u00e9e</p> <p>C'est le cas normal pour un ajout. Il suffit d'ajouter (Add) l'entit\u00e9 d\u00e9tach\u00e9e au contexte en s'assurant qu'elle a une cl\u00e9 primaire \u00e9gale \u00e0 null.</p> <p>Modifier une entit\u00e9 d\u00e9tach\u00e9e</p> <p>On peut utiliser le code suivant\u00a0:</p> <pre><code>[DbContext].Entry(entit\u00e9-d\u00e9tach\u00e9e).State=EntityState.Modified\u00a0;\n</code></pre> <ul> <li>la m\u00e9thode [DbContext].Entry(entit\u00e9-d\u00e9tach\u00e9e) va mettre l'entit\u00e9 dans le contexte\u00a0;</li> <li>l'\u00e9tat de cette entit\u00e9 est mis \u00e0 \"\u00a0modifi\u00e9\u00a0\" afin qu'elle fasse l'objet d'un ordre SQL UPDATE.</li> </ul> <p>Supprimer une entit\u00e9 d\u00e9tach\u00e9e</p> <p>On peut utiliser le code suivant\u00a0:</p> <pre><code>Entity e=[DbContext].[DbSet].Find(cl\u00e9 primaire de l'entit\u00e9 d\u00e9tach\u00e9e)\u00a0;\n[DbContext].[DbSet].Remove(e)\u00a0;\n</code></pre> <ul> <li>ligne  1\u00a0: on met dans le contexte l'entit\u00e9 de m\u00eame cl\u00e9 primaire que l'entit\u00e9 d\u00e9tach\u00e9e\u00a0;</li> <li>ligne 2\u00a0: on la supprime\u00a0:</li> </ul> <p>On notera que cela n\u00e9cessite en base un SELECT suivi d'un DELETE alors que normalement le seul DELETE est suffisant. On peut suivre \u00e9galement l'exemple de la modification d'une entit\u00e9 d\u00e9tach\u00e9e et \u00e9crire\u00a0:</p> <pre><code>[DbContext].Entry(entit\u00e9-d\u00e9tach\u00e9e).State=EntityState.Deleted\u00a0;\n</code></pre> <p>Comme je n'ai pas pu mettre en oeuvre de logs sur les op\u00e9rations SQL faites sur la base, je ne sais pas si une m\u00e9thode est \u00e0 conseiller plut\u00f4t que l'autre.</p> <p>Voici un exemple\u00a0:</p> <p>Le code du programme [ModifyDetachedEntities] est le suivant\u00a0:</p> <pre><code>using System;\nusing System.Data;\nusing RdvMedecins.Entites;\nusing RdvMedecins.Models;\n\nnamespace RdvMedecins_01\n{\n  class ModifyDetachedEntities\n  {\n    static void Main(string[] args)\n    {\n      Client client1;\n\n      // on vide la base actuelle\n      Erase();\n      // on ajoute un client\n      using (var context = new RdvMedecinsContext())\n      {\n        // cr\u00e9ation client\n        client1 = new Client { Titre = \"x\", Nom = \"x\", Prenom = \"x\" };\n        // ajout du client au contexte\n        context.Clients.Add(client1);\n        // on sauvegarde le contexte\n        context.SaveChanges();\n      }\n      // affichage base\n      Dump(\"1-----------------------------\");\n      // client1 n'est pas dans le contexte - on le modifie\n      client1.Nom = \"y\";\n      // nouveau contexte\n      using (var context = new RdvMedecinsContext())\n      {\n        // ici, on a un contexte vide\n        // on met client1 dans le contexte dans un \u00e9tat modifi\u00e9\n        context.Entry(client1).State = EntityState.Modified;\n        // on sauvegarde le contexte\n        context.SaveChanges();\n      }\n      // affichage base\n      Dump(\"2-----------------------------\");\n      // suppression entit\u00e9 hors contexte\n      using (var context = new RdvMedecinsContext())\n      {\n        // ici, on a un nouveau contexte vide\n        // on met client1 dans le contexte dans un \u00e9tat supprim\u00e9\n        context.Entry(client1).State = EntityState.Deleted;\n        // on sauvegarde le contexte\n        context.SaveChanges();\n      }\n      // affichage base\n      Dump(\"3-----------------------------\");\n    }\n\n    static void Erase()\n    {\n      // vide la base\n      using (var context = new RdvMedecinsContext())\n      {\n        foreach (var client in context.Clients)\n        {\n          context.Clients.Remove(client);\n        }\n        foreach (var medecin in context.Medecins)\n        {\n          context.Medecins.Remove(medecin);\n        }\n        // on sauvegarde le contexte\n        context.SaveChanges();\n      }\n    }\n\n    static void Dump(string str)\n    {\n      Console.WriteLine(str);\n      // affiche la base\n      using (var context = new RdvMedecinsContext())\n      {\n        foreach (var rv in context.Rvs)\n        {\n          Console.WriteLine(rv);\n        }\n        foreach (var creneau in context.Creneaux)\n        {\n          Console.WriteLine(creneau);\n        }\n        foreach (var client in context.Clients)\n        {\n          Console.WriteLine(client);\n        }\n        foreach (var medecin in context.Medecins)\n        {\n          Console.WriteLine(medecin);\n        }\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 15\u00a0: la base est effac\u00e9e\u00a0;</li> <li>lignes 17-25\u00a0: un client est ajout\u00e9 en base\u00a0;</li> <li>ligne 27\u00a0: affiche le contenu de la base\u00a0;</li> </ul> <pre><code>1-----------------------------\nClient[20,x,x,x,0000011209]\n</code></pre> <ul> <li>apr\u00e8s la ligne 25, le contexte de persistance n'existe plus. Il n'y a donc plus d'entit\u00e9s attach\u00e9es. L'entit\u00e9 client1 est pass\u00e9e dans l'\u00e9tat \"\u00a0d\u00e9tach\u00e9\u00a0\"\u00a0;</li> <li>ligne 29\u00a0: on modifie le nom de l'entit\u00e9 d\u00e9tach\u00e9e\u00a0;</li> <li>ligne 31\u00a0: on ouvre un nouveau contexte vide\u00a0;</li> <li>ligne 35\u00a0: l'entit\u00e9 d\u00e9tach\u00e9e client1 est mise dans le contexte dans un \u00e9tat \"\u00a0modifi\u00e9\u00a0\"\u00a0;</li> <li>ligne 37\u00a0: le contexte est synchronis\u00e9 avec la base\u00a0;</li> <li>ligne 38\u00a0: il est ferm\u00e9\u00a0;</li> <li>ligne 40\u00a0: la base est affich\u00e9e\u00a0;</li> </ul> <pre><code>2-----------------------------\nClient[20,x,x,y,0000011210]\n</code></pre> <p>Le nom du client a bien \u00e9t\u00e9 modifi\u00e9 en base. On notera que le timestamp a \u00e9t\u00e9 mis \u00e0 jour\u00a0;</p> <ul> <li>ligne 42\u00a0: ouverture d'un nouveau contexte vide\u00a0;</li> <li>ligne 46\u00a0: l'entit\u00e9 d\u00e9tach\u00e9e client1 est mise dans le contexte dans un \u00e9tat \"supprim\u00e9\"\u00a0;</li> <li>ligne 48\u00a0: le contexte est synchronis\u00e9 avec la base\u00a0;</li> <li>ligne 49\u00a0: il est ferm\u00e9\u00a0;</li> <li>ligne 51\u00a0: la base est affich\u00e9e\u00a0;</li> </ul> <pre><code>3-----------------------------\n</code></pre> <p>L'entit\u00e9 a bien \u00e9t\u00e9 supprim\u00e9e en base.</p> <p>Maintenant, nous voyons les deux modes de chargement des d\u00e9pendances d'une entit\u00e9\u00a0: Lazy et Eager Loading.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#357-lazy-et-eager-loading","title":"3.5.7. Lazy et Eager Loading","text":"<p>Reprenons le sch\u00e9ma des d\u00e9pendances plusieurs \u00e0 un de nos quatre entit\u00e9s\u00a0:</p> <p>Ci-dessus, l'entit\u00e9 [Creneau] a une propri\u00e9t\u00e9 navigationnelle [Creneau.Medecin] vers l'entit\u00e9 [Medecin]. On appelle cela une d\u00e9pendance. Nous avons vu qu'il y avait \u00e9galement des d\u00e9pendances un \u00e0 plusieurs. Le principe qui va \u00eatre expliqu\u00e9 s'applique \u00e9galement \u00e0 elles.</p> <p>Par d\u00e9faut, EF 5 est en mode Lazy Loading\u00a0: lorsqu'il am\u00e8ne une entit\u00e9 dans le contexte de persistance depuis la base, il n'am\u00e8ne pas ses d\u00e9pendances. Celles-ci seront amen\u00e9es lorsqu'elles seront utilis\u00e9es la premi\u00e8re fois. C'est une mesure de bon sens. Si ce n'\u00e9tait pas le cas, amener dans le contexte les rendez-vous am\u00e8nerait d'apr\u00e8s les d\u00e9pendances ci-dessus\u00a0:</p> <ul> <li>les entit\u00e9s [Creneau] li\u00e9es aux rendez-vous\u00a0;</li> <li>les entit\u00e9s [Medecin] li\u00e9es \u00e0 ces cr\u00e9neaux\u00a0;</li> <li>les entit\u00e9s [Clients] li\u00e9es aux rendez-vous.</li> </ul> <p>Parfois cependant, on a besoin d'une entit\u00e9 et de ses d\u00e9pendances. Nous allons illustrer les deux modes de chargement.</p> <p>Le code de [LazyEagerLoading] est le suivant\u00a0:</p> <pre><code>using RdvMedecins.Entites;\nusing RdvMedecins.Models;\nusing System;\nusing System.Linq;\n\nnamespace RdvMedecins_01\n{\n  class LazyEagerLoading\n  {\n    // les entit\u00e9s\n    static Medecin[] medecins;\n    static Client[] clients;\n    static Creneau[] creneaux;\n\n    static void Main(string[] args)\n    {\n      // on initialise la base      \n      InitBase();\n      Console.WriteLine(\"Initialisation termin\u00e9e\");\n      // eager loading\n      Creneau creneau;\n      int idCreneau = (int)creneaux[0].Id;\n      using (var context = new RdvMedecinsContext())\n      {\n        // creneau n\u00b0 0\n        creneau = context.Creneaux.Include(\"Medecin\").Single&lt;Creneau&gt;(c =&gt; c.Id == idCreneau);\n        Console.WriteLine(creneau.ShortIdentity());\n      }\n      // affichage d\u00e9pendance\n      try\n      {\n        Console.WriteLine(\"M\u00e9decin={0}\", creneau.Medecin);\n      }\n      catch (Exception e)\n      {\n        Console.WriteLine(\"L'erreur 1 suivante s'est produite : {0}\", e);\n      }\n      // lazy loading - mode par d\u00e9faut\n      using (var context = new RdvMedecinsContext())\n      {\n        // creneau n\u00b0 0\n        creneau = context.Creneaux.Single&lt;Creneau&gt;(c =&gt; c.Id == idCreneau);\n        Console.WriteLine(creneau.ShortIdentity());\n      }\n      // affichage d\u00e9pendance\n      try\n      {\n        Console.WriteLine(\"M\u00e9decin={0}\", creneau.Medecin);\n      }\n      catch (Exception e)\n      {\n        Console.WriteLine(\"L'erreur 2 suivante s'est produite : {0}\", e);\n      }\n\n    }\n\n    static void InitBase()\n    {\n      // on initialise la base\n      using (var context = new RdvMedecinsContext())\n      {\n        // on vide la base actuelle\n        ...\n        // on initialise la base\n        // les clients\n        clients = new Client[] {\n        new Client { Titre = \"Mr\", Nom = \"Martin\", Prenom = \"Jules\" },\n        new Client { Titre = \"Mme\", Nom = \"German\", Prenom = \"Christine\" },\n        new Client { Titre = \"Mr\", Nom = \"Jacquard\", Prenom = \"Jules\" },\n        new Client { Titre = \"Melle\", Nom = \"Bistrou\", Prenom = \"Brigitte\" }\n     };\n...\n        // les Rdv\n        context.Rvs.Add(new Rv { Jour = new System.DateTime(2012, 10, 8), Client = clients[0], Creneau = creneaux[0] });\n        // on sauve le contexte de persistance\n        context.SaveChanges();\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 18\u00a0: on part d'une base connue, celle utilis\u00e9e jusqu'\u00e0 maintenant. Apr\u00e8s cette op\u00e9ration, les tableaux des lignes 11-13 sont remplis d'entit\u00e9s d\u00e9tach\u00e9es\u00a0;</li> <li>lignes 21-22\u00a0: on s'int\u00e9resse au premier cr\u00e9neau et au m\u00e9decin associ\u00e9\u00a0;</li> <li>ligne 23\u00a0: nouveau contexte\u00a0;</li> <li>ligne 26\u00a0: on met le cr\u00e9neau dans le contexte avec sa d\u00e9pendance (eager loading). Parce que ce n'est pas le mode par d\u00e9faut, il faut demander explicitement cette d\u00e9pendance. C'est la m\u00e9thode Include qui permet cela. Son param\u00e8tre est le nom de la d\u00e9pendance dans l'entit\u00e9 amen\u00e9e dans le contexte. La requ\u00eate qui am\u00e8ne l'entit\u00e9 dans le contexte utilise des expressions lambda. La m\u00e9thode Single permet de pr\u00e9ciser une condition permettant de ramener une unique entit\u00e9. Ici, on recherche en base l'entit\u00e9 [Creneau] qui a la cl\u00e9 primaire du cr\u00e9neau n\u00b0 0\u00a0;</li> <li>ligne 27\u00a0: on affiche l'entit\u00e9 ramen\u00e9e. Rappelons les deux m\u00e9thodes d'\u00e9criture utilis\u00e9es dans les entit\u00e9s\u00a0:</li> </ul> <pre><code>// signature\n    public override string ToString()\n    {\n      return String.Format(\"Creneau[{0},{1},{2},{3},{4}, {5},{6}]\", Id, Hdebut, Mdebut, Hfin, Mfin, Medecin, dump(Timestamp));\n    }\n\n   // signature courte\n    public string ShortIdentity()\n    {\n      return String.Format(\"Creneau[{0},{1},{2},{3},{4}, {5}, {6}]\", Id, Hdebut, Mdebut, Hfin, Mfin, MedecinId, dump(Timestamp));\n    }\n</code></pre> <ul> <li>lignes 2-5\u00a0: la m\u00e9thode [ToString] affiche la d\u00e9pendance [Medecin]. Si celle-ci n'est pas d\u00e9j\u00e0 dans le contexte, elle sera cherch\u00e9e en base pour l'y mettre\u00a0;</li> <li>lignes 8-11\u00a0: la m\u00e9thode [ShortIdentity] n'affiche pas la d\u00e9pendance [Medecin]. Elle ne sera donc pas recherch\u00e9e en base si elle n'est pas dans le contexte\u00a0;</li> </ul> <p>A ce stade, l'affichage console est le suivant\u00a0:</p> <pre><code>Initialisation termin\u00e9e\nCreneau[181,8,0,8,20, 21, 00000195150]\n</code></pre> <ul> <li>ligne 28\u00a0: le contexte est ferm\u00e9\u00a0;</li> <li>lignes 30-37\u00a0: on essaie d'\u00e9crire la d\u00e9pendance [Medecin] de l'entit\u00e9. On rappelle le fonctionnement en Lazy Loading\u00a0: une d\u00e9pendance est charg\u00e9e lors de sa premi\u00e8re utilisation si elle n'est pas pr\u00e9sente.  Ici, normalement elle est pr\u00e9sente. L'affichage est le suivant\u00a0:</li> </ul> <pre><code>M\u00e9decin=Medecin[21,Mme,Marie,Pelissier,00000195149]\n</code></pre> <ul> <li>lignes 39-44\u00a0: dans le cadre d'un nouveau contexte, le cr\u00e9neau n\u00b0 0 est de nouveau cherch\u00e9 en base et amen\u00e9 dans le contexte. Ici, la d\u00e9pendance [Medecin] n'est pas demand\u00e9e explicitement. Elle ne sera donc pas amen\u00e9e (Lazy Loading)\u00a0;</li> <li>ligne 43\u00a0: l'affichage de l'identit\u00e9 courte du cr\u00e9neau est la suivante\u00a0:</li> </ul> <pre><code>Creneau[181,8,0,8,20, 21, 00000195150]\n</code></pre> <p>Ici, il est important d'utiliser ShortIdentity au lieu de ToString pour afficher l'entit\u00e9. Si on utilise ToString, la d\u00e9pendance [Medecin] va \u00eatre affich\u00e9e et pour cela elle va \u00eatre cherch\u00e9e en base. Or on ne veut pas cela.</p> <ul> <li>ligne 44\u00a0: le contexte est ferm\u00e9\u00a0;</li> <li>lignes 46-53\u00a0: on essaie d'afficher la d\u00e9pendance de l'entit\u00e9. Il est important de faire cela hors contexte sinon elle sera recherch\u00e9e en base et trouv\u00e9e. Ici on est hors contexte. L'entit\u00e9 [Creneau] est d\u00e9tach\u00e9e et sa d\u00e9pendance [Medecin] est absente (Lazy Loading). Que va-t-il se passer\u00a0? L'affichage \u00e9cran est le suivant\u00a0:</li> </ul> <pre><code>L'erreur 2 suivante s'est produite : System.ObjectDisposedException: L'instance ObjectContext a \u00e9t\u00e9 supprim\u00e9e et ne peut plus \u00eatre utilis\u00e9e pour les op\u00e9rations qui requi\u00e8rent une connexion.\n   \u00e0 System.Data.Objects.ObjectContext.EnsureConnection()\n   \u00e0 System.Data.Objects.ObjectQuery`1.GetResults(Nullable`1 forMergeOption)\n   \u00e0 System.Data.Objects.ObjectQuery`1.Execute(MergeOption mergeOption)\n   \u00e0 System.Data.Objects.DataClasses.EntityReference`1.Load(MergeOption mergeOption)\n   \u00e0 System.Data.Objects.DataClasses.RelatedEnd.Load()\n   \u00e0 System.Data.Objects.DataClasses.RelatedEnd.DeferredLoad()\n   \u00e0 System.Data.Objects.Internal.LazyLoadBehavior.LoadProperty[TItem](TItem propertyValue, String relationshipName, String targetRoleName, Boolean mustBeNull,Object wrapperObject)\n   \u00e0 System.Data.Objects.Internal.LazyLoadBehavior.&lt;&gt;c__DisplayClass7`2.&lt;GetInterceptorDelegate&gt;b__2(TProxy proxy, TItem item)\n   \u00e0 System.Data.Entity.DynamicProxies.Creneau_AF14A89855AD9B7E5ABA4A877B4989B2F8B3F7ECA154E3FEC02BA722002773E4.get_Medecin()\n   \u00e0 RdvMedecins_01.LazyEagerLoading.Main(String[] args) dans d:\\data\\istia-1213\\c#\\dvp\\Entity Framework\\RdvMedecins\\RdvMedecins-SqlServer-01\\LazyEagerLoading.cs:ligne 48\n</code></pre> <p>EF a trouv\u00e9 la d\u00e9pendance [Medecin] absente. Il a voulu la charger mais le contexte \u00e9tant ferm\u00e9, cette op\u00e9ration n'\u00e9tait plus possible. On m\u00e9morisera cette exception [System.ObjectDisposedException] car est elle caract\u00e9ristique du chargement d'une d\u00e9pendance en-dehors d'un contexte ouvert.</p> <p>Maintenant examinons la concurrence d'acc\u00e8s aux entit\u00e9s.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#358-concurrence-dacces-aux-entites","title":"3.5.8. Concurrence d'acc\u00e8s aux entit\u00e9s","text":"<p>Revenons sur la d\u00e9finition de l'entit\u00e9 [Client]\u00a0:</p> <pre><code>public class Client\n  {\n    // data\n    [Key]\n    [Column(\"ID\")]\n    public int? Id { get; set; }\n    [Required]\n    [MaxLength(5)]\n    [Column(\"TITRE\")]\n    public string Titre { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"NOM\")]\n    public string Nom { get; set; }\n    [Required]\n    [MaxLength(30)]\n    [Column(\"PRENOM\")]\n    public string Prenom { get; set; }\n    // les Rvs du client\n    public ICollection&lt;Rv&gt; Rvs { get; set; }\n    [Column(\"TIMESTAMP\")]\n    [Timestamp]\n    public byte[] Timestamp { get; set; }\n\n    // signature\n    ...\n  }\n</code></pre> <p>Nous allons nous int\u00e9resser au champ [Timestamp] de la ligne 23. Nous savons que sa valeur est g\u00e9n\u00e9r\u00e9e par le SGBD. Nous avons dit \u00e9galement que l'annotation [Timestamp] de la ligne 22 faisait que EF 5 utilisait le champ annot\u00e9 pour g\u00e9rer les concurrences d'acc\u00e8s aux entit\u00e9s. Rappelons ce qu'est une gestion de concurrence d'acc\u00e8s\u00a0:</p> <ul> <li>un processus P1 lit une ligne L de la table [MEDECINS] au temps T1. La ligne a le timestamp TS1\u00a0;</li> <li>un processus P2 lit la m\u00eame ligne L de la table [MEDECINS] au temps T2. La ligne a le timestamp TS1 parce que le processus P1 n'a pas encore valid\u00e9 sa modification\u00a0;</li> <li>le processus P1 valide sa modification de la ligne L. Le timestamp de la ligne L passe alors \u00e0 TS2\u00a0;</li> <li>le processus P2 valide sa modification de la ligne L. L'ORM lance alors une exception car le processus P2 a un timestamp TS1 de la ligne L diff\u00e9rent du timestamp TS2 trouv\u00e9 en base.</li> </ul> <p>On appelle cela la gestion optimiste des acc\u00e8s concurrents. Avec EF 5, un champ jouant ce r\u00f4le doit avoir l'un des deux attributs [Timestamp] ou [ConcurrencyCheck]. SQL server a un type [timestamp]. Une colonne ayant ce type voit sa valeur automatiquement g\u00e9n\u00e9r\u00e9e par SQL Server \u00e0 toute insertion / modification d'une ligne. Une telle colonne peut alors servir \u00e0 g\u00e9rer la concurrence d'acc\u00e8s.</p> <p>Nous allons illustrer cette concurrence d'acc\u00e8s avec deux threads qui vont modifier en m\u00eame temps une m\u00eame entit\u00e9 [Client] en base. Le projet \u00e9volue comme suit\u00a0:</p> <p>Le code du programme [Acc\u00e8sConcurrents] est le suivant\u00a0:</p> <pre><code>using System;\nusing System.Data;\nusing System.Linq;\nusing System.Threading;\nusing RdvMedecins.Entites;\nusing RdvMedecins.Models;\n\nnamespace RdvMedecins_01\n{\n\n  // objet \u00e9chang\u00e9 avec les threads\n  class Data\n  {\n    public int Duree { get; set; }\n    public string Nom { get; set; }\n    public Client Client { get; set; }\n  }\n\n  // programme de test\n  class Acc\u00e8sConcurrents\n  {\n\n    static void Main(string[] args)\n    {\n      Client client1;\n      using (var context = new RdvMedecinsContext())\n      {\n        // thread principal\n        Thread.CurrentThread.Name = \"main\";\n        // on vide la base actuelle\n        foreach (var client in context.Clients)\n        {\n          context.Clients.Remove(client);\n        }\n        foreach (var medecin in context.Medecins)\n        {\n          context.Medecins.Remove(medecin);\n        }\n        // on ajoute un client\n        client1 = new Client { Nom = \"xx\", Prenom = \"xx\", Titre = \"xx\" };\n        context.Clients.Add(client1);\n        // suivi\n        Console.WriteLine(\"{0} client1--avant sauvegarde du contexte\", Thread.CurrentThread.Name);\n        Console.WriteLine(client1.ShortIdentity());\n        // sauvegarde\n        context.SaveChanges();\n        // suivi\n        Console.WriteLine(\"{0} client1--apr\u00e8s sauvegarde du contexte\", Thread.CurrentThread.Name);\n        Console.WriteLine(client1.ShortIdentity());\n      }\n      // on va modifier client1 avec deux threads\n      // thead t1\n      Thread t1 = new Thread(Modifie);\n      t1.Name = \"t1\";\n      t1.Start(new Data { Duree = 5000, Nom = \"yy\", Client = client1 });\n      // thread t2\n      Thread t2 = new Thread(Modifie);\n      t2.Name = \"t2\";\n      t2.Start(new Data { Duree = 5000, Nom = \"zz\", Client = client1 });\n      // on attend la fin des 2 threads\n      Console.WriteLine(\"Thread {0} -- d\u00e9but attente fin des deux threads\", Thread.CurrentThread.Name);\n      t1.Join();\n      t2.Join();\n      Console.WriteLine(\"Thread {0} -- fin attente fin des deux threads\", Thread.CurrentThread.Name);\n      // on affiche la modification - une seule a du r\u00e9ussir\n      using (var context = new RdvMedecinsContext())\n      {\n        // on r\u00e9cup\u00e8re client1 dans client2\n        Client client2 = context.Clients.Find(client1.Id);\n        Console.WriteLine(\"Thread {0} client2\", Thread.CurrentThread.Name);\n        Console.WriteLine(\"Thread {0} {1}\", Thread.CurrentThread.Name, client2.ShortIdentity());\n      }\n    }\n\n    // thread\n    static void Modifie(object infos)\n    {\n ...\n}\n</code></pre> <ul> <li>ligne 26\u00a0: on d\u00e9marre un contexte vide\u00a0;</li> <li>ligne 29\u00a0: on donne un nom au thread courant pour le diff\u00e9rentier des deux threads qui vont \u00eatre cr\u00e9\u00e9s ult\u00e9rieurement\u00a0;</li> <li>lignes 31-38\u00a0: les entit\u00e9s [Medecin] et [Client] sont mises dans l'\u00e9tat \"\u00a0supprim\u00e9\u00a0\"\u00a0;</li> <li>lignes 40-41: on met un client dans le contexte\u00a0;</li> <li>lignes 43-44\u00a0: on l'affiche avant la synchronisation du contexte\u00a0;</li> <li>ligne 46\u00a0: synchronisation du contexte avec la base\u00a0: les entit\u00e9s dans l'\u00e9tat \"\u00a0supprim\u00e9\u00a0\" vont \u00eatre supprim\u00e9es de la base. L'entit\u00e9 [Client] mise dans le contexte va \u00eatre ins\u00e9r\u00e9e dans la base. Ce sera le seul \u00e9l\u00e9ment de la base\u00a0;</li> <li>lignes 47-49\u00a0: on affiche le client apr\u00e8s synchronisation du contexte. A ce stade, les affichages \u00e9cran sont les suivants\u00a0:</li> </ul> <pre><code>main client1--avant sauvegarde du contexte\nClient[,xx,xx,xx,]\nmain client1--apr\u00e8s sauvegarde du contexte\nClient[33,xx,xx,xx,000001126209]\n</code></pre> <p>On remarquera qu'apr\u00e8s synchronisation du contexte, le client a une cl\u00e9 primaire et un timestamp\u00a0;</p> <ul> <li>ligne 50\u00a0: le contexte est ferm\u00e9\u00a0;</li> <li>ligne 53\u00a0: un thread t1 est associ\u00e9 \u00e0 la m\u00e9thode [Modifie] de la ligne 84. Cela signifie que lorsqu'il sera lanc\u00e9, il ex\u00e9cutera la m\u00e9thode [Modifie]\u00a0;</li> <li>ligne 54\u00a0: on donne un nom au thread t1\u00a0;</li> <li>ligne 55\u00a0: le thread t1 est lanc\u00e9. On lui passe des param\u00e8tres sous la forme d'une structure [Data] d\u00e9finie lignes 12-17\u00a0:</li> <li>Dur\u00e9e\u00a0: le thread s'arr\u00eatera Dur\u00e9e secondes avant de terminer son ex\u00e9cution,</li> <li>Client\u00a0: une r\u00e9f\u00e9rence sur le client \u00e0 mettre \u00e0 jour dans la base,</li> <li>Nom\u00a0: nom \u00e0 donner \u00e0 ce client\u00a0;</li> <li>lignes 57-59\u00a0: m\u00eame chose avec un deuxi\u00e8me thread. Au final, deux threads vont essayer de changer en base, le nom du m\u00eame client\u00a0;</li> <li>lignes 60-63\u00a0: apr\u00e8s avoir lanc\u00e9 les deux threads, le thread principal attend leur fin d'ex\u00e9cution\u00a0;</li> <li>ligne 62\u00a0: attente de la fin du thread t1\u00a0;</li> <li>ligne 63\u00a0: attente de la fin du thread t2\u00a0;</li> <li>ligne 64\u00a0: on se sait pas dans quel ordre les deux threads vont se terminer. Ce qui est s\u00fbr, c'est qu'en ligne 64 ils sont termin\u00e9s\u00a0;</li> <li>lignes 66-72\u00a0: dans un nouveau contexte, on va chercher le client en base pour voir dans quel \u00e9tat il est.</li> </ul> <p>Voyons maintenant, ce que font les deux threads t1 et t2. Ils ex\u00e9cutent la m\u00e9thode [Modifie] suivante\u00a0:</p> <pre><code>static void Modifie(object infos)\n    {\n      // on r\u00e9cup\u00e8re le param\u00e8tre\n      Data data = (Data)infos;\n      try\n      {\n        using (var context = new RdvMedecinsContext())\n        {\n          Console.WriteLine(\"D\u00e9but Thread {0}\", Thread.CurrentThread.Name);\n          // on r\u00e9cup\u00e8re client1 dans client2\n          Client client2 = context.Clients.Find(data.Client.Id);\n          Console.WriteLine(\"Thread {0} client2\", Thread.CurrentThread.Name);\n          Console.WriteLine(\"Thread {0} {1}\", Thread.CurrentThread.Name, client2.ShortIdentity());\n          // on modifie client2\n          client2.Nom = data.Nom;\n          // on attend un peu\n          Thread.Sleep(data.Duree);\n          // on sauvegarde les changements\n          context.SaveChanges();\n        }\n      }\n      catch (Exception e)\n      {\n        // exception\n        Console.WriteLine(\"Thread {0} {1}\", Thread.CurrentThread.Name, e);\n      }\n      // fin du thread\n      Console.WriteLine(\"Fin Thread {0}\", Thread.CurrentThread.Name);\n    }\n</code></pre> <ul> <li>ligne 4\u00a0: on r\u00e9cup\u00e8re les param\u00e8tres du thread (Dur\u00e9e, Nom, Client)\u00a0;</li> <li>ligne 7\u00a0: nouveau contexte\u00a0;</li> <li>ligne 11\u00a0: le client est amen\u00e9 dans le contexte\u00a0;</li> <li>lignes 12-13\u00a0: suivi pour voir l'\u00e9tat du client\u00a0;</li> <li>ligne 15\u00a0: on change son nom\u00a0;</li> <li>ligne 17\u00a0: le thread s'arr\u00eate Duree milli-secondes. Cela a un effet int\u00e9ressant. Le thread l\u00e2che le processeur qui l'ex\u00e9cutait laissant la place \u00e0 un autre thread. Dans notre exemple, nous avons trois threads\u00a0: main, t1 , t2. Le thread main est \u00e0 l'arr\u00eat attendant la fin des threads t1 et t2. En supposant que le thread t1 ait le processeur le premier, il le laisse d\u00e9sormais au thread t2. Cela va avoir pour effet, que le thread t2 va lire exactement la m\u00eame chose que le thread t1, le m\u00eame client avec le m\u00eame timestamp\u00a0;</li> <li>ligne 19\u00a0: le contexte est synchronis\u00e9 avec la base. Admettons de nouveau que le thread t1 se r\u00e9veille le premier. Il va sauvegarder le client avec le nom \"\u00a0yy\u00a0\". Il va pouvoir le faire parce qu'il a le m\u00eame timestamp qu'en base. A cause de cette mise \u00e0 jour, le SGBD va modifier le timestamp. Lorsque le thread t2 va se r\u00e9veiller \u00e0 son tour, il aura un client avec un timestamp diff\u00e9rent de celui qui est maintenant en base. Sa mise \u00e0 jour va \u00eatre refus\u00e9e.</li> </ul> <p>Les affichages \u00e9cran sont les suivants\u00a0:</p> <pre><code>main client1--avant sauvegarde du contexte\nClient[,xx,xx,xx,]\nmain client1--apr\u00e8s sauvegarde du contexte\nClient[33,xx,xx,xx,000001126209]\nThread main -- d\u00e9but attente fin des deux threads\nD\u00e9but Thread t1\nD\u00e9but Thread t2\nThread t2 client2\nThread t2 Client[33,xx,xx,xx,000001126209]\nThread t1 client2\nThread t1 Client[33,xx,xx,xx,000001126209]\nFin Thread t2\nThread t1 System.Data.Entity.Infrastructure.DbUpdateConcurrencyException: Une instruction de mise \u00e0 jour, d'insertion ou de suppression dans le magasin a affect\u00e9 un nombre inattendu de lignes (0). Des entit\u00e9s ont peut-\u00eatre \u00e9t\u00e9 modifi\u00e9es ou supprim\u00e9es depuis leur chargement. Actualisez les entr\u00e9es ObjectStateManager. ---&gt; System.Data.OptimisticConcurrencyException: Une instruction de mise \u00e0 jour, d'insertion ou de suppression dans le magasin a affect\u00e9 un nombre inattendu de lignes (0). Des entit\u00e9s ont peut-\u00eatre \u00e9t\u00e9 modifi\u00e9es ou supprim\u00e9es depuis leur char\ngement. Actualisez les entr\u00e9es ObjectStateManager.\n   \u00e0 System.Data.Mapping.Update.Internal.UpdateTranslator.ValidateRowsAffected(I\nnt64 rowsAffected, UpdateCommand source)\n   ...\n   \u00e0 RdvMedecins_01.Acc\u00e8sConcurrents.Modifie(Object infos) dans d:\\data\\istia-12\n13\\c#\\dvp\\Entity Framework\\RdvMedecins\\RdvMedecins-SqlServer-01\\Acc\u00e8sConcurrents\n.cs:ligne 102\nFin Thread t1\nThread main -- fin attente fin des deux threads\nThread main client2\nThread main Client[33,xx,xx,zz,000001126210]\n</code></pre> <ul> <li>ligne 4\u00a0: le client dans la base\u00a0;</li> <li>ligne 9\u00a0: le client tel qu'il est lu par le thread t2\u00a0;</li> <li>ligne 11\u00a0: le client tel qu'il est lu par le thread t1. Les deux threads ont donc lu la m\u00eame chose\u00a0;</li> <li>ligne 12\u00a0: le thread t2 se termine le premier. Il a donc pu faire sa mise \u00e0 jour. Le nom a du passer \u00e0 \"\u00a0zz\u00a0\"\u00a0;</li> <li>ligne 13\u00a0: le thread t1 lance une exception de type [System.Data.OptimisticConcurrencyException]. EF a d\u00e9tect\u00e9 qu'il n'avait pas le bon timestamp\u00a0;</li> <li>ligne 21\u00a0: le thread t1 se termine \u00e0 son tour\u00a0;</li> <li>ligne 22\u00a0: le thread principal a termin\u00e9 son attente\u00a0;</li> <li>ligne 24\u00a0:  le thread principal affiche le client en base. C'est bien le thread t2 qui a gagn\u00e9. Le nom est \"\u00a0zz\u00a0\". On notera que le timestamp a chang\u00e9.</li> </ul> <p>Maintenant, examinons un autre aspect\u00a0: la transaction qui encadre la synchronisation du contexte de persistance avec la base.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#359-synchronisation-dans-une-transaction","title":"3.5.9. Synchronisation dans une transaction","text":"<p>La table [CRENEAUX] a une contrainte d'unicit\u00e9 que nous avons ajout\u00e9e \u00e0 la main (cf paragraphe 2.2.4, page 11)\u00a0:</p> <pre><code>ALTER TABLE RV ADD CONSTRAINT UNQ1_RV UNIQUE (JOUR, ID_CRENEAU);\n</code></pre> <p>Nous allons proc\u00e9der de la fa\u00e7on suivante\u00a0: nous allons ajouter en m\u00eame temps deux rendez-vous pour le m\u00eame m\u00e9decin, le m\u00eame jour et le m\u00eame cr\u00e9neau horaire. On va voir ce qui se passe.</p> <p>Le projet \u00e9volue comme suit\u00a0:</p> <p>Le code du programme [SynchronisationTransaction] est le suivant\u00a0:</p> <pre><code>using System;\nusing System.Linq;\nusing RdvMedecins.Entites;\nusing RdvMedecins.Models;\n\nnamespace RdvMedecins_01\n{\n\n  // programme de test\n  class SynchronisationTransaction\n  {\n\n    static void Main(string[] args)\n    {\n      using (var context = new RdvMedecinsContext())\n      {\n        // on vide la base actuelle\n        foreach (var client in context.Clients)\n        {\n          context.Clients.Remove(client);\n        }\n        foreach (var medecin in context.Medecins)\n        {\n          context.Medecins.Remove(medecin);\n        }\n        context.SaveChanges();\n      }\n\n      // on cr\u00e9e un client\n      Client client1 = new Client { Nom = \"xx\", Prenom = \"xx\", Titre = \"xx\" };\n      // on cr\u00e9e un m\u00e9decin\n      Medecin medecin1 = new Medecin { Nom = \"xx\", Prenom = \"xx\", Titre = \"xx\" };\n      // on cr\u00e9e un cr\u00e9neau pour ce m\u00e9decin\n      Creneau creneau1 = new Creneau { Hdebut = 8, Mdebut = 20, Hfin = 8, Mfin = 40, Medecin = medecin1 };\n      // on cr\u00e9e deux Rv pour ce m\u00e9decin et ce client, m\u00eame jour, m\u00eame cr\u00e9neau\n      Rv rv1 = new Rv { Client = client1, Creneau = creneau1, Jour = new DateTime(2012, 10, 18) };\n      Rv rv2 = new Rv { Client = client1, Creneau = creneau1, Jour = new DateTime(2012, 10, 18) };\n      try\n      {\n        // on met tout ce petit monde dans le contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          context.Clients.Add(client1);\n          context.Creneaux.Add(creneau1);\n          context.Medecins.Add(medecin1);\n          context.Rvs.Add(rv1);\n          context.Rvs.Add(rv2);\n          // on sauvegarde le contexte - on doit avoir une exception\n          // car la BD sous-jacente a une contrainte d'unicit\u00e9 emp\u00eachant\n          // d'avoir deux RDV m\u00eame jour, m\u00eame cr\u00e9neau\n          context.SaveChanges();\n        }\n      }\n      catch (Exception e)\n      {\n        Console.WriteLine(\"Erreur : {0}\", e);\n      }\n      // si la sauvegarde se passe dans une transaction alors rien n'a du \u00eatre ins\u00e9r\u00e9 dans la base\n      // \u00e0 cause de l'exception pr\u00e9c\u00e9dente - on v\u00e9rifie\n\n      using (var context = new RdvMedecinsContext())\n      {\n        // les clients\n        Console.WriteLine(\"Clients--------------------------------------\");\n        var clients = from client in context.Clients select client;\n        foreach (Client client in clients)\n        {\n          Console.WriteLine(client);\n        }\n        // les m\u00e9decins\n        Console.WriteLine(\"M\u00e9decins--------------------------------------\");\n        var medecins = from medecin in context.Medecins select medecin;\n        foreach (Medecin medecin in medecins)\n        {\n          Console.WriteLine(medecin);\n        }\n        // les cr\u00e9neaux horaires\n        Console.WriteLine(\"Cr\u00e9neaux horaires--------------------------------------\");\n        var creneaux = from creneau in context.Creneaux select creneau;\n        foreach (Creneau creneau in creneaux)\n        {\n          Console.WriteLine(creneau);\n        }\n        // les Rdvs\n        Console.WriteLine(\"Rendez-vous--------------------------------------\");\n        var rvs = from rv in context.Rvs select rv;\n        foreach (Rv rv in rvs)\n        {\n          Console.WriteLine(rv);\n        }\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>lignes 15-27\u00a0: on utilise un contexte de persistance pour vider la base\u00a0;</li> <li>ligne 30\u00a0: cr\u00e9ation d'un objet [Client]\u00a0;</li> <li>ligne 32\u00a0: cr\u00e9ation d'un objet [Medecin]\u00a0;</li> <li>ligne 34\u00a0: cr\u00e9ation d'un objet [Creneau]\u00a0;</li> <li>ligne 36\u00a0: cr\u00e9ation d'un objet [Rv]\u00a0;</li> <li>ligne 37\u00a0: cr\u00e9ation d'un second objet [Rv] identique au pr\u00e9c\u00e9dent\u00a0;</li> <li>ligne 41\u00a0: ouverture d'un nouveau contexte\u00a0;</li> <li>lignes 43-47\u00a0: les objets cr\u00e9\u00e9s pr\u00e9c\u00e9demment sont attach\u00e9s au nouveau contexte. Notez ici, qu'en tenant compte des d\u00e9pendances, nous aurions pu minimiser le nombre d'op\u00e9ration Add. Mais EF lui optimisera les ordres SQL INSERT \u00e0 \u00e9mettre sur la base\u00a0;</li> <li>ligne 51\u00a0: le contexte est synchronis\u00e9 avec la base. Comme l'indique le commentaire, l'insertion d'un des deux rendez-vous doit \u00e9chouer \u00e0 cause de la contrainte d'unicit\u00e9 sur la table [RVS]. Mais davantage que cela, si la synchronisation se passe dans une transaction, tout doit \u00eatre d\u00e9fait. Donc aucune insertion ne doit avoir lieu. La base doit rester vide\u00a0;</li> <li>ligne 53\u00a0: le contexte est ferm\u00e9\u00a0;</li> <li>lignes 61-90\u00a0: affichage du contenu de la base. Elle doit \u00eatre vide.</li> </ul> <p>L'affichage \u00e9cran est le suivant\u00a0:</p> <pre><code>Erreur : System.Data.Entity.Infrastructure.DbUpdateException: Une erreur s'est produite lors de la mise \u00e0 jour des entr\u00e9es. Pour plus d'informations, consultezl'exception interne. ---&gt; System.Data.UpdateException: Une erreur s'est produite lors de la mise \u00e0 jour des entr\u00e9es. Pour plus d'informations, consultez l'exception interne. ---&gt; System.Data.SqlClient.SqlException: Violation de la contrainte UNIQUE KEY \u00ab\u00a0RVS_uq\u00a0\u00bb. Impossible d'ins\u00e9rer une cl\u00e9 en double dans l'objet \u00ab\u00a0dbo.RVS\u00a0\u00bb. Valeur de cl\u00e9 dupliqu\u00e9e\u00a0: (oct 18 2012 12:00AM, 34).\nL'instruction a \u00e9t\u00e9 arr\u00eat\u00e9e.\n   \u00e0 System.Data.SqlClient.SqlConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)\n   \u00e0 System.Data.SqlClient.SqlInternalConnection.OnError(SqlException exception, Boolean breakConnection, Action`1 wrapCloseInAction)...\n   --- Fin de la trace de la pile d'exception interne ---\n   ...\n   \u00e0 System.Data.Entity.DbContext.SaveChanges()\n   \u00e0 RdvMedecins_01.SynchronisationTransaction.Main(String[] args) dans d:\\data\\istia-1213\\c#\\dvp\\Entity Framework\\RdvMedecins\\RdvMedecins-SqlServer-01\\SynchronisationTransaction.cs:ligne 59\nClients--------------------------------------\nM\u00e9decins--------------------------------------\nCr\u00e9neaux horaires--------------------------------------\nRendez-vous--------------------------------------\n</code></pre> <ul> <li>ligne 1\u00a0: exception due \u00e0 la violation de la contrainte d'unicit\u00e9 sur la table [RVS]\u00a0;</li> <li>lignes 9-12\u00a0: la base est bien vide. La synchronisation du contexte avec la base s'est donc pass\u00e9e dans une transaction.</li> </ul> <p>Il y aurait sans doute d'autres choses \u00e0 explorer dans EF 5. Mais nous en savons assez pour revenir sur notre \u00e9tude d'une architecture multi-couche. Le lecteur trouvera au d\u00e9but de ce document des r\u00e9f\u00e9rences d'articles et de livres lui permettant d'approfondir sa connaissance de EF 5.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#36-etude-dune-architecture-multi-couche-sappuyant-sur-ef-5","title":"3.6. Etude d'une architecture multi-couche s'appuyant sur EF 5","text":"<p>Nous revenons \u00e0 notre \u00e9tude de cas d\u00e9crite au paragraphe 2. Il s'agit d'une application web ASP.NET structur\u00e9e comme suit\u00a0:</p> <p>Nous allons commencer par construire la couche [DAO] d'acc\u00e8s aux donn\u00e9es. Cette couche s'appuiera sur EF5.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#361-le-nouveau-projet","title":"3.6.1. Le nouveau projet","text":"<p>Nous cr\u00e9ons un nouveau projet console VS 2012 [RdvMedecins-SqlServer-02] dans la solution courante [1]\u00a0:</p> <p>Nous lui ajoutons quatre dossiers [2] dans lesquels nous allons r\u00e9partir nos codes. Le dossier [Entites] est une recopie du dossier [Entites] du projet pr\u00e9c\u00e9dent. Apr\u00e8s cette recopie, apparaissent des erreurs dues au fait que nous n'avons pas les bonnes r\u00e9f\u00e9rences. Il nous faut ajouter une r\u00e9f\u00e9rence \u00e0 Entity Framework 5. On suivra pour cela, la m\u00e9thode expliqu\u00e9e au paragraphe 3.4, page 20. La liste des r\u00e9f\u00e9rences devient la suivante [3]\u00a0:</p> <p>3</p> <p>A ce stade, le projet ne doit plus pr\u00e9senter d'erreurs de compilation. Du projet pr\u00e9c\u00e9dent, nous recopions \u00e9galement le fichier [App.config] qui configure la connexion \u00e0 la base de donn\u00e9es\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;configSections&gt;\n    &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt;\n    &lt;section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" /&gt;\n  &lt;/configSections&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;entityFramework&gt;\n    &lt;defaultConnectionFactory type=\"System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework\" /&gt;\n  &lt;/entityFramework&gt;\n\n  &lt;!-- cha\u00eene de connexion sur la base --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\"\n         connectionString=\"Data Source=localhost;Initial Catalog=rdvmedecins-ef;User Id=sa;Password=sqlserver2012;\"\n         providerName=\"System.Data.SqlClient\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;!-- le factory provider --&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"SqlClient Data Provider\"\n       invariant=\"System.Data.SqlClient\"\n       description=\".Net Framework Data Provider for SqlServer\"\n       type=\"System.Data.SqlClient.SqlClientFactory, System.Data,\n     Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\"\n    /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n\n&lt;/configuration&gt;\n</code></pre>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#362-la-classe-exception","title":"3.6.2. La classe Exception","text":"<p>Nous allons utiliser une classe d'exception propre au projet. C'est celle qui sortira de la couche [DAO]\u00a0:</p> <p>La couche [DAO] arr\u00eatera toutes les exceptions qui remonteront jusqu'\u00e0 elles et les encapsulera dans une exception de type [RdvMedecinsException]. Cette exception sera la suivante\u00a0:</p> <pre><code>using System;\n\nnamespace RdvMedecins.Exceptions\n{\n  public class RdvMedecinsException : Exception\n  {\n\n    // propri\u00e9t\u00e9s\n    public int Code { get; set; }\n\n    // constructeurs\n    public RdvMedecinsException()\n      : base()\n    {\n    }\n\n    public RdvMedecinsException(string message)\n      : base(message)\n    {\n    }\n\n    public RdvMedecinsException(int code, string message)\n      : base(message)\n    {\n      Code = code;\n    }\n\n    public RdvMedecinsException(int code, string message, Exception ex)\n      : base(message, ex)\n    {\n      Code = code;\n    }\n\n    // identit\u00e9\n    public override string ToString()\n    {\n      if (InnerException == null)\n      {\n        return string.Format(\"RdvMedecinsException[{0},{1}]\", Code, base.Message);\n      }\n      else\n      {\n        return string.Format(\"RdvMedecinsException[{0},{1},{2}]\", Code, base.Message, base.InnerException.Message);\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 5\u00a0: la classe d\u00e9rive de la classe [Exception]\u00a0;</li> <li>ligne 9\u00a0: elle ajoute \u00e0 sa classe de base un code d'erreur\u00a0;</li> <li>lignes 12-32\u00a0: les diff\u00e9rents constructeurs int\u00e8grent la pr\u00e9sence du champ [Code].</li> </ul> <p>Le projet \u00e9volue comme suit\u00a0:</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#363-la-couche-dao","title":"3.6.3. La couche [DAO]","text":"<p>La couche [DAO] offre une interface \u00e0 la couche [ASP.NET]. Pour identifier celle-ci, il faut regarder les pages web de l'application\u00a0:</p> <ul> <li>en [1] ci-dessus, la liste d\u00e9roulante a \u00e9t\u00e9 remplie avec la liste des m\u00e9decins. La couche [DAO] fournira cette liste\u00a0;</li> <li>en [2], la couche [DAO] fournira\u00a0;</li> <li>la liste des rendez-vous d'un m\u00e9decin pour tel jour,</li> <li>la liste des cr\u00e9neaux horaires d'un m\u00e9decin,</li> <li>des informations compl\u00e9mentaires sur le m\u00e9decin s\u00e9lectionn\u00e9\u00a0;</li> </ul> <ul> <li>en [3], la liste d\u00e9roulante des clients sera fournie par la couche [DAO]\u00a0;</li> </ul> <ul> <li>en [4], l'utilisateur valide un rendez-vous. La couche [DAO] doit pouvoir l'ajouter \u00e0 la base. Elle doit pouvoir \u00e9galement donner des informations compl\u00e9mentaires sur le client s\u00e9lectionn\u00e9\u00a0;</li> </ul> <ul> <li>en [5], l'utilisateur supprime un rendez-vous. La couche [DAO] doit permettre cela.</li> </ul> <p>Avec ces informations, l'interface [IDao] de la couche [DAO] pourrait \u00eatre la suivante\u00a0:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing RdvMedecins.Entites;\n\nnamespace RdvMedecins.Dao\n{\n  public interface IDao\n  {\n    // liste des clients\n    List&lt;Client&gt; GetAllClients();\n    // liste des m\u00e9decins\n    List&lt;Medecin&gt; GetAllMedecins();\n    // liste des cr\u00e9neaux horaires d'un m\u00e9decin\n    List&lt;Creneau&gt; GetCreneauxMedecin(int idMedecin);\n    // liste des RV d'un m\u00e9decin donn\u00e9, un jour donn\u00e9\n    List&lt;Rv&gt; GetRvMedecinJour(int idMedecin, DateTime jour);\n    // ajouter un RV\n    int AjouterRv(DateTime jour, int idCreneau, int idClient);\n    // supprimer un RV\n    void SupprimerRv(int idRv);\n    // trouver une entit\u00e9 T via sa cl\u00e9 primaire\n    T Find&lt;T&gt;(int id) where T : class;\n  }\n}\n</code></pre> <p>Les m\u00e9thodes des lignes 10-20 d\u00e9coulent de l'\u00e9tude qui vient d'\u00eatre faite. La m\u00e9thodes de la ligne 22 est l\u00e0 pour rem\u00e9dier au fait qu'on travaille en Lazy Loading. Si dans la couche [ASP.NET] on a besoin d'une d\u00e9pendance d'une entit\u00e9, on ira la chercher en base avec cette m\u00e9thode.</p> <p>L'impl\u00e9mentation [Dao] de cette interface sera la suivante\u00a0:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing RdvMedecins.Entites;\nusing RdvMedecins.Exceptions;\nusing RdvMedecins.Models;\n\nnamespace RdvMedecins.Dao\n{\n  public class Dao : IDao\n  {\n\n    //liste des clients\n    public List&lt;Client&gt; GetAllClients()\n    {\n      // liste des clients\n      List&lt;Client&gt; clients = null;\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          // liste des clients\n          clients = context.Clients.ToList();\n        }\n\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(1, \"GetAllClients\", ex);\n      }\n      // on rend le r\u00e9sultat\n      return clients;\n    }\n\n    // liste des m\u00e9decins\n    public List&lt;Medecin&gt; GetAllMedecins()\n    {\n      // liste des m\u00e9decins\n      List&lt;Medecin&gt; medecins = null;\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          // liste des m\u00e9decins\n          medecins = context.Medecins.ToList();\n        }\n\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(2, \"GetAllMedecins\", ex);\n      }\n      // on rend le r\u00e9sultat\n      return medecins;\n    }\n\n    // liste des cr\u00e9neaux horaires d'un m\u00e9decin donn\u00e9\n    public List&lt;Creneau&gt; GetCreneauxMedecin(int idMedecin)\n    {\n   ...\n    }\n\n    // liste des RV d'un m\u00e9decin pour un jour donn\u00e9\n    public List&lt;Rv&gt; GetRvMedecinJour(int idMedecin, DateTime jour)\n    {\n ...\n    }\n\n    // ajouter un RV\n    public int AjouterRv(DateTime jour, int idCreneau, int idClient)\n    {\n ...\n    }\n\n    // supprimer un RV\n    public void SupprimerRv(int idRv)\n    {\n...\n    }\n\n    // trouver un client\n    public Client FindClient(int id)\n    {\n...\n    }\n\n    // trouver un cr\u00e9neau\n    public Creneau FindCreneau(int id)\n    {\n ...\n    }\n\n    // trouver un m\u00e9decin\n    public Medecin FindMedecin(int id)\n    {\n....\n    }\n\n    // trouver un Rv\n    public Rv FindRv(int id){\n...\n    }\n\n  }\n}\n</code></pre> <p>Explicitons la m\u00e9thode [GetAllClients] qui doit rendre la liste de tous les clients\u00a0:</p> <ul> <li>lignes 18-31\u00a0: la recherche des clients se fait dans un try / catch. Il en sera de m\u00eame de toutes les m\u00e9thodes \u00e0 suivre\u00a0;</li> <li>ligne 21\u00a0: ouverture d'un nouveau contexte\u00a0;</li> <li>ligne 24\u00a0: les entit\u00e9s [Client] sont charg\u00e9es dans le contexte et mises dans une liste.</li> </ul> <p>La m\u00e9thode [GetAllMedecins] qui doit rendre la liste de tous les m\u00e9decins est analogue (lignes 37-57).</p> <p>La m\u00e9thode [GetCreneauxMedecin] est la suivante\u00a0:</p> <pre><code>// liste des cr\u00e9neaux horaires d'un m\u00e9decin donn\u00e9\n    public List&lt;Creneau&gt; GetCreneauxMedecin(int idMedecin)\n    {\n      // liste des cr\u00e9neaux\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          // on r\u00e9cup\u00e8re le m\u00e9decin avec ses cr\u00e9neaux\n          Medecin medecin = context.Medecins.Include(\"Creneaux\").Single(m =&gt; m.Id == idMedecin);\n          // liste des cr\u00e9neaux du m\u00e9decin\n          return medecin.Creneaux.ToList&lt;Creneau&gt;();\n        }\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(3, \"GetCreneauxMedecin\", ex);\n      }\n    }\n</code></pre> <ul> <li>ligne 9\u00a0: ouverture d'un nouveau contexte de persistance\u00a0;</li> <li>ligne 11\u00a0: on recherche le m\u00e9decin dont on a la cl\u00e9 primaire. On demande d'y inclure la d\u00e9pendance [Creneaux] qui est une collection des cr\u00e9neaux du m\u00e9decin. Si le m\u00e9decin n'existe pas, la m\u00e9thode Single lance une exception\u00a0;</li> <li>ligne 13\u00a0: on rend la liste des cr\u00e9neaux.</li> </ul> <p>La m\u00e9thode [GetRvMedecinJour] doit rendre la liste des rendez-vous d'un m\u00e9decin pour un jour donn\u00e9. Son code pourrait \u00eatre le suivant\u00a0:</p> <pre><code>// liste des RV d'un m\u00e9decin pour un jour donn\u00e9\n    public List&lt;Rv&gt; GetRvMedecinJour(int idMedecin, DateTime jour)\n    {\n      // liste des Rv\n      List&lt;Rv&gt; rvs = null;\n\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          // on r\u00e9cup\u00e8re le m\u00e9decin\n          Medecin medecin = context.Medecins.Find(idMedecin);\n          if (medecin == null)\n          {\n            throw new RdvMedecinsException(10, string.Format(\"M\u00e9decin [{0}] inexistant\", idMedecin));\n          }\n          // liste des rv\n          rvs = context.Rvs.Where(r =&gt; r.Creneau.Medecin.Id == idMedecin &amp;&amp; r.Jour == jour).ToList();\n        }\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(4, \"GetRvMedecinJour\", ex);\n      }\n      // on rend le r\u00e9sultat\n      return rvs;\n    }\n</code></pre> <ul> <li>ligne 13\u00a0: on am\u00e8ne dans le contexte le m\u00e9decin dont on a la cl\u00e9 primaire\u00a0;</li> <li>lignes 14-17\u00a0: s'il n'existe pas, on lance une exception\u00a0;</li> <li>ligne 19\u00a0: la requ\u00eate LINQ pour r\u00e9cup\u00e9rer les rendez-vous pour ce m\u00e9decin\u00a0;</li> </ul> <p>La m\u00e9thode [AjouterRv] doit ajouter un rendez-vous en base et doit rendre la cl\u00e9 primaire de l'\u00e9l\u00e9ment ins\u00e9r\u00e9. Son code pourrait \u00eatre le suivant\u00a0:</p> <pre><code>// ajouter un RV\n    public int AjouterRv(DateTime jour, int idCreneau, int idClient)\n    {\n      // n\u00b0 du Rdv ajout\u00e9\n      int idRv;\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          // on r\u00e9cup\u00e8re le cr\u00e9neau\n          Creneau creneau = context.Creneaux.Find(idCreneau);\n          if (creneau == null)\n          {\n            throw new RdvMedecinsException(5, string.Format(\"Cr\u00e9neau [{0}] inexistant\", idCreneau));\n          }\n          // on r\u00e9cup\u00e8re le client\n          Client client = context.Clients.Find(idClient);\n          if (client == null)\n          {\n            throw new RdvMedecinsException(6, string.Format(\"Client [{0}] inexistant\", idCreneau));\n          }\n          // cr\u00e9ation cr\u00e9neau\n          Rv rv = new Rv { Jour = jour, Client = client, Creneau = creneau };\n          // ajout dans le contexte\n          context.Rvs.Add(rv);\n          // sauvegarde du contexte\n          context.SaveChanges();\n          // on r\u00e9cup\u00e8re la cl\u00e9 primaire du rv ajout\u00e9\n          idRv = (int)rv.Id;\n        }\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(7, \"AjouterRv\", ex);\n      }\n      // r\u00e9sultat\n      return idRv;\n    }\n</code></pre> <ul> <li>ligne 12\u00a0: on cherche le cr\u00e9neau du rendez-vous en base\u00a0;</li> <li>lignes 13-16\u00a0: si on ne le trouve pas, on lance une exception\u00a0;</li> <li>ligne 18\u00a0: on cherche le client du rendez-vous en base\u00a0;</li> <li>lignes 19-22\u00a0: si on ne le trouve pas, on lance une exception\u00a0;</li> <li>ligne 24\u00a0: on construit un objet [Rv] avec les informations n\u00e9cessaires\u00a0;</li> <li>ligne 26\u00a0: on l'ajoute au contexte de persistance\u00a0;</li> <li>ligne 28\u00a0: on synchronise le contexte de persistance avec la base. Le rendez-vous va alors \u00eatre mis en base\u00a0;</li> <li>ligne 30\u00a0: on sait qu'apr\u00e8s synchronisation de la base, les cl\u00e9s primaires des \u00e9l\u00e9ments ins\u00e9r\u00e9s sont disponibles. On r\u00e9cup\u00e8re celle du rendez-vous ajout\u00e9\u00a0;</li> <li>ligne 31\u00a0: on ferme le contexte de persistance.</li> </ul> <p>La m\u00e9thode [SupprimerRv] doit supprimer un rendez-vous dont on lui passe la cl\u00e9 primaire.</p> <pre><code>// supprimer un RV\n    public void SupprimerRv(int idRv)\n    {\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          // on r\u00e9cup\u00e8re le Rv\n          Rv rv = context.Rvs.Find(idRv);\n          if (rv == null)\n          {\n            throw new RdvMedecinsException(5, string.Format(\"Rv [{0}] inexistant\", idRv));\n          }\n          // suppression Rv\n          context.Rvs.Remove(rv);\n          // sauvegarde du contexte\n          context.SaveChanges();\n        }\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(8, \"SupprimerRv\", ex);\n      }\n    }\n</code></pre> <ul> <li>ligne 7\u00a0: nouveau contexte de persistance\u00a0;</li> <li>ligne 10\u00a0: on am\u00e8ne dans le contexte, le rendez-vous \u00e0 supprimer\u00a0;</li> <li>lignes 11-15\u00a0: s'il n'existe pas, on lance une exception\u00a0;</li> <li>ligne 16\u00a0: on le supprime du contexte\u00a0;</li> <li>ligne 18\u00a0: on synchronise le contexte avec la base\u00a0;</li> <li>ligne 19\u00a0: on ferme le contexte.</li> </ul> <p>La m\u00e9thode [Find&lt;T&gt;] permet de rechercher en base une entit\u00e9 de type T, via sa cl\u00e9 primaire. Son code pourrait \u00eatre le suivant\u00a0:</p> <pre><code>public T Find&lt;T&gt;(int id)  where T : class\n    {\n      try\n      {\n        // ouverture contexte de persistance\n        using (var context = new RdvMedecinsContext())\n        {\n          return context.Set&lt;T&gt;().Find(id);\n        }\n      }\n      catch (Exception ex)\n      {\n        throw new RdvMedecinsException(20, \"Find&lt;T&gt;\", ex);\n      }\n    }\n</code></pre> <ul> <li>ligne 8\u00a0: la m\u00e9thode Set&lt;T&gt; permet de r\u00e9cup\u00e9rer un DbSet&lt;T&gt; sur lequel on peut appliquer les m\u00e9thodes habituelles.</li> </ul> <p>Le projet \u00e9volue comme suit\u00a0:</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#364-test-de-la-couche-dao","title":"3.6.4. Test de la couche [DAO]","text":"<p>Nous allons cr\u00e9er un programme de test de la couche [DAO]. L'architecture du test sera la suivante\u00a0:</p> <p>Un programme console demande \u00e0 [Spring.net] d'instancier la couche [DAO]. Ceci fait, il teste les diff\u00e9rentes fonctionnalit\u00e9s de l'interface de la couche [DAO]. Plut\u00f4t qu'un programme console, il aurait \u00e9t\u00e9 pr\u00e9f\u00e9rable d'\u00e9crire un programme de test de type NUnit. Un programme de test de la couche [DAO] pourrait \u00eatre le suivant\u00a0:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing RdvMedecins.Dao;\nusing RdvMedecins.Entites;\nusing RdvMedecins.Exceptions;\nusing Spring.Context.Support;\n\nnamespace RdvMedecins.Tests\n{\n  class Program\n  {\n    public static void Main()\n    {\n      IDao dao = null;\n      try\n      {\n        // instanciation couche [DAO] via Spring\n        dao = ContextRegistry.GetContext().GetObject(\"rdvmedecinsDao\") as IDao;\n\n        // affichage clients\n        List&lt;Client&gt; clients = dao.GetAllClients();\n        DisplayClients(\"Liste des clients :\", clients);\n\n        // affichage m\u00e9decins\n        List&lt;Medecin&gt; medecins = dao.GetAllMedecins();\n        DisplayMedecins(\"Liste des m\u00e9decins :\", medecins);\n\n        // liste des cr\u00e9neaux horaires du m\u00e9decin n\u00b0 0\n        List&lt;Creneau&gt; creneaux = dao.GetCreneauxMedecin((int)medecins[0].Id);\n        DisplayCreneaux(string.Format(\"Liste des cr\u00e9neaux horaires du m\u00e9decin {0}\", medecins[0]), creneaux);\n\n        // liste des Rv d'un m\u00e9decin pour un jour donn\u00e9\n        DisplayRvs(string.Format(\"Liste des RV du m\u00e9decin {0}, le 23/11/2013 :\", medecins[0]), dao.GetRvMedecinJour((int)medecins[0].Id, new DateTime(2013, 11, 23)));\n\n        // ajouter un RV au m\u00e9decin n\u00b01 dans cr\u00e9neau n\u00b0 0\n        Console.WriteLine(string.Format(\"Ajout d'un RV au m\u00e9decin {0} avec client {1} le 23/11/2013\", medecins[0], clients[0]));\n        int idRv1 = dao.AjouterRv(new DateTime(2013, 11, 23), (int)creneaux[0].Id, (int)clients[0].Id);\n        Console.WriteLine(\"Rdv ajout\u00e9\");\n        DisplayRvs(string.Format(\"Liste des RV du m\u00e9decin {0}, le 23/11/2013 :\", medecins[0]), dao.GetRvMedecinJour((int)medecins[0].Id, new DateTime(2013, 11, 23)));\n\n        // ajouter un Rv dans un cr\u00e9neau d\u00e9j\u00e0 occup\u00e9 - doit provoquer une exception\n        int idRv2;\n        Console.WriteLine(\"Ajout d'un RV dans un cr\u00e9neau d\u00e9j\u00e0 occup\u00e9\");\n        try\n        {\n          idRv2 = dao.AjouterRv(new DateTime(2013, 11, 23), (int)creneaux[0].Id, (int)clients[0].Id);\n          Console.WriteLine(\"Rdv ajout\u00e9\");\n          DisplayRvs(string.Format(\"Liste des RV du m\u00e9decin {0}, le 23/11/2013 :\", medecins[0]), dao.GetRvMedecinJour((int)medecins[0].Id, new DateTime(2013, 11, 23)));\n        }\n        catch (RdvMedecinsException ex)\n        {\n          Console.WriteLine(string.Format(\"L'erreur suivante s'est produite : {0}\", ex));\n        }\n\n        // supprimer un Rv\n        Console.WriteLine(string.Format(\"Suppression du RV n\u00b0 {0}\", idRv1));\n        dao.SupprimerRv(idRv1);\n        DisplayRvs(string.Format(\"Liste des RV du m\u00e9decin {0}, le 23/11/2013 :\", medecins[0]), dao.GetRvMedecinJour((int)medecins[0].Id, new DateTime(2013, 11, 23)));\n      }\n      catch (Exception ex)\n      {\n        Console.WriteLine(string.Format(\"L'erreur suivante s'est produite : {0}\", ex));\n      }\n      //pause \n      Console.ReadLine();\n    }\n\n    // m\u00e9thodes utilitaires - affiche des listes\n    public static void DisplayClients(string Message, List&lt;Client&gt; clients)\n    {\n      Console.WriteLine(Message);\n      foreach (Client c in clients)\n      {\n        Console.WriteLine(c.ShortIdentity());\n      }\n    }\n    public static void DisplayMedecins(string Message, List&lt;Medecin&gt; medecins)\n    {\n...\n    }\n    public static void DisplayCreneaux(string Message, List&lt;Creneau&gt; creneaux)\n    {\n...\n    }\n    public static void DisplayRvs(string Message, List&lt;Rv&gt; rvs)\n    {\n...\n    }\n  }\n}\n</code></pre> <ul> <li>ligne 14\u00a0: la r\u00e9f\u00e9rence sur la couche [DAO]. Pour rendre le test ind\u00e9pendant de l'impl\u00e9mentation r\u00e9elle de celle-ci, cette r\u00e9f\u00e9rence est du type de l'interface [IDao] et non du type de la classe [Dao]\u00a0;</li> <li>ligne 18\u00a0: la couche [DAO] est instanci\u00e9e par Spring. Nous reviendrons sur la configuration n\u00e9cessaire pour que cela soit possible. Nous castons la r\u00e9f\u00e9rence d'objet rendue par Spring en une r\u00e9f\u00e9rence du type de l'interface [IDao]\u00a0;</li> <li>lignes 21-22\u00a0: affichent les clients\u00a0;</li> <li>lignes 25-26\u00a0: affichent les m\u00e9decins\u00a0;</li> <li>lignes 29-30\u00a0: affichent la liste des cr\u00e9neaux du m\u00e9decin n\u00b0 0\u00a0;</li> <li>ligne 33\u00a0: affiche les rendez-vous du m\u00e9decin n\u00b0 0 \u00e0 la date du 23/11/2013. On doit en avoir aucun\u00a0;</li> <li>ligne 37\u00a0: ajoute un rendez-vous au m\u00e9decin n\u00b0 0 pour le 23/11/2013\u00a0;</li> <li>ligne 39\u00a0: affiche les rendez-vous du m\u00e9decin n\u00b0 0 \u00e0 la date du 23/11/2013. On doit en avoir un ;</li> <li>ligne 46\u00a0: on ajoute une seconde fois le m\u00eame rendez-vous. On doit avoir une exception\u00a0;</li> <li>ligne 57\u00a0: on supprime l'unique rendez-vous ajout\u00e9\u00a0;</li> <li>ligne 58\u00a0: affiche les rendez-vous du m\u00e9decin n\u00b0 0 \u00e0 la date du 23/11/2013. On doit en avoir aucun.</li> </ul>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#365-configuration-de-springnet","title":"3.6.5. Configuration de Spring.net","text":"<p>Dans le programme de test ci-dessus, nous sommes pass\u00e9s rapidement sur l'instruction qui instancie la couche [DAO]\u00a0:</p> <pre><code>dao = ContextRegistry.GetContext().GetObject(\"rdvmedecinsDao\") as IDao;\n</code></pre> <p>La classe [ContextRegistry] est une classe de Spring dans l'espace de noms [Spring.Context.Support]. Pour pouvoir utiliser Spring, il nous faut ajouter sa DLL dans les r\u00e9f\u00e9rences du projet. Nous proc\u00e9dons de la fa\u00e7on suivante\u00a0:</p> <ul> <li>en [1], on recherche des paquetages avec l'outil [NuGet]\u00a0;</li> </ul> <ul> <li>en [2], on cherche des paquetages en ligne\u00a0;</li> <li>en [3], on met le mot cl\u00e9 spring dans la zone de recherche\u00a0;</li> <li>en [4], les paquetages dont la description contient ce mot cl\u00e9 sont affich\u00e9es. Ici, c'est [Spring.Core] qui nous convient. On l'installe.</li> </ul> <p>Les r\u00e9f\u00e9rences du projet \u00e9voluent comme suit\u00a0:</p> <p>Le paquetage [Spring.Core] avait une d\u00e9pendance sur le paquetage [Common.Logging]. Celui-ci a \u00e9t\u00e9 charg\u00e9 \u00e9galement. A ce stade, le projet ne doit plus pr\u00e9senter d'erreurs.</p> <p>Ce n'est pas pour cela qu'il va marcher. Il nous faut configurer d'abord Spring dans le fichier [App.config]. C'est la partie la plus d\u00e9licate du projet. Le nouveau fichier [App.config] est le suivant\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;configSections&gt;\n    &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt;\n    &lt;section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" /&gt;\n    &lt;!-- spring --&gt;\n    &lt;sectionGroup name=\"spring\"&gt;\n      &lt;section name=\"context\" type=\"Spring.Context.Support.ContextHandler, Spring.Core\" /&gt;\n      &lt;section name=\"objects\" type=\"Spring.Context.Support.DefaultSectionHandler, Spring.Core\" /&gt;\n    &lt;/sectionGroup&gt;\n    &lt;!-- common logging--&gt;\n    &lt;section name=\"logging\" type=\"Common.Logging.ConfigurationSectionHandler, Common.Logging\" /&gt;\n  &lt;/configSections&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;!-- Entity Framework --&gt;\n  &lt;entityFramework&gt;\n    &lt;defaultConnectionFactory type=\"System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework\"&gt;\n      &lt;parameters&gt;\n        &lt;parameter value=\"v11.0\" /&gt;\n      &lt;/parameters&gt;\n    &lt;/defaultConnectionFactory&gt;\n  &lt;/entityFramework&gt;\n  &lt;!-- Cha\u00eenes de connexion --&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"monContexte\" connectionString=\"Data Source=localhost;Initial Catalog=rdvmedecins-ef;User Id=sa;Password=sqlserver2012;\" providerName=\"System.Data.SqlClient\" /&gt;\n  &lt;/connectionStrings&gt;\n  &lt;system.data&gt;\n    &lt;DbProviderFactories&gt;\n      &lt;add name=\"SqlClient Data Provider\" invariant=\"System.Data.SqlClient\" description=\".Net Framework Data Provider for SqlServer\" type=\"System.Data.SqlClient.SqlClientFactory, System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" /&gt;\n    &lt;/DbProviderFactories&gt;\n  &lt;/system.data&gt;\n  &lt;!-- configuration Spring --&gt;\n  &lt;spring&gt;\n    &lt;context&gt;\n      &lt;resource uri=\"config://spring/objects\" /&gt;\n    &lt;/context&gt;\n    &lt;objects xmlns=\"http://www.springframework.net\"&gt;\n      &lt;object id=\"rdvmedecinsDao\" type=\"RdvMedecins.Dao.Dao,RdvMedecins-SqlServer-02\" /&gt;\n    &lt;/objects&gt;\n  &lt;/spring&gt;\n  &lt;!-- configuration common.logging --&gt;\n  &lt;logging&gt;\n    &lt;factoryAdapter type=\"Common.Logging.Simple.ConsoleOutLoggerFactoryAdapter, Common.Logging\"&gt;\n      &lt;arg key=\"showLogName\" value=\"true\" /&gt;\n      &lt;arg key=\"showDataTime\" value=\"true\" /&gt;\n      &lt;arg key=\"level\" value=\"DEBUG\" /&gt;\n      &lt;arg key=\"dateTimeFormat\" value=\"yyyy/MM/dd HH:mm:ss:fff\" /&gt;\n    &lt;/factoryAdapter&gt;\n  &lt;/logging&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Commen\u00e7ons par enlever tout ce qui est d\u00e9j\u00e0 connu\u00a0: Entity Framework, cha\u00eenes de connexion, ProviderFactory. Le fichier \u00e9volue comme suit\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;configSections&gt;\n    &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt;\n    &lt;section name=\"entityFramework\" ... /&gt;\n    &lt;!-- spring --&gt;\n    &lt;sectionGroup name=\"spring\"&gt;\n      &lt;section name=\"context\" type=\"Spring.Context.Support.ContextHandler, Spring.Core\" /&gt;\n      &lt;section name=\"objects\" type=\"Spring.Context.Support.DefaultSectionHandler, Spring.Core\" /&gt;\n    &lt;/sectionGroup&gt;\n    &lt;!-- common logging--&gt;\n    &lt;sectionGroup name=\"common\"&gt;\n      &lt;section name=\"logging\" type=\"Common.Logging.ConfigurationSectionHandler, Common.Logging\" /&gt;\n    &lt;/sectionGroup&gt;\n  &lt;/configSections&gt;\n...\n  &lt;!-- configuration Spring --&gt;\n  &lt;spring&gt;\n    &lt;context&gt;\n      &lt;resource uri=\"config://spring/objects\" /&gt;\n    &lt;/context&gt;\n    &lt;objects xmlns=\"http://www.springframework.net\"&gt;\n      &lt;object id=\"rdvmedecinsDao\" type=\"RdvMedecins.Dao.Dao,RdvMedecins-SqlServer-02\" /&gt;\n    &lt;/objects&gt;\n  &lt;/spring&gt;\n  &lt;!-- configuration common.logging --&gt;\n  &lt;common&gt;\n    &lt;logging&gt;\n      &lt;factoryAdapter type=\"Common.Logging.Simple.ConsoleOutLoggerFactoryAdapter, Common.Logging\"&gt;\n        &lt;arg key=\"showLogName\" value=\"true\" /&gt;\n        &lt;arg key=\"showDataTime\" value=\"true\" /&gt;\n        &lt;arg key=\"level\" value=\"DEBUG\" /&gt;\n        &lt;arg key=\"dateTimeFormat\" value=\"yyyy/MM/dd HH:mm:ss:fff\" /&gt;\n      &lt;/factoryAdapter&gt;\n    &lt;/logging&gt;\n  &lt;/common&gt;\n&lt;/configuration&gt;\n</code></pre> <ul> <li>lignes 3-15\u00a0: d\u00e9finissent des sections de configuration\u00a0;</li> <li>ligne 8\u00a0: d\u00e9finit la classe qui va g\u00e9rer la section &lt;spring&gt;&lt;context&gt; du fichier XML (lignes 19-21)\u00a0;</li> <li>ligne 9\u00a0: d\u00e9finit la classe qui va g\u00e9rer la section &lt;spring&gt;&lt;objects&gt; du fichier XML (lignes 22-24)\u00a0;</li> <li>ligne 13\u00a0: d\u00e9finit la classe qui va g\u00e9rer la section &lt;common&gt;&lt;logging&gt; du fichier XML (lignes 27-36)\u00a0;</li> <li>lignes 7-14\u00a0: sont stables. N'ont pas \u00e0 \u00eatre chang\u00e9es dans un autre projet\u00a0;</li> <li>lignes 18-25\u00a0: configuration Spring. Est stable sauf pour les lignes 22-24 qui d\u00e9finissent les objets que Spring sera amen\u00e9 \u00e0 instancier\u00a0;</li> <li>ligne 23\u00a0: d\u00e9finition d'un objet. L'attribut id est libre. C'est l'identifiant de l'objet. L'attribut type d\u00e9signe la classe \u00e0 instancier sous la forme \"\u00a0nom complet de la classe, Assembly qui contient la classe\". La classe ici est celle qui impl\u00e9mente la couche [DAO]\u00a0: [RdvMedecins.Dao.Dao]. Pour conna\u00eetre son assembly, il faut regarder les propri\u00e9t\u00e9s du projet\u00a0:</li> </ul> <p>En [1], le nom de l'assembly \u00e0 fournir\u00a0;</p> <ul> <li>lignes 27-36\u00a0: la configuration de \"\u00a0Common Logging\u00a0\" est stable. On peut \u00eatre amen\u00e9s \u00e0 modifier le niveau d'information, ligne 32. Apr\u00e8s la phase de d\u00e9bogage, on peut passer le niveau \u00e0 INFO.</li> </ul> <p>Au final, complexe au premier abord, le fichier de configuration de Spring s'av\u00e8re simple. Il n'y a \u00e0 modifier que\u00a0:</p> <ul> <li>les lignes 22-24 qui d\u00e9finissent les objets \u00e0 instancier\u00a0;</li> <li>ligne 32\u00a0: le niveau de logs.</li> </ul> <p>Dans le programme de test l'instruction qui instancie la couche [DAO]est la suivante\u00a0:</p> <pre><code>dao = ContextRegistry.GetContext().GetObject(\"rdvmedecinsDao\") as IDao;\n</code></pre> <p>[ContextRegistry] est une classe de Spring qui exploite la configuration de Spring faite dans un fichier [Web.config] ou [App.config]. Ici, elle va exploiter la section suivante du fichier [App.config]\u00a0:</p> <pre><code>  &lt;spring&gt;\n    &lt;context&gt;\n      &lt;resource uri=\"config://spring/objects\" /&gt;\n    &lt;/context&gt;\n    &lt;objects xmlns=\"http://www.springframework.net\"&gt;\n      &lt;object id=\"rdvmedecinsDao\" type=\"RdvMedecins.Dao.Dao,RdvMedecins-SqlServer-02\" /&gt;\n    &lt;/objects&gt;\n&lt;/spring&gt;\n</code></pre> <ul> <li>ContextRegistry.GetContext() exploite le contexte des lignes 2-4. La ligne 3 signifie que les objets Spring sont d\u00e9finis dans la section [spring/objects] du fichier de configuration. Cette section est lignes 5-7\u00a0;</li> <li>ContextRegistry.GetContext().GetObject(\"rdvmedecinsDao\") exploite la section des lignes 5-7. Elle ram\u00e8ne une r\u00e9f\u00e9rence sur l'objet qui a l'attribut id=\u00a0\"rdvmedecinsDao\u00a0\". C'est l'objet d\u00e9fini ligne 6. Spring va alors instancier la classe d\u00e9finie par l'attribut type en utilisant son constructeur sans param\u00e8tres. Celui-ci doit donc exister. Ceci fait, la r\u00e9f\u00e9rence de l'objet cr\u00e9\u00e9 est rendue au code appelant. Si l'objet est demand\u00e9 une seconde fois dans le code, Spring se contente de rendre une r\u00e9f\u00e9rence sur le premier objet cr\u00e9\u00e9. C'est le mod\u00e8le de conception (Design Pattern) appel\u00e9 singleton.</li> </ul> <p>La construction de l'objet peut \u00eatre plus complexe. On peut utiliser un constructeur avec param\u00e8tres ou pr\u00e9ciser l'initialisation de certains champs de l'objet une fois celui-ci cr\u00e9\u00e9. Pour plus d'informations sur ce sujet, on pourra lire l'article \"\u00a0Tutoriel Spring IOC pour .NET\u00a0\", \u00e0 l'URL [http://tahe.developpez.com/dotnet/springioc/].</p> <p>Ceci fait, nous pouvons ex\u00e9cuter l'application. Les r\u00e9sultats \u00e9cran sont les suivants\u00a0:</p> <pre><code>Liste des clients :\nClient[35,Mr,Jules,Martin,00000118981]\nClient[36,Mme,Christine,German,00000118982]\nClient[37,Mr,Jules,Jacquard,00000118983]\nClient[38,Melle,Brigitte,Bistrou,00000118984]\nListe des m\u00e9decins :\nMedecin[26,Mme,Marie,Pelissier,00000118985]\nMedecin[27,Mr,Jacques,Bromard,000001189110]\nMedecin[28,Mr,Philippe,Jandot,000001189123]\nMedecin[29,Melle,Justine,Jacquemot,000001189124]\nListe des cr\u00e9neaux horaires du m\u00e9decin Medecin[26,Mme,Marie,Pelissier,00000118985]\nCreneau[218,8,0,8,20, 26, 00000118986]\nCreneau[219,8,20,8,40, 26, 00000118987]\nCreneau[220,8,40,9,0, 26, 00000118988]\nCreneau[221,9,0,9,20, 26, 00000118989]\nCreneau[222,9,20,9,40, 26, 00000118990]\nCreneau[223,9,40,10,0, 26, 00000118991]\nCreneau[224,10,0,10,20, 26, 00000118992]\nCreneau[225,10,20,10,40, 26, 00000118993]\nCreneau[226,10,40,11,0, 26, 00000118994]\nCreneau[227,11,0,11,20, 26, 00000118995]\nCreneau[228,11,20,11,40, 26, 00000118996]\nCreneau[229,11,40,12,0, 26, 00000118997]\nCreneau[230,14,0,14,20, 26, 00000118998]\nCreneau[231,14,20,14,40, 26, 00000118999]\nCreneau[232,14,40,15,0, 26, 000001189100]\nCreneau[233,15,0,15,20, 26, 000001189101]\nCreneau[234,15,20,15,40, 26, 000001189102]\nCreneau[235,15,40,16,0, 26, 000001189103]\nCreneau[236,16,0,16,20, 26, 000001189104]\nCreneau[237,16,20,16,40, 26, 000001189105]\nCreneau[238,16,40,17,0, 26, 000001189106]\nCreneau[239,17,0,17,20, 26, 000001189107]\nCreneau[240,17,20,17,40, 26, 000001189108]\nCreneau[241,17,40,18,0, 26, 000001189109]\nListe des RV du m\u00e9decin Medecin[26,Mme,Marie,Pelissier,00000118985], le 23/11/2013 :\nAjout d'un RV au m\u00e9decin Medecin[26,Mme,Marie,Pelissier,00000118985] avec client  Client[35,Mr,Jules,Martin,00000118981] le 23/11/2013\nRdv ajout\u00e9\nListe des RV du m\u00e9decin Medecin[26,Mme,Marie,Pelissier,00000118985], le 23/11/2013 :\nRv[28,23/11/2013 00:00:00,35,218,00000289145]\nAjout d'un RV dans un cr\u00e9neau d\u00e9j\u00e0 occup\u00e9\nL'erreur suivante s'est produite : RdvMedecinsException[7,AjouterRv,Une erreur s'est produite lors de la mise \u00e0 jour des entr\u00e9es. Pour plus d'informations, consultez l'exception interne.]\nSuppression du RV n\u00b0 28\nListe des RV du m\u00e9decin Medecin[26,Mme,Marie,Pelissier,00000118985], le 23/11/2013 :\n</code></pre> <p>Les r\u00e9sultats sont conformes \u00e0 ce qui \u00e9tait attendu. On consid\u00e8rera d\u00e9sormais que notre couche [DAO] est valide. Le tutoriel pourrait s'arr\u00eater l\u00e0. Nous avons montr\u00e9 jusqu'\u00e0 maintenant\u00a0:</p> <ul> <li>les bases de l'ORM Entity Framework 5\u00a0;</li> <li>une couche [DAO] utilisant cet ORM.</li> </ul> <p>Rappelons notre \u00e9tude de cas d\u00e9crite au d\u00e9but de ce document. Nous partons d'une application existante \u00e0 l'architecture suivante\u00a0:</p> <p>que nous voulons transformer en celle-ci\u00a0:</p> <p>o\u00f9 EF5 a remplac\u00e9 NHibernate. Nous venons de construire la couche [DAO2]. En fait elle ne pr\u00e9sente pas la m\u00eame interface que la couche [DAO1] dont l'interface \u00e9tait plus r\u00e9duite\u00a0:</p> <pre><code>  public interface IDao\n  {\n    // liste des clients\n    List&lt;Client&gt; GetAllClients();\n    // liste des m\u00e9decins\n    List&lt;Medecin&gt; GetAllMedecins();\n    // liste des cr\u00e9neaux horaires d'un m\u00e9decin\n    List&lt;Creneau&gt; GetCreneauxMedecin(int idMedecin);\n    // liste des RV d'un m\u00e9decin donn\u00e9, un jour donn\u00e9\n    List&lt;Rv&gt; GetRvMedecinJour(int idMedecin, DateTime jour);\n    // ajouter un RV\n    int AjouterRv(DateTime jour, int idCreneau, int idClient);\n    // supprimer un RV\n    void SupprimerRv(int idRv);\n  }\n</code></pre> <p>La couche [DAO2] a rajout\u00e9 \u00e0 cette interface la m\u00e9thode\u00a0:</p> <pre><code>// trouver une entit\u00e9 T via sa cl\u00e9 primaire\nT Find&lt;T&gt;(int id) where T : class;\n</code></pre> <p>L'ajout de cette m\u00e9thode vient du fait que l'ORM EF 5 travaille par d\u00e9faut en mode Lazy Loading. Les entit\u00e9s arrivent dans la couche [ASP.NET] sans leurs d\u00e9pendances. La m\u00e9thode ci-dessus nous permet de les r\u00e9cup\u00e9rer si on en a besoin et dans certains cas on en a besoin. NHibernate travaille \u00e9galement par d\u00e9faut en mode Lazy Loading mais je l'avais utilis\u00e9 en mode Eager Loading. Les entit\u00e9s arrivaient dans la couche [ASP.NET] avec leurs d\u00e9pendances.</p> <p>Nous allons terminer le portage de l'application ASP.NET / NHibernate vers l'application ASP.NET / EF 5. Mais comme cela ne concerne plus EF5, nous ne commenterons pas le code web. Nous expliquerons simplement comment mettre en place l'application web et la tester. Celle-ci est disponible sur le site de ce tutoriel.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#366-generation-de-la-dll-de-la-couche-dao","title":"3.6.6. G\u00e9n\u00e9ration de la DLL de la couche [DAO]","text":"<p>Dans l'architecture suivante\u00a0:</p> <p>la couche [ASP.NET] aura \u00e0 sa disposition les couches \u00e0 sa droite sous la forme de DLL. Nous construisons donc la DLL de la couche [DAO].</p> <ul> <li>en [1], on s\u00e9lectionne le programme de test et en [2] on ne l'inclut pas dans la DLL qui va \u00eatre g\u00e9n\u00e9r\u00e9e\u00a0;</li> <li>en [3], dans les propri\u00e9t\u00e9s du projet, on indique que l'assembly \u00e0 cr\u00e9er est une DLL\u00a0;</li> <li>en [4], dans le menu de VS, on indique qu'on va g\u00e9n\u00e9rer un assembly de type [Release] qui contient moins d'informations qu'un assembly de type [Debug]\u00a0;</li> </ul> <ul> <li>en [5], on r\u00e9g\u00e9n\u00e8re l'assembly du projet. La DLL va \u00eatre g\u00e9n\u00e9r\u00e9e\u00a0;</li> <li>en [6], on fait afficher tous les fichiers du projet\u00a0;</li> </ul> <ul> <li>en [7], la DLL du projet de la couche [DAO]. C'est celle-ci que le projet web ASP.NET utilisera\u00a0;</li> <li>en [8], nous rafra\u00eechissons l'affichage du projet\u00a0;</li> </ul> <ul> <li>en [9], les DLL du dossier [Release] sont rassembl\u00e9es dans un dossier [lib] externe [10]. C'est l\u00e0 que le projet web ira chercher ses r\u00e9f\u00e9rences.</li> </ul>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#367-la-couche-aspnet","title":"3.6.7. La couche [ASP.NET]","text":"<p>Nous allons ici expliquer le portage de l'application [ASP.NET / NHibernate] vers l'application [ASP.NET / EF 5]. Nous allons travailler avec Visual Studio Express 2012 pour le web disponible gratuitement \u00e0 l'URL [http://www.microsoft.com/visualstudio/fra/downloads].</p> <p>Nous allons travailler \u00e0 partir du projet web existant cr\u00e9\u00e9 avec VS 2010.</p> <ul> <li>en [1], on ouvre le projet existant\u00a0:</li> <li>en [2], le projet charg\u00e9 a les r\u00e9f\u00e9rences suivantes [3]\u00a0:</li> <li>[NHibernate] est la DLL du framework NHibernate,</li> <li>[Spring.Core] est la DLL du framework Spring.net,</li> <li>[log4net] est la DLL du framework de logs log4net. Ce framework est utilis\u00e9 par Spring.net,</li> <li>[MySql.Data] est le pilote ADO.NET du SGBD MySQL,</li> <li>[rdvmedecins] est la DLL de la couche [DAO] construite avec NHibernate\u00a0;</li> <li>en [4], nous changeons le nom du projet et en [5], nous supprimons les r\u00e9f\u00e9rences pr\u00e9c\u00e9dentes\u00a0;</li> </ul> <ul> <li>en [6], nous ajoutons des r\u00e9f\u00e9rences au projet\u00a0;</li> <li>en [7], dans l'assistant nous utilisons l'option [Parcourir]\u00a0;</li> </ul> <ul> <li>en [8], nous s\u00e9lectionnons toutes les DLL du projet n\u00b0 2 mises pr\u00e9c\u00e9demment dans le dossier [lib]\u00a0;</li> <li>en [9], un r\u00e9capitulatif que nous validons\u00a0;</li> <li>en [10], le projet web avec ses nouvelles r\u00e9f\u00e9rences.</li> </ul> <p>Ceci fait, le projet se pr\u00e9sente de la fa\u00e7on suivante\u00a0:</p> <ul> <li>en [1], le code de gestion des pages web est r\u00e9parti sur les deux fichiers [Global.asax] et [Default.aspx]. Du code utilitaire a \u00e9t\u00e9 plac\u00e9 dans le dossier [Entites]. Enfin l'application est configur\u00e9e par le fichier [Web.config]\u00a0;</li> <li>en [2], nous g\u00e9n\u00e9rons l'assembly du projet\u00a0;</li> <li>en [3], des erreurs apparaissent.</li> </ul> <p>Examinons les erreurs, par exemple la suivante\u00a0:</p> <p></p> <p>et son explication\u00a0:</p> <p></p> <p>Le type de [medecin.Id] est int? alors que la m\u00e9thode [GetCreneauxMedecin] est de type int. Il faut donc un cast. Cette erreur est r\u00e9currente dans tout le code car les entit\u00e9s du projet ASP.NET / NHibernate avaient des cl\u00e9s primaires de type int alors que celles du projet ASP.NET / EF 5 sont de type int?. On corrige toutes les erreurs de ce type et on r\u00e9g\u00e9n\u00e8re le projet. Il n'y en a alors plus.</p> <p>Il nous reste un d\u00e9tail \u00e0 r\u00e9gler avant d'ex\u00e9cuter le projet\u00a0: l'instanciation de la couche [DAO] par le framework Spring. Celle-ci est faite dans [Global.asax]\u00a0:</p> <pre><code>protected void Application_Start(object sender, EventArgs e)\n    {\n      // on met en cache certaines donn\u00e9es de la base de donn\u00e9es\n      try\n      {\n        // instanciation couche [dao]\n        Dao = ContextRegistry.GetContext().GetObject(\"rdvmedecinsDao\") as IDao;\n        ...\n      }\n      catch (Exception ex)\n      {...\n      }\n    }\n</code></pre> <p>Dans le programme de test de la couche [DAO], celui-ci instanciait la couche [DAO] de la fa\u00e7on suivante\u00a0:</p> <pre><code>dao = ContextRegistry.GetContext().GetObject(\"rdvmedecinsDao\") as IDao;\n</code></pre> <p>Les deux m\u00e9thodes sont identiques. On se rappelle que cette instanciation de la couche [DAO] s'appuyait sur une configuration faite dans [App.config]. On remplace alors le contenu actuel [Web.config] du projet web par celui de [App.config] du projet de la couche [DAO] afin d'avoir la m\u00eame configuration.</p> <p>Nous sommes pr\u00eats pour une premi\u00e8re ex\u00e9cution. La page d'accueil est affich\u00e9e [1]\u00a0:</p> <ul> <li>en [2], on entre un jour de rendez-vous et on valide\u00a0;</li> </ul> <ul> <li>en [3], une erreur.</li> </ul> <p>Lorsqu'on examine le texte d'erreur affich\u00e9 par la page, on s'aper\u00e7oit que l'exception signal\u00e9e est celle du Lazy Loading\u00a0: on a essay\u00e9 de charger une d\u00e9pendance d'un objet alors que le contexte de persistance qui le g\u00e8re a \u00e9t\u00e9 ferm\u00e9. L'objet est maintenant dans un \u00e9tat \"\u00a0d\u00e9tach\u00e9\u00a0\". Cette erreur est due au fait que par que NHibernate avait \u00e9t\u00e9 utilis\u00e9 en mode Eager Loading alors que EF 5 travaille par d\u00e9faut en Lazy Loading. Sur la ligne en rouge ci-dessus\u00a0:</p> <ul> <li>rdv repr\u00e9sente un objet [Rv] qui a \u00e9t\u00e9 charg\u00e9 sans ses d\u00e9pendances\u00a0;</li> <li>pour \u00e9valuer rdv.Creneau.Id, l'application essaie de charger la d\u00e9pendance rdv.Creneau. Mais comme on n'est plus dans le contexte, ce n'est pas possible, d'o\u00f9 l'exception.</li> </ul> <p>Ici, la solution est simple. Ligne 108, On cr\u00e9e une entr\u00e9e dans un dictionnaire avec pour cl\u00e9 la cl\u00e9 primaire du cr\u00e9neau d'un rendez-vous. Or il se trouve que l'entit\u00e9 [Rv] encapsule la cl\u00e9 primaire du cr\u00e9neau associ\u00e9. On \u00e9crit donc\u00a0:</p> <pre><code>        dicoRvPris[(int)rdv.CreneauId] = rdv;\n</code></pre> <p>Nous r\u00e9essayons l'ex\u00e9cution. Cette fois-ci l'erreur est la suivante\u00a0:</p> <p>L'erreur est analogue. Ligne 132, on essaie de charger la d\u00e9pendance [Client] d'un objet [Rv] dans la couche ASP.NET, donc hors contexte. Il faut aller chercher l'objet [Client] en base. C'est pour rem\u00e9dier \u00e0 ce probl\u00e8me, que l'interface [IDao] a \u00e9t\u00e9 enrichie de la m\u00e9thode suivante\u00a0:</p> <pre><code>    // trouver une entit\u00e9 T via sa cl\u00e9 primaire\n    T Find&lt;T&gt;(int id) where T : class;\n</code></pre> <p>Elle va permettre d'aller chercher les d\u00e9pendances. Ainsi la ligne erron\u00e9e ci-dessus va \u00eatre r\u00e9\u00e9crite de la fa\u00e7on suivante\u00a0:</p> <pre><code>        Client client = Global.Dao.Find&lt;Client&gt;(agenda.Creneaux[i].Rdv.ClientId);\n</code></pre> <p>De nouveau on notera l'int\u00e9r\u00eat que les entit\u00e9s embarquent leurs cl\u00e9s \u00e9trang\u00e8res. Ici, l'entit\u00e9 [Rv] nous donne acc\u00e8s \u00e0 la cl\u00e9 \u00e9trang\u00e8re de la d\u00e9pendance [Creneau] associ\u00e9e. Ces deux corrections faites, l'application marche. Le lecteur est invit\u00e9 \u00e0 tester l'application [RdvMedecins-SqlServer-03] pr\u00e9sente dans les t\u00e9l\u00e9chargements des exemples du site web de cet article.</p>"},{"location":"etude-de-cas-avec-sql-server-express-2012.html#37-conclusion","title":"3.7. Conclusion","text":"<p>Nous avons men\u00e9 \u00e0 bien le portage d'une application ASP.NET / NHibernate\u00a0:</p> <p>vers une application ASP.NET / EF 5\u00a0:</p> <p>Alors que cette architecture aurait du nous permettre de garder intacte la couche [ASP.NET], nous avons du la modifier pour deux raisons\u00a0:</p> <ul> <li>les entit\u00e9s n'\u00e9taient pas exactement les m\u00eames. Le type des cl\u00e9s primaires des entit\u00e9s NHibernate \u00e9tait int alors que celui de EF 5 \u00e9tait int?. Cela nous a amen\u00e9s \u00e0 introduire des cast dans le code web\u00a0;</li> <li>le mode de chargement des entit\u00e9s n'\u00e9tait pas le m\u00eame pour les deux ORM\u00a0: Eager Loading pour NHibernate, Lazy loading pour EF 5. Cela nous a amen\u00e9s \u00e0 enrichir l'interface de la couche [DAO] avec une m\u00e9thode g\u00e9n\u00e9rique permettant d'aller chercher une entit\u00e9 via sa cl\u00e9 primaire.</li> </ul> <p>N\u00e9anmoins, le portage s'est r\u00e9v\u00e9l\u00e9 plut\u00f4t simple justifiant de nouveau, si besoin \u00e9tait, l'architecture en couches et l'injection de d\u00e9pendances avec Spring ou un autre framework d'injection de d\u00e9pendances.</p> <p>Nous allons mesurer maintenant l'impact d'un changement de SGBD sur l'architecture pr\u00e9c\u00e9dente. Nous allons porter l'ensemble des projets pr\u00e9c\u00e9dents vers quatre autres SGBD\u00a0:</p> <ul> <li>Oracle Database Express Edition 11g Release 2\u00a0;</li> <li>MySQL 5.5.28\u00a0;</li> <li>PostgreSQL 9.2.1\u00a0;</li> <li>Firebird 2.1. </li> </ul> <p>Les codes ne vont plus changer. Seuls les \u00e9l\u00e9ments suivants vont changer\u00a0:</p> <ul> <li>la d\u00e9finition dans les entit\u00e9s du champ utilis\u00e9 pour contr\u00f4ler la concurrence d'acc\u00e8s \u00e0 une entit\u00e9\u00a0;</li> <li>les fichiers de configuration [App.config] ou [Web.config]\u00a0;</li> </ul> <p>Nous ne commenterons que les \u00e9l\u00e9ments qui changent.</p>"},{"location":"introduction.html","title":"1. Introduction","text":""},{"location":"introduction.html#11-objectif","title":"1.1. Objectif","text":"<p>Entity Framework est un ORM (Object Relational Mapper) initialement cr\u00e9\u00e9 par Microsoft et maintenant disponible en open source [juillet 2012, http://entityframework.codeplex.com/]. Dans un cours ASP.NET j'utilise l'architecture suivante pour une certaine application web\u00a0:</p> <p>Le framework NHibernate [http://sourceforge.net/projects/nhibernate/] est un ORM apparu avant Entity Framework. C'est un produit mature permettant de se connecter \u00e0 diverses bases de donn\u00e9es. L'ORM isole la couche [DAO] (Data Access Objects) du connecteur ADO.NET. C'est l'ORM qui \u00e9met les ordres SQL \u00e0 destination du connecteur. La couche [DAO] utilise elle l'interface offerte par l'ORM. Celle-ci d\u00e9pend de l'ORM. Ainsi changer d'ORM implique de changer la couche [DAO].</p> <p>Cette architecture r\u00e9siste bien aux changements de SGBD.</p> <p>Lorsqu'on relie la couche [DAO] directement au connecteur ADO.NET, changer de SGBD a un impact sur la couche [DAO]\u00a0:</p> <ul> <li>les SGBD n'ont pas tous les m\u00eames types de donn\u00e9es\u00a0;</li> <li>les SGBD n'ont pas les m\u00eames strat\u00e9gies de g\u00e9n\u00e9ration des cl\u00e9s primaires\u00a0;</li> <li>les SGBD ont du SQL propri\u00e9taire\u00a0;</li> <li>la couche [DAO] a pu utiliser des biblioth\u00e8ques li\u00e9es \u00e0 un SGBD pr\u00e9cis\u00a0;</li> <li>...</li> </ul> <p>Lorsque c'est un ORM qui est reli\u00e9 au connecteur ADO.NET, changer de SGBD revient \u00e0 changer la configuration de l'ORM pour l'adapter au nouveau SGBD. La couche [DAO] ne change pas.</p> <p>Le framework Spring.NET [http://www.springframework.net/index.html] assure l'int\u00e9gration des couches d'une application. Ci-dessus\u00a0: </p> <ul> <li>l'application ASP.NET demande \u00e0 Spring une r\u00e9f\u00e9rence sur la couche [DAO]\u00a0;</li> <li>Spring exploite un fichier de configuration pour cr\u00e9er cette couche et en rendre la r\u00e9f\u00e9rence.</li> </ul> <p>Cette architecture r\u00e9siste bien aux changements de couches tant que celles-ci pr\u00e9sentent toujours la m\u00eame interface. Changer la couche [DAO] ci-dessus, consiste \u00e0 changer le fichier de configuration de Spring pour que la nouvelle couche soit instanci\u00e9e \u00e0 la place de l'ancienne. Comme celles-ci impl\u00e9mentent la m\u00eame interface et que la couche ASP.NET utilise cette interface, la couche ASP.NET reste inchang\u00e9e.</p> <p>On a donc l\u00e0 une architecture souple et \u00e9volutive. Pour le montrer, nous allons remplacer l'ORM NHibernate par Entity Framework 5\u00a0:</p> <p>Nous allons proc\u00e9der en plusieurs \u00e9tapes\u00a0:</p> <ul> <li>on va d\u00e9couvrir Entity Framework 5 avec plusieurs SGBD\u00a0;</li> <li>on construira la couche [DAO2]\u00a0;</li> <li>on connectera l'application ASP.NET existante \u00e0 cette nouvelle couche [DAO].</li> </ul>"},{"location":"introduction.html#12-les-outils-utilises","title":"1.2. Les outils utilis\u00e9s","text":"<p>Les tests ont \u00e9t\u00e9 r\u00e9alis\u00e9s sur un portable HP EliteBook avec Windows 7 pro, un processeur Intel Core i7, 8 Go de RAM. Nous utiliserons C# comme langage de d\u00e9veloppement.</p> <p>Le document utilise les outils suivants tous disponibles gratuitement\u00a0:</p> <p>Les IDE de d\u00e9veloppement\u00a0:</p> <ul> <li>Visual Studio Express pour le bureau 2012 [http://www.microsoft.com/visualstudio/fra/downloads]\u00a0;</li> <li>Visual Studio Express pour le web 2012 [http://www.microsoft.com/visualstudio/fra/downloads].</li> </ul> <p>Le SGBD SQL Server Express 2012 \u00a0:</p> <ul> <li>le SGBD : [http://www.microsoft.com/fr-fr/download/details.aspx?id=29062]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for SQL Server Freeware [http://www.sqlmanager.net/fr/products/mssql/manager/download].</li> </ul> <p>Le SGBD Oracle Database Express Edition 11g Release 2\u00a0:</p> <ul> <li>le SGBD\u00a0: [http://www.oracle.com/technetwork/products/express-edition/downloads/index.html]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for Oracle Freeware [http://www.sqlmanager.net/fr/products/oracle/manager/download]\u00a0;</li> <li>un client Oracle pour .NET : ODAC 11.2 Release 5 (11.2.0.3.20) with Oracle Developer Tools for Visual Studio\u00a0: [http://www.oracle.com/technetwork/developer-tools/visual-studio/downloads/index.html].</li> </ul> <p>Le SGBD MySQL 5.5.28\u00a0:</p> <ul> <li>le SGBD\u00a0: [http://dev.mysql.com/downloads/]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for MySQL Freeware [http://www.sqlmanager.net/fr/products/mysql/manager/download].</li> </ul> <p>Le SGBD PostgreSQL 9.2.1\u00a0:</p> <ul> <li>le SGBD\u00a0: [http://www.enterprisedb.com/products-services-training/pgdownload#windows]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for PostgreSQL Freeware [http://www.sqlmanager.net/fr/products/postgresql/manager/download].</li> </ul> <p>Le SGBD Firebird 2.1\u00a0:</p> <ul> <li>le SGBD\u00a0: [http://www.firebirdsql.org/en/firebird-2-1-5/]\u00a0;</li> <li>un outil d'administration\u00a0: EMS SQL Manager for InterBase/Firebird Freeware [http://www.sqlmanager.net/fr/products/ibfb/manager/download].</li> </ul> <p>LINQPad 4\u00a0: un outil d'apprentissage de LINQ (Language INtegrated Query)\u00a0[http://www.linqpad.net/, http://www.linqpad.net/GetFile.aspx?LINQPad4.zip].</p>"},{"location":"introduction.html#13-les-codes-source","title":"1.3. Les codes source","text":"<p>Les codes source des exemples qui vont suivre sont disponibles \u00e0 l'URL [http://tahe.developpez.com/dotnet/ef5cf].</p> <p>Ce sont des projets Visual Studio 2012 [1], rassembl\u00e9s dans une solution [2]. Dans un dossier [databases], on trouvera un dossier par SGBD utilis\u00e9. On y trouve les scripts SQL de g\u00e9n\u00e9ration de la base exemple pour ces SGBD.</p>"},{"location":"introduction.html#14-la-methode","title":"1.4. La m\u00e9thode","text":"<p>Pour d\u00e9couvrir Entity Framework 5 Code First, je suis d'abord parti du livre suivant\u00a0: \"\u00a0Professional ASP.NET MVC 3\u00a0\" de Jon Galloway, Phil Haack, Brad Wilson, Scott Allen aux \u00e9ditions Wrox. Dans l'application exemple de ce livre, les auteurs utilisent  Entity Framework (EF) comme ORM. Comme je ne connaissais pas, j'ai parcouru le net pour en savoir plus. J'ai ainsi d\u00e9couvert que la version la plus r\u00e9cente \u00e9tait EF 5 et qu'il y avait des incompatibilit\u00e9s avec EF 4 car le code du livre test\u00e9 avec EF 5 pr\u00e9sentait des erreurs de compilation.</p> <p>J'ai ensuite d\u00e9couvert qu'il y avait plusieurs fa\u00e7ons d'utiliser EF\u00a0:</p> <ul> <li>Model First\u00a0: il existe de nombreux articles sur cette approche de EF, par exemple [http://msdn.microsoft.com/en-us/data/ff830362.aspx]. Cet article est introduit de la fa\u00e7on suivante\u00a0:</li> </ul> <p>Summary: In this paper we'll look at the new Entity Framework 4 that ships with .NET Framework 4 and Visual Studio 2010. I'll discuss how you can approach it's usage from a model-first perspective with the premise that you can drive database design from a\u00a0model and build both your database as well as your data access layer declaratively from this model. The model contains the description of your data represented as entities and relationships providing a powerful approach to working with ADO.NET, creating a separation of concerns through an abstraction between a model definition and its implementation.</p> <p>Un ORM fait le pont entre des tables de bases de donn\u00e9es et des classes.</p> <p>Ci-dessus,</p> <ul> <li>\u00e0 gauche de la couche EF5, on a des objets, qu'on appelle des entit\u00e9s\u00a0;</li> <li>\u00e0 droite de la couche EF5, on a des tables de base de donn\u00e9es.</li> </ul> <p>La couche [DAO] travaille avec des objets images des tables de la base de donn\u00e9es. Ces objets sont rassembl\u00e9s dans un contexte de persistance et sont appel\u00e9s entit\u00e9s (Entity). Les modifications faites sur les entit\u00e9s sont r\u00e9percut\u00e9es, gr\u00e2ce \u00e0 l'ORM, sur les tables de la base de donn\u00e9es (insertion, modification, suppression). De plus la couche [DAO] dispose d'un langage de requ\u00eatage LINQ to Entity (Language INtegrated Query) qui requ\u00eate sur les entit\u00e9s et non sur les tables. La m\u00e9thode Model First consiste \u00e0 construire les entit\u00e9s avec un outil graphique. On d\u00e9finit chaque entit\u00e9 et les relations qui la lient avec les autres. Ceci fait, un outil permet de g\u00e9n\u00e9rer\u00a0:</p> <ul> <li>les diff\u00e9rentes classes refl\u00e9tant les entit\u00e9s construites graphiquement\u00a0;</li> <li>la DDL (Data Definition Language) permettant de g\u00e9n\u00e9rer la base de donn\u00e9es.</li> </ul> <p>Les exemples que j'ai trouv\u00e9s sur cette m\u00e9thode utilisaient tous Visual Studio 2010 Professional et un mod\u00e8le appel\u00e9 ADO.NET Entity Data Model. J'ai pu tester ce mod\u00e8le avec Visual Studio 2010 Professional mais lorsque je suis pass\u00e9 \u00e0 Visual Studio Express 2012 qui \u00e9tait ma cible, j'ai constat\u00e9 que ce mod\u00e8le n'\u00e9tait plus disponible. J'ai donc abandonn\u00e9 cette approche.</p> <ul> <li>Database First\u00a0: le point de d\u00e9part de cette m\u00e9thode est une base de donn\u00e9es existante. A partir de l\u00e0, un outil g\u00e9n\u00e8re automatiquement les entit\u00e9s images des tables de la base. L\u00e0 encore les exemples trouv\u00e9s, par exemple [http://msdn.microsoft.com/en-us/data/gg685489.aspx], utilisent Visual Studio 2010 Professional et le mod\u00e8le ADO.NET Entity Data Model. J'ai donc abandonn\u00e9 \u00e9galement cette approche qui \u00e9tait pourtant ma pr\u00e9f\u00e9r\u00e9e. Pour savoir quelles entit\u00e9s utiliser comme images d'une base de donn\u00e9es existante, il \u00e9tait simple de commencer avec un outil qui les g\u00e9n\u00e8re.</li> <li>Code First\u00a0: on \u00e9crit soi-m\u00eame les classes qui vont former les entit\u00e9s. Il faut alors avoir un minimum de notions sur le fonctionnement d'EF. C'est la voie que j'ai suivie parce qu'elle \u00e9tait exploitable avec Visual Studio Express 2012.</li> </ul> <p>Ceci acquis, j'ai travaill\u00e9 de la fa\u00e7on suivante\u00a0:</p> <ul> <li>j'\u00e9crivais un code pour SQL Server Express 2012 car c'est pour ce SGBD qu'on trouve le plus grand nombre d'exemples\u00a0;</li> <li>une fois ce code d\u00e9bogu\u00e9, je le portais sur les autres SGBD (Firebird, Oracle, MySQL, PostgreSQL).</li> </ul> <p>Nous allons ici proc\u00e9der diff\u00e9remment. Je vais d'abord d\u00e9crire la totalit\u00e9 des codes pour SQL Server puis je d\u00e9crirai leur portage pour les autres SGBD. Dans ce portage, les ajustements suivants ont lieu\u00a0:</p> <ul> <li>les bases de donn\u00e9es ont des particularit\u00e9s propri\u00e9taires. J'ai notamment utilis\u00e9 des Triggers pour g\u00e9n\u00e9rer le contenu de certains colonnes de fa\u00e7on automatique. Chaque SGBD a sa fa\u00e7on propre de g\u00e9rer cela\u00a0;</li> <li>les entit\u00e9s images des tables peuvent changer mais c'est alors volontaire. J'aurais pu choisir des entit\u00e9s convenant \u00e0 toutes les bases de donn\u00e9es\u00a0;</li> <li>le pilote ADO.NET du SGBD change\u00a0;</li> <li>la cha\u00eene de connexion au SGBD change.</li> </ul> <p>La progression adopt\u00e9e est la suivante\u00a0:</p> <ul> <li>association entit\u00e9s / base de donn\u00e9es. Remplissage de la base\u00a0;</li> <li>dump de la base avec des requ\u00eates LINQ\u00a0;</li> <li>LINQPad, un outil d'apprentissage de LINQ\u00a0;</li> <li>ajout, suppression, modification d'entit\u00e9s\u00a0;</li> <li>gestion de la concurrence d'acc\u00e8s\u00a0;</li> <li>contexte de persistance sauvegard\u00e9 dans une transaction\u00a0;</li> <li>modification d'une entit\u00e9 hors contexte de persistance\u00a0;</li> <li>Eager et Lazy loading\u00a0;</li> <li>construction de la couche [DAO]\u00a0;</li> <li>construction de la couche web ASP.NET.</li> </ul>"},{"location":"introduction.html#15-public-vise","title":"1.5. Public vis\u00e9","text":"<p>Le public vis\u00e9 est celui des d\u00e9butants.</p> <p>Ce document n'est pas un cours sur Entity Framework 5 Code First. Pour cela, on pourra lire par exemple \"\u00a0Programming Entity Framework: Code First\u00a0\", de Julie Lerman et Rowan Miller aux \u00e9ditions O'Reilly. Le document ne vise aucunement  l'exhaustivit\u00e9 mais expose simplement la d\u00e9marche que j'ai utilis\u00e9e pour appr\u00e9hender cet ORM. Je pense que celle-ci peut servir \u00e0 d'autres personnes abordant EF5. Mon objectif ne d\u00e9passe pas ce cadre.</p>"},{"location":"introduction.html#16-articles-connexes-sur-developpezcom","title":"1.6. Articles connexes sur developpez.com","text":"<p>Le livre cit\u00e9 ci-dessus servira de r\u00e9f\u00e9rence. Il existe par ailleurs des articles consacr\u00e9s \u00e0 Entity Framework sur developpez.com. En voici quelques-uns\u00a0:</p> <ul> <li>\"\u00a0Entity Framework \u2013 l'approche Code First\u00a0\", juin 2012 \u2013 par Reward. Cet article et le pr\u00e9sent document se recoupent partiellement. Il va cependant plus loin sur certains points notamment sur le \"\u00a0mapping\u00a0\" h\u00e9ritage de classes &lt;--&gt; tables\u00a0;</li> <li>\"\u00a0Introduction \u00e0 Entity Framework\u00a0\", d\u00e9cembre 2008, par Paul Musso\u00a0;</li> <li>\"\u00a0Cr\u00e9er un mod\u00e8le de classes avec Entity Framework\u00a0\", avril 2009, par J\u00e9r\u00f4me Lambert\u00a0;</li> <li>\"\u00a0Mesure des performances de Linq to SQL face \u00e0 Sql et Entity Framework\u00a0\", juin 2011, d'Immobilis\u00a0;</li> <li>\"\u00a0Entity Framework Code First : activer la migration automatique\u00a0\", juin 2012, par Hinault Romaric\u00a0;</li> <li>\"\u00a0Cr\u00e9ation d'une application CRUD avec WebMatrix, Razor et Entity Framework\u00a0\", mai 2012, par Hinault Romaric\u00a0;</li> <li>\"\u00a0Entity Framework : \u00e0 la d\u00e9couverte de Code First Migrations\u00a0\", juin 2012,  par Hinault Romaric\u00a0;</li> </ul> <p>Comme indiqu\u00e9 plus haut, le document pr\u00e9sent n'est pas exhaustif. On lira avec profit les articles ci-dessus pour combler certaines lacunes. Ma recherche a pu \u00eatre incompl\u00e8te. Que les auteurs que j'ai pu oublier veuillent bien m'excuser.</p>"},{"location":"letude-de-cas.html","title":"2. L'\u00e9tude de cas","text":""},{"location":"letude-de-cas.html#21-le-probleme","title":"2.1. Le probl\u00e8me","text":"<p>Revenons \u00e0 l'application que nous voulons construire. Nous partons d'une application existante \u00e0 l'architecture suivante\u00a0:</p> <p>Pour ceux qui veulent en savoir plus sur\u00a0:</p> <ul> <li>NHibernate\u00a0: Introduction \u00e0 l'ORM Nhibernate [http://tahe.developpez.com/dotnet/nhibernate/]\u00a0;</li> <li>application ASP.NET (WebForms) avec NHibernate et Spring \u00a0: Construction d'une application web \u00e0 trois couches avec ASP.NET, Spring.NET et NHibernate [http://tahe.developpez.com/dotnet/pam-aspnet/].</li> </ul> <p>Nous voulons transformer l'application pr\u00e9c\u00e9dente en celle-ci\u00a0:</p> <p>o\u00f9 EF5 a remplac\u00e9 NHibernate. Cette application est un pr\u00e9texte pour \u00e9tudier EF5. Parce que Spring.NET nous permet facilement de changer de couche sans tout casser, l'application 2 utilisera la m\u00eame couche [ASP.NET] que l'application 1. Parce que ce document est consacr\u00e9 \u00e0 EF5, nous n'expliquerons pas l'\u00e9criture de cette couche. Nous l'introduirons dans l'application 2 pour constater que \u00e7a marche. Nous expliquerons simplement les changements \u00e0 op\u00e9rer dans le fichier de configuration de Spring.NET.</p> <p>L'\u00e9tude de cas est la suivante. On souhaite proposer \u00e0 des m\u00e9decins un service de prise de rendez-vous fonctionnant sur le principe suivant :</p> <ul> <li>un service secr\u00e9tariat assure les prises de RV pour un grand nombre de m\u00e9decins. Ce service peut \u00eatre r\u00e9duit \u00e0 une unique personne. Le salaire de celle-ci est mutualis\u00e9 entre tous les m\u00e9decins utilisant le service de RV\u00a0;</li> <li>le service secr\u00e9tariat et tous les m\u00e9decins sont reli\u00e9s \u00e0 Internet\u00a0;</li> <li>les RV sont enregistr\u00e9s dans une base de donn\u00e9es centralis\u00e9e, accessible par Internet,  par le secr\u00e9tariat et les m\u00e9decins\u00a0;</li> <li>la prise de RV est normalement faite par le secr\u00e9tariat. Elle peut \u00eatre faite \u00e9galement par les m\u00e9decins eux-m\u00eames. C'est le cas notamment lorsqu'\u00e0 la fin d'une consultation, le m\u00e9decin fixe lui-m\u00eame un nouveau RV \u00e0 son patient.</li> </ul> <p>L'architecture du service de prise de RV est le suivant :</p> <p>Les m\u00e9decins gagnent en efficacit\u00e9 s'ils n'ont plus \u00e0 g\u00e9rer les RV. S'ils sont suffisamment nombreux, leur contribution aux frais de fonctionnement du secr\u00e9tariat sera faible. Nous appellerons l'application [RdvMedecins]. Nous pr\u00e9sentons ci-dessous des copies d'\u00e9cran de son fonctionnement.</p> <p>La page d'accueil de l'application est la suivante :</p> <p></p> <p>A partir de cette premi\u00e8re page, l'utilisateur (Secr\u00e9tariat, M\u00e9decin) va engager un certain nombre d'actions. Nous les pr\u00e9sentons ci-dessous. La vue de gauche pr\u00e9sente la vue \u00e0 partir de laquelle l'utilisateur fait une demande, la vue de droite la r\u00e9ponse envoy\u00e9e par le serveur.</p>"},{"location":"letude-de-cas.html#22-la-base-de-donnees","title":"2.2. La base de donn\u00e9es","text":"<p>La base de donn\u00e9es utilis\u00e9e par l'application NHibernate est une base de donn\u00e9es MySQL5 avec quatre tables :</p> <p></p> <p>Elle nous servira de r\u00e9f\u00e9rence pour construire toutes nos bases.</p>"},{"location":"letude-de-cas.html#221-la-table-medecins","title":"2.2.1. La table [MEDECINS]","text":"<p>Elle contient des informations sur les m\u00e9decins g\u00e9r\u00e9s par l'application [RdvMedecins].</p> <ul> <li>ID : n\u00b0 identifiant le m\u00e9decin - cl\u00e9 primaire de la table</li> <li>VERSION : n\u00b0 identifiant la version de la ligne dans la table. Ce nombre est incr\u00e9ment\u00e9 de 1 \u00e0 chaque fois qu'une modification est apport\u00e9e \u00e0 la ligne.</li> <li>NOM : le nom du m\u00e9decin</li> <li>PRENOM : son pr\u00e9nom</li> <li>TITRE : son titre (Melle, Mme, Mr)</li> </ul>"},{"location":"letude-de-cas.html#222-la-table-clients","title":"2.2.2. La table [CLIENTS]","text":"<p>Les clients des diff\u00e9rents m\u00e9decins sont enregistr\u00e9s dans la table [CLIENTS] :</p> <ul> <li>ID : n\u00b0 identifiant le client - cl\u00e9 primaire de la table</li> <li>VERSION : n\u00b0 identifiant la version de la ligne dans la table. Ce nombre est incr\u00e9ment\u00e9 de 1 \u00e0 chaque fois qu'une modification est apport\u00e9e \u00e0 la ligne.</li> <li>NOM : le nom du client</li> <li>PRENOM : son pr\u00e9nom</li> <li>TITRE : son titre (Melle, Mme, Mr)</li> </ul>"},{"location":"letude-de-cas.html#223-la-table-creneaux","title":"2.2.3. La table [CRENEAUX]","text":"<p>Elle liste les cr\u00e9neaux horaires o\u00f9 les RV sont possibles : </p> <ul> <li>ID : n\u00b0 identifiant le cr\u00e9neau horaire - cl\u00e9 primaire de la table</li> <li>VERSION : n\u00b0 identifiant la version de la ligne dans la table. Ce nombre est incr\u00e9ment\u00e9 de 1 \u00e0 chaque fois qu'une modification est apport\u00e9e \u00e0 la ligne.</li> <li>ID_MEDECIN : n\u00b0 identifiant le m\u00e9decin auquel appartient ce cr\u00e9neau \u2013 cl\u00e9 \u00e9trang\u00e8re sur la colonne MEDECINS(ID).</li> <li>HDEBUT : heure d\u00e9but cr\u00e9neau</li> <li>MDEBUT : minutes d\u00e9but cr\u00e9neau</li> <li>HFIN : heure fin cr\u00e9neau</li> <li>MFIN : minutes fin cr\u00e9neau</li> </ul> <p>La seconde ligne de la table [CRENEAUX] (cf [1] ci-dessus) indique, par exemple, que le cr\u00e9neau n\u00b0 2 commence \u00e0 8 h 20 et se termine \u00e0 8 h 40 et appartient au m\u00e9decin n\u00b0 1 (Mme Marie PELISSIER).</p>"},{"location":"letude-de-cas.html#224-la-table-rv","title":"2.2.4. La table [RV]","text":"<p>Elle liste les RV pris pour chaque m\u00e9decin :</p> <ul> <li>ID : n\u00b0 identifiant le RV de fa\u00e7on unique \u2013 cl\u00e9 primaire</li> <li>JOUR : jour du RV</li> <li>ID_CRENEAU : cr\u00e9neau horaire du RV - cl\u00e9 \u00e9trang\u00e8re sur la colonne [ID] de la table [CRENEAUX] \u2013 fixe \u00e0 la fois le cr\u00e9neau horaire et le m\u00e9decin concern\u00e9.</li> <li>ID_CLIENT : n\u00b0 du client pour qui est faite la r\u00e9servation \u2013 cl\u00e9 \u00e9trang\u00e8re sur la colonne [ID] de la table [CLIENTS]</li> </ul> <p>Cette table a une contrainte d'unicit\u00e9 sur les valeurs des colonnes jointes (JOUR, ID_CRENEAU) :</p> <pre><code>ALTER TABLE RV ADD CONSTRAINT UNQ1_RV UNIQUE (JOUR, ID_CRENEAU);\n</code></pre> <p>Si une ligne de la table[RV] a la valeur (JOUR1, ID_CRENEAU1) pour les colonnes (JOUR, ID_CRENEAU), cette valeur ne peut se retrouver nulle part ailleurs. Sinon, cela signifierait que deux RV ont \u00e9t\u00e9 pris au m\u00eame moment pour le m\u00eame m\u00e9decin. D'un point de vue programmation Java, le pilote JDBC de la base lance une SQLException lorsque ce cas se produit.</p> <p>La ligne d'id \u00e9gal \u00e0 7 (cf [1] ci-dessus) signifie qu'un RV a \u00e9t\u00e9 pris pour le cr\u00e9neau n\u00b0 10 et le client n\u00b0 2 le 10/09/2006. La table [CRENEAUX] nous apprend que le cr\u00e9neau n\u00b0 10 correspond au cr\u00e9neau horaire 11 h - 11 h 20 et appartient au m\u00e9decin n\u00b0 1 (Mme Marie PELISSIER). La table [CLIENTS] nous apprend que le client n\u00b0 2 est Mme Christine GERMAN.</p> <p>Cette \u00e9tude de cas a fait l'objet d'un article Java [http://tahe.developpez.com/java/primefaces] dans lequel on utilise l'ORM Hibernate pour Java.</p>"}]}